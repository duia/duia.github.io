<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="jvm,虚拟机,">





  <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">






<meta name="description" content="1.对象是否可回收1.1引用计数算法引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时候计数器值为0的对象就是不可能再被使用的对象。 客观来说，引用计数算法的实现简单，判定效率高，在大部分情况下都是不错的算法，但是在主流的java虚拟机里面都没有选用该算法进行内存管理，主要原因是它很难解决对象之间相互循环引用的情况。如下面代码例子">
<meta name="keywords" content="jvm,虚拟机">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟机学习之二：垃圾收集器和内存分配策略（转载）">
<meta property="og:url" content="https://duia.github.io/2019/02/26/虚拟机学习之二：垃圾收集器和内存分配策略（转载）/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="1.对象是否可回收1.1引用计数算法引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时候计数器值为0的对象就是不可能再被使用的对象。 客观来说，引用计数算法的实现简单，判定效率高，在大部分情况下都是不错的算法，但是在主流的java虚拟机里面都没有选用该算法进行内存管理，主要原因是它很难解决对象之间相互循环引用的情况。如下面代码例子">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://duia.github.io/upload/2019/2/fa5ab4f8625338ec9983cc7fcc4280a78b020190322114841890.jpg">
<meta property="og:updated_time" content="2019-05-23T12:00:00.095Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="虚拟机学习之二：垃圾收集器和内存分配策略（转载）">
<meta name="twitter:description" content="1.对象是否可回收1.1引用计数算法引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时候计数器值为0的对象就是不可能再被使用的对象。 客观来说，引用计数算法的实现简单，判定效率高，在大部分情况下都是不错的算法，但是在主流的java虚拟机里面都没有选用该算法进行内存管理，主要原因是它很难解决对象之间相互循环引用的情况。如下面代码例子">
<meta name="twitter:image" content="https://duia.github.io/upload/2019/2/fa5ab4f8625338ec9983cc7fcc4280a78b020190322114841890.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://duia.github.io/2019/02/26/虚拟机学习之二：垃圾收集器和内存分配策略（转载）/">





  <title>虚拟机学习之二：垃圾收集器和内存分配策略（转载） | 个人博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d05b0991ea544c8d9c4cb7a57ff5fc4d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-technology">
          <a href="/technology/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-file-text"></i> <br>
            
            技术关注
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2019/02/26/虚拟机学习之二：垃圾收集器和内存分配策略（转载）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">虚拟机学习之二：垃圾收集器和内存分配策略（转载）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T13:25:00+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/" itemprop="url" rel="index">
                    <span itemprop="name">服务器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-对象是否可回收"><a href="#1-对象是否可回收" class="headerlink" title="1.对象是否可回收"></a>1.对象是否可回收</h2><h3 id="1-1引用计数算法"><a href="#1-1引用计数算法" class="headerlink" title="1.1引用计数算法"></a>1.1引用计数算法</h3><p>引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时候计数器值为0的对象就是不可能再被使用的对象。</p>
<p>客观来说，引用计数算法的实现简单，判定效率高，在大部分情况下都是不错的算法，但是在主流的java虚拟机里面都没有选用该算法进行内存管理，主要原因是它很难解决对象之间相互循环引用的情况。如下面代码例子：</p>
<p>配置：输出垃圾回收日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC</span><br></pre></td></tr></table></figure>
<p>代码： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line"></span><br><span class="line">	private ReferenceCountingGC instance = null;</span><br><span class="line"></span><br><span class="line">	private static final int _1M = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">	private byte[] bsize = new byte[2 * _1M];</span><br><span class="line"></span><br><span class="line">	public static void testGC() &#123;</span><br><span class="line">		ReferenceCountingGC rc1 = new ReferenceCountingGC();</span><br><span class="line">		ReferenceCountingGC rc2 = new ReferenceCountingGC();</span><br><span class="line">		</span><br><span class="line">		//两个对象互相引用</span><br><span class="line">		rc1.instance = rc2;</span><br><span class="line">		rc2.instance = rc1;</span><br><span class="line">		</span><br><span class="line">		rc1 = null;</span><br><span class="line">		rc2 = null;</span><br><span class="line">		//提醒虚拟机执行垃圾回收</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		testGC();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  6092K-&gt;736K(125952K), 0.0009621 secs]</span><br><span class="line">[Full GC (System.gc())  736K-&gt;612K(125952K), 0.0068694 secs]</span><br></pre></td></tr></table></figure>
<p> 从运行结果中可以清楚看到，GC日志中包含6092K-&gt;736K，意味着虚拟机并没有因为这两个对象相互引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否或者。（配置-XX:+PrintGC或者-verbose:gc输出基本回收信息，配置-XX:+PrintGCDetails可以输出详细的GC信息）。</p>
<h3 id="1-2可达性分析算法"><a href="#1-2可达性分析算法" class="headerlink" title="1.2可达性分析算法"></a>1.2可达性分析算法</h3><p>在虚拟机的主流实现中，都是通过可达性分析算法来判定对象是否存活的。这个算法的基本思路就是：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（也就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>在java语言中可以作为“GC Roots”的对象包括以下几种：</p>
<ul>
<li>虚拟机栈中引用的对象，也就是栈帧中本地变量表中的对象。</li>
<li>方法区中静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（一般说的是Native方法）引用的对象。</li>
</ul>
<p>如下面图中所示：虽然obj5、obj6、obj7之间相互引用但是它们到GC Roots没有可达的调用链，所以他们将会被判定为可回收的对象。</p>
<p><img src="/upload/2019/2/fa5ab4f8625338ec9983cc7fcc4280a78b020190322114841890.jpg" alt="image"></p>
<h3 id="1-3对象引用类别"><a href="#1-3对象引用类别" class="headerlink" title="1.3对象引用类别"></a>1.3对象引用类别</h3><p>在JDK1.2之前定义引用：如果reference类型的数据中存储的数值代表另一块内存的起始地址，就称这块内存代表着一个引用。这种定义虽然比较纯粹但是太过狭隘，我们实际中更希望能代表一种情况：当内存空间足够时，则保留在内存之中，当内存空间在进行垃圾回收之后依然比较紧张，则可以抛弃这些对象。所以在JDK1.2之后java就对引用概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。这四种引用强度依次减弱。</p>
<ul>
<li>强引用：这种引用在代码中普遍存在，类似“Object obj = new Object()”这类的引用只要引用还在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用：这种引用用来描述一些“还有用但并非必须”的对象，对于软引用关联的对象，在系统将要发生内存溢出之前，会将这些对象列入回收对象之中进行二次回收，如果回收之后依然没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用：是用来描述非必须对象的，但它的强度比软引用更弱一些，被若引用关联的对象只能生存到下一次垃圾回收之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉被弱引用关联的对象。</li>
<li>虚引用：也被成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用存在完全不会对其生存时间产生影响，也不能通过虚引用取得一个对象实例。为对象设置虚引用的唯一目的就是能够在对象被回收时收到一个通知。</li>
</ul>
<h3 id="1-4finalize方法"><a href="#1-4finalize方法" class="headerlink" title="1.4finalize方法"></a>1.4finalize方法</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候他们暂时处于“缓刑”阶段，要真正宣布一个对象死亡，至少要经理两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的调用链，那么这个对象将会被进行第一次标记并且进行一次筛选，筛选的条件就是是否有必要执行finalize方法，如果没有覆盖该方法或者已经被虚拟机调用过，就会被认为“没有必要执行”。如果被判定为有必要执行finalize方法，就会将对象放置在一个叫做“F-Queue”的队列中，并由一个虚拟机自建的优先级低的线程去执行它（虚拟机只是触发调用，并不保证执行成功或完成）。如果在执行finalize方法的过程中对象重新与引用链上的任何一个对象建立关联则在稍后的第二次标记中该对象就会被移除“即将回收队列”，如果这时候依然没有和引用链上的对象建立关联，则该对象就会被回收。虚拟机调用对象finalize方法只有一次，不会进行第二次调用。如下代码实例：</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class FinalizeEscapeGC &#123;</span><br><span class="line"></span><br><span class="line">	public static FinalizeEscapeGC SAVE_HOOK = null;</span><br><span class="line">	</span><br><span class="line">	public void isAlive()&#123;</span><br><span class="line">		System.out.println(&quot;yes,I am still alive!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	protected void finalize() throws Throwable &#123;</span><br><span class="line">		super.finalize();</span><br><span class="line">		//与成员变量建立关联</span><br><span class="line">		System.out.println(&quot;finalize method executed!&quot;);</span><br><span class="line">		FinalizeEscapeGC.SAVE_HOOK = this;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SAVE_HOOK = new FinalizeEscapeGC();</span><br><span class="line">		//对象第一次拯救自己</span><br><span class="line">		SAVE_HOOK = null;</span><br><span class="line">		System.gc();</span><br><span class="line">		//因为虚拟机调用finalize方法优先级比较低，暂停1s等待执行。</span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line">		if(SAVE_HOOK != null)&#123;</span><br><span class="line">			SAVE_HOOK.isAlive();</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;I am dead!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//第二次时不会再调用finalize方法</span><br><span class="line">		SAVE_HOOK = null;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line">		if(SAVE_HOOK != null)&#123;</span><br><span class="line">			SAVE_HOOK.isAlive();</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;I am dead!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize method executed!</span><br><span class="line">yes,I am still alive!</span><br><span class="line">I am dead!</span><br></pre></td></tr></table></figure>
<p>可以看到回收的第一次执行了finalize方法然后对象没有被回收，第二次时没有调用finalize方法，对象被回收掉了。</p>
<p>这种方法虽然能在对象被回收时自救一次，但在编写代码时不建议使用此种操作。</p>
<h3 id="1-5回收方法区（JDK8中是回收元空间）"><a href="#1-5回收方法区（JDK8中是回收元空间）" class="headerlink" title="1.5回收方法区（JDK8中是回收元空间）"></a>1.5回收方法区（JDK8中是回收元空间）</h3><p>按照JDK7介绍，永久代中的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>
<p>废弃常量：废弃常量的回收和java堆中对象的回收非常类似。以常量池为例，如果一个字符串“abc”已经进入常量池中，但是当前系统中没有任何一个String字符串对象叫做“abc”，也就是没有任何一个对象引用这个“abc”常量，也没有任何一个地方引用这个字面量。这个时候发生内存回收，有必要的话常量池中的“abc”常量会被系统清理出常量池。</p>
<p>无用的类：类的回收判定比较严格要满足一下三个条件才可以会被回收。</p>
<ul>
<li>该类所有的实例都已经被回收。</li>
<li>加载该类的ClassLoader也已经被回收。</li>
<li>该类对应的class对象也没有在任何地方被引用，也就是不能通过反射访问该类。</li>
</ul>
<h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2.垃圾收集算法"></a>2.垃圾收集算法</h2><h3 id="2-1标记-清除算法"><a href="#2-1标记-清除算法" class="headerlink" title="2.1标记-清除算法"></a>2.1标记-清除算法</h3><p>标记-清除算法：最基础的收集算法，主要分为“标记”和“清除”两个阶段完成，首先标记出所有需要回收的对象，在标记完成之后进行统一回收。之所以说它时最基础的收集算法是因为后续的收集算法都是基于这种思路进行对其不足进行改进而得到的。</p>
<p>这种算法有两种不足：第一个就是这两个阶段的效率都不高；第二个是在标记清除之后会产生大量的不连续的内存碎片，空间碎片太多可能会导致在后面程序运行过程中如果分配较大对象时，无法找到足够的连续内存空间，而不得不提前进行下一次垃圾回收。</p>
<h3 id="2-2复制算法"><a href="#2-2复制算法" class="headerlink" title="2.2复制算法"></a>2.2复制算法</h3><p>复制算法：将可用内存分为大小相等的两部分，每次只使用其中的一块，当这一块内存用完，就进行垃圾回收将还存活的对象复制到另一块上面，然后清除掉刚才使用的内存空间。这样做的好处就是每次对整个板块内存进行回收，不用考虑内存碎片等复杂问题。但是这种算法的代价就是讲内存可用空间直接缩小了一半。</p>
<p>在商业虚拟机中都使用这种算法来回收新生代。IBM研究表明大部分情况新生代中有98%的对象会被第一次收集时被回收掉，所以在实现中把内存分为较大的一块Eden空间和两个较小的Survivor空间，比例是8:1:1.每次使用时将新创建的对象分配到Eden区其中一个Surivivor区保存上次回收存活下来的对象，当进行垃圾收集时将Eden和使用中的Survivor中的存活对象复制到另一个Survivor中，然后清空Eden和使用过的Survivor空间，依次循环使用。当然并不是每次存活的对象都不足10%，当存活对象大于10%时Surivivor中的空间就不够使用，就需要依赖其他内存进行分配担保（老年代）。也就是当另一块Surivivor内存不够时就会将存活的对象分配到老年代中。</p>
<h3 id="2-3标记-整理算法"><a href="#2-3标记-整理算法" class="headerlink" title="2.3标记-整理算法"></a>2.3标记-整理算法</h3><p>复制算法在对象存活率较高时就要进行较多的复制操作，从而降低效率。还要预留担保空间，以应对存活对象较多时新生代内存不够分配的情况。所以在老年代提出了“标记-整理”算法，标记同样跟前面的“标记-清除”算法中标记操作一样，但是标记之后不会将对象清除掉，而是将对象移动到整块内存空间的一端，然后直接清理掉边界以外的内存。</p>
<h3 id="2-4分代收集算法"><a href="#2-4分代收集算法" class="headerlink" title="2.4分代收集算法"></a>2.4分代收集算法</h3><p>当前商业虚拟机都采用“分代收集算法”，这种算法只是将整块内存按照对象存活周期分为几个块，一般把java堆分为新生代、老年代。这样就可以根据各个年代特点使用不同算法进行收集。例如在新生代每次回收时都有少量对象可以存活，就是用复制算法，将少量存活对象复制到Survivor区。而老年代对象存活率比较高只有少量对象会被清除掉，就选用“标记-清除”或者“标记-整理”算法。</p>
<h2 id="3-HotSpot算法实现"><a href="#3-HotSpot算法实现" class="headerlink" title="3.HotSpot算法实现"></a>3.HotSpot算法实现</h2><h3 id="3-1枚举根节点"><a href="#3-1枚举根节点" class="headerlink" title="3.1枚举根节点"></a>3.1枚举根节点</h3><p>在可达性分析算法中可以作为GC Roots节点的主要在全局性引用（例如常量、静态属性）或者执行上下文（栈中本地变量表）中。在查找调用链的时候并不会这个检查这里面的引用，因为这样会消耗很多时间。</p>
<p>HotSopt实现中，使用一组称为OopMap的数据结构，在类加载完成的时候就已经计算出来对象“哪些”偏移量上面存储“哪些”数据类型。例如：在JIT编译过程中会在特定位置记录栈和寄存器中哪些位置是引用。这样在GC扫描的时候可以直接引用。</p>
<p>另外在执行GC 的时候所有java线程都必须停顿下来（Stop The World），因为在执行可达性分析算法的时候对象的引用关系不能发生变化。</p>
<h3 id="3-2安全点"><a href="#3-2安全点" class="headerlink" title="3.2安全点"></a>3.2安全点</h3><p>上面提到记录引用的特定位置称为“安全点”，线程在GC的时候需要暂停执行，但并不是在任何地方都可以停下来的，需要线程跑到“安全点”上时如果这时候有GC标识就暂停执行，这样可以保证在GC时引用不会发生变化。</p>
<h3 id="3-3安全区域"><a href="#3-3安全区域" class="headerlink" title="3.3安全区域"></a>3.3安全区域</h3><p>安全区域：指在一段代码片段之中，引用关系不会发生变化。这个区域中的任何位置开始GC 都是安全的。</p>
<h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4.垃圾收集器"></a>4.垃圾收集器</h2><h3 id="4-1Serial收集器"><a href="#4-1Serial收集器" class="headerlink" title="4.1Serial收集器"></a>4.1Serial收集器</h3><p>新生代收集器，复制算法。</p>
<p>Serial收集器是最基本、发展历史最悠久的收集器。这个收集器是一个单线程的收集器，它有一条专门的线程负责垃圾收集工作，更重要的是它在垃圾回收的时候要停止所有其他线程。主要用在Client模式下（用户的桌面场景中）。</p>
<h3 id="4-2ParNew收集器"><a href="#4-2ParNew收集器" class="headerlink" title="4.2ParNew收集器"></a>4.2ParNew收集器</h3><p>新生代收集器，复制算法。</p>
<p>ParNew收集器是Serial收集器的多线程版本。除了使用多线程进行垃圾收集之外其他的所有包括控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial完全一样。</p>
<h3 id="4-3Paralle-Scavenge收集器"><a href="#4-3Paralle-Scavenge收集器" class="headerlink" title="4.3Paralle Scavenge收集器"></a>4.3Paralle Scavenge收集器</h3><p>Parallel Scavenge收集器是一个新生代收集器，也是使用复制算法的收集器，有事并行的多线程收集器。</p>
<p>Paralle Scavenge收集器的特点就是关注吞吐量：运行用户代码时间 / CPU总运行时间（用户代码时间+垃圾收集时间）。</p>
<p>Paralle Scavenge收集器提供了可以配置精准控制吞吐量的参数。所以又称为“吞吐量优先”收集器。</p>
<h3 id="4-4Serial-Old收集器"><a href="#4-4Serial-Old收集器" class="headerlink" title="4.4Serial Old收集器"></a>4.4Serial Old收集器</h3><p>Serial Old收集器是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。</p>
<p>主要给client模式下的虚拟机使用。</p>
<h3 id="4-5Parallel-Old收集器"><a href="#4-5Parallel-Old收集器" class="headerlink" title="4.5Parallel Old收集器"></a>4.5Parallel Old收集器</h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。和Paralle Scavenge收集器搭配实现名副其实的“吞吐量优先”收集器。</p>
<h3 id="4-6CMS收集器"><a href="#4-6CMS收集器" class="headerlink" title="4.6CMS收集器"></a>4.6CMS收集器</h3><p>CMS收集器（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器。CMS收集器主要分四个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>初始标记、重新标记：这两个步骤虽然很快但是还是需要“Stop The World”。</p>
<p>并发标记：进行GC Roots tracing，在这个阶段jvm收集线程会和用户线程并行执行。（时间较长，降低用户系统信息）。</p>
<p>缺点：</p>
<ul>
<li>占用用户CPU资源，4核以上服务器至少占用1/4CPU资源。</li>
<li>产生“浮动垃圾”由于CMS收集器和用户线程并发执行，在收集过程中用户线程可能产生新的垃圾对象。</li>
<li>标记清除算法产生碎片内存空间，多次执行标记清除回收之后要进行一次内存压缩。</li>
</ul>
<h3 id="4-7G1收集器"><a href="#4-7G1收集器" class="headerlink" title="4.7G1收集器"></a>4.7G1收集器</h3><p>G1收集器是当今收集技术最前沿成果之一。</p>
<p>特点：</p>
<ul>
<li>并行和并发，缩短“Stop The World”时间，让用户线程和收集线程并发执行。</li>
<li>分代收集</li>
<li>空间整合，不会产生内存碎片。</li>
<li>可预测停顿时间，可以让使用者明确指定在一个长度为M毫米的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
<p>G1之前的收集器收集范围都是整个新生代或者老年代。而G1收集器将整个java堆划分为多个大小相等的独立区域（Region），虽然还保留着新生代和老年代，但新生代和老年代不再是物理隔离的了，他们都是有一部分Region的集合组成。G1维护一个优先列表记录每个Region回收的价值大小，每次根据允许收集时间，首先回收价值最大的Region。</p>
<h3 id="4-8理解GC日志"><a href="#4-8理解GC日志" class="headerlink" title="4.8理解GC日志"></a>4.8理解GC日志</h3><p>JVM中可以配置使用不同的收集器，不同收集器输出的日志格式虽然相同，但每种收集器都有自己的标识。</p>
<p>例如：</p>
<p>1、配置：”-XX:+UseSerialGC” 使用Serial+Serial Old的收集器组合进行内存回收。</p>
<p>日志格式：[GC (Allocation Failure) [DefNew: 7292K-&gt;612K(9216K), 0.0055084 secs] 7292K-&gt;6756K(19456K), 0.0055700 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </p>
<p>2、配置：”-XX:+UseParallelOldGC” 使用Paralle Scavenge + Parallel Old的收集器组合进行内存回收。</p>
<p>日志格式：[GC (Allocation Failure) –[PSYoungGen: 7292K-&gt;7292K(9216K)] 11388K-&gt;15492K(19456K), 0.0030434 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (Ergonomics) [PSYoungGen: 7292K-&gt;2658K(9216K)] [ParOldGen: 8200K-&gt;8193K(10240K)] 15492K-&gt;10851K(19456K), [Metaspace: 2664K-&gt;2664K(1056768K)], 0.0078503 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </p>
<p>JDK8 HotSopt虚拟机默认使用的是并行收集器，日志如下格式进行讲解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;32K(38400K)] 1943K-&gt;644K(125952K), 0.0004471 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 612K-&gt;611K(87552K)] 644K-&gt;611K(125952K), [Metaspace: 2662K-&gt;2662K(1056768K)], 0.0076396 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>
<p>[GC 和[Full GC 代表收集停顿来下，Full表示有停顿及“Stop The World”。</p>
<p>[PSYongGen 和 [ParOldGen、[Metaspace表示GC发生的区域，[PSYongGen新生代；[ParOldGen老年代；[Metaspace元空间。</p>
<p>区域后面“[ ]”之内的32K-&gt;0K(38400K) 表示：该区域回收之前占用容量-&gt;回收之后占用容量(该区域总容量)。</p>
<p>“[ ]”之外的644K-&gt;611K(125952K)表示：java堆GC之前的占用容量-&gt;GC之后占用容量(java堆总用量)。</p>
<h2 id="5内存分配与回收策略"><a href="#5内存分配与回收策略" class="headerlink" title="5内存分配与回收策略"></a>5内存分配与回收策略</h2><h3 id="5-1对象优先在Eden分配"><a href="#5-1对象优先在Eden分配" class="headerlink" title="5.1对象优先在Eden分配"></a>5.1对象优先在Eden分配</h3><p>通过例子讲解：首先创建4个数组对象allocation1、allocation2、allocation3、allocation4，占用空间分别为2M、2M、2M、4M，然后指定虚拟机堆内存20M，新生代内存10M，新生代中Eden区域Survivor区域占比为8:1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class EdenTest &#123;</span><br><span class="line"></span><br><span class="line">	private static final int _1MB = 1024 * 1024;</span><br><span class="line">    /**</span><br><span class="line">	 * -verbose:gc -Xms20M(堆初始大小) -Xmx20M(堆最大值) -Xmn10M(堆中年轻代大小) -XX:+PrintGCDetails -XX:SurvivorRatio=8(表示Eden与一个Survivor比例为8:1)</span><br><span class="line">	 */</span><br><span class="line">	private static void testAllocation() &#123;</span><br><span class="line">		byte[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">		allocation1 = new byte[2 * _1MB];</span><br><span class="line">		allocation2 = new byte[2 * _1MB];</span><br><span class="line">		allocation3 = new byte[2 * _1MB];</span><br><span class="line">		allocation4 = new byte[4 * _1MB];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		testAllocation();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Serial+Serial Old收集器组合进行内存回收（UseSerialGC配置指定收集器）</p>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+UseSerialGC</p>
<p>运行日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 7292K-&gt;613K(9216K), 0.0050167 secs] 7292K-&gt;6757K(19456K), 0.0050693 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4791K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  59% used [0x00000000ff500000, 0x00000000ff599460, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 2668K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>日志解读</p>
<p>GC (Allocation Failure)：表示向young generation(eden)给新对象申请空间，但是young generation(eden)剩余的合适空间不够所需的大小导致的minor gc。</p>
<p>DefNew：表示新生代使用Serial串行GC垃圾收集器，defNew提供新生代空间信息。</p>
<p>7292K-&gt;613K(9216K)：新生代占用内存7292K -&gt; 收集器回收之后占用内存613K（新生代可用内存9216K）。</p>
<p>7292K-&gt;6757K(19456K)：java堆被占用内存7292K -&gt; 收集器回收之后占用内存6757K （堆内存总空间19456K）。</p>
<p>Heap则表示此时堆内存中每个区域分配内存大小以及被使用的空间比例。</p>
<p>下面我们通过日志分析allocation1、allocation2、allocation3、allocation4这四个对象分配的位置。</p>
<p>首先日志的第一行进行新生代收集出现日志：7292K-&gt;613K(9216K)，说明allocation1、allocation2、allocation3这三个对象共计6M大小在Eden区，收集过后使用空间为613K，对象被移走，正常情况下Eden区对象首次会被移到其中一个Survivor区，但是Survivor区空间只用1M不足存放6M对象大小，所以这些对象直接被移送到了老年代中。堆内存收集前后并没有发生大的变化7292K-&gt;6757K(19456K)，也表示这些对象还在堆内存中，只是从新生代的Eden区直接被移送到了老年代中。</p>
<p>从最后堆内存各个区域内存占用的情况也可以分析得出我们的推论</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>大小</th>
<th>使用比例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>新生代：eden</td>
<td>8192K</td>
<td>51%</td>
<td>被占用4M空间，被allocation4占用</td>
</tr>
<tr>
<td>新生代：from</td>
<td>1024K</td>
<td>59%</td>
<td>空间不足1M，并未存放测试对象</td>
</tr>
<tr>
<td>新生代：to</td>
<td>1024K</td>
<td>0%</td>
<td>Survivor只有一个被使用</td>
</tr>
<tr>
<td>老年代区域</td>
<td>10240K</td>
<td>60%</td>
<td>老年代占用6M，为3个2M的对象</td>
</tr>
</tbody>
</table>
<h3 id="5-2大对象直接进入老年代"><a href="#5-2大对象直接进入老年代" class="headerlink" title="5.2大对象直接进入老年代"></a>5.2大对象直接进入老年代</h3><p>大对象就是在虚拟机中需要大量连续空间存放的对象。比如字符串对象或数组等。</p>
<p>虚拟提供一个-XX:PretenureSizeThreshold参数，可以设置令大于该参数值的对象直接进入老年代。这个参数只对Serial和ParNew收集器有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class PretenureSizeThresholdTest &#123;</span><br><span class="line"></span><br><span class="line">	private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * -verbose:gc -Xms20M(堆初始大小) -Xmx20M(堆最大值) -Xmn10M(堆中年轻代大小)</span><br><span class="line">	 * -XX:+PrintGCDetails -XX:SurvivorRatio=8(表示Eden与一个Survivor比例为8:1)</span><br><span class="line">	 * -XXPretenureSizeThreshold=3145728(超过该值的对象直接进入老年代)</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		byte[] allocation;</span><br><span class="line">		allocation = new byte[4 * _1MB];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM执行参数配置：</p>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+UseSerialGC -XX:PretenureSizeThreshold=3145728</p>
<p>执行日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1312K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  16% used [0x00000000fec00000, 0x00000000fed480b0, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 2670K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>其中the space 10240K,  40% used，老年代使用40%，说明对象直接进入了老年代区域。</p>
<h3 id="5-3长期存活的对象将进入老年代"><a href="#5-3长期存活的对象将进入老年代" class="headerlink" title="5.3长期存活的对象将进入老年代"></a>5.3长期存活的对象将进入老年代</h3><pre><code>虚拟机采用分代收集的思想来管理内存，虚拟机为每个对象定义了一个年龄（Age）计数器，如果对象在Eden出生，并经历一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。此后对象在Survivor中每熬过一次Minor GC对象年龄就增加1岁，当年龄增加到一定程度时（默认15岁），该对象就会被移动到老年代中。对象晋升到老年代的这个阈值可以通过参数设定 -XX:MaxTenuringThreshold=2，表示对象经理过两次Minor GC 就可以被移动到老年代。
</code></pre><h3 id="5-4动态对象年龄判定"><a href="#5-4动态对象年龄判定" class="headerlink" title="5.4动态对象年龄判定"></a>5.4动态对象年龄判定</h3><p>对象移动到老年代的另一个规则：当Survivor空间中相同年龄的对象所占用空间大小的总和大于Survivor空间的一半时，年龄大于或等于该年龄的对象就可以被直接移动到老年代中。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/jvm/" rel="tag"># jvm</a>
          
            <a href="/tags/虚拟机/" rel="tag"># 虚拟机</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/26/虚拟机学习之一：java内存区域与内存溢出异常（转载）/" rel="next" title="虚拟机学习之一：java内存区域与内存溢出异常（转载）">
                <i class="fa fa-chevron-left"></i> 虚拟机学习之一：java内存区域与内存溢出异常（转载）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/21/Nginx Linux详细安装部署教程及配置SSL/" rel="prev" title="Nginx Linux详细安装部署教程及配置SSL">
                Nginx Linux详细安装部署教程及配置SSL <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/pengcheng.jpg" alt="W鹏程">
            
              <p class="site-author-name" itemprop="name">W鹏程</p>
              <p class="site-description motion-element" itemprop="description">宁在地狱为王，不愿天堂为仆</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/duia" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="duia.online@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-对象是否可回收"><span class="nav-number">1.</span> <span class="nav-text">1.对象是否可回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1引用计数算法"><span class="nav-number">1.1.</span> <span class="nav-text">1.1引用计数算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2可达性分析算法"><span class="nav-number">1.2.</span> <span class="nav-text">1.2可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3对象引用类别"><span class="nav-number">1.3.</span> <span class="nav-text">1.3对象引用类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4finalize方法"><span class="nav-number">1.4.</span> <span class="nav-text">1.4finalize方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5回收方法区（JDK8中是回收元空间）"><span class="nav-number">1.5.</span> <span class="nav-text">1.5回收方法区（JDK8中是回收元空间）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-垃圾收集算法"><span class="nav-number">2.</span> <span class="nav-text">2.垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1标记-清除算法"><span class="nav-number">2.1.</span> <span class="nav-text">2.1标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2复制算法"><span class="nav-number">2.2.</span> <span class="nav-text">2.2复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3标记-整理算法"><span class="nav-number">2.3.</span> <span class="nav-text">2.3标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4分代收集算法"><span class="nav-number">2.4.</span> <span class="nav-text">2.4分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-HotSpot算法实现"><span class="nav-number">3.</span> <span class="nav-text">3.HotSpot算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1枚举根节点"><span class="nav-number">3.1.</span> <span class="nav-text">3.1枚举根节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2安全点"><span class="nav-number">3.2.</span> <span class="nav-text">3.2安全点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3安全区域"><span class="nav-number">3.3.</span> <span class="nav-text">3.3安全区域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-垃圾收集器"><span class="nav-number">4.</span> <span class="nav-text">4.垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1Serial收集器"><span class="nav-number">4.1.</span> <span class="nav-text">4.1Serial收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2ParNew收集器"><span class="nav-number">4.2.</span> <span class="nav-text">4.2ParNew收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3Paralle-Scavenge收集器"><span class="nav-number">4.3.</span> <span class="nav-text">4.3Paralle Scavenge收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4Serial-Old收集器"><span class="nav-number">4.4.</span> <span class="nav-text">4.4Serial Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5Parallel-Old收集器"><span class="nav-number">4.5.</span> <span class="nav-text">4.5Parallel Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6CMS收集器"><span class="nav-number">4.6.</span> <span class="nav-text">4.6CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7G1收集器"><span class="nav-number">4.7.</span> <span class="nav-text">4.7G1收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8理解GC日志"><span class="nav-number">4.8.</span> <span class="nav-text">4.8理解GC日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5内存分配与回收策略"><span class="nav-number">5.</span> <span class="nav-text">5内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1对象优先在Eden分配"><span class="nav-number">5.1.</span> <span class="nav-text">5.1对象优先在Eden分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2大对象直接进入老年代"><span class="nav-number">5.2.</span> <span class="nav-text">5.2大对象直接进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3长期存活的对象将进入老年代"><span class="nav-number">5.3.</span> <span class="nav-text">5.3长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4动态对象年龄判定"><span class="nav-number">5.4.</span> <span class="nav-text">5.4动态对象年龄判定</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">W鹏程</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
