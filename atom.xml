<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://duia.github.io/"/>
  <updated>2019-05-23T12:00:00.006Z</updated>
  <id>https://duia.github.io/</id>
  
  <author>
    <name>W鹏程</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流</title>
    <link href="https://duia.github.io/2019/05/16/Sentinel%20+%20Zookeeper%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%20+%20Springboot%E5%AE%A2%E6%88%B7%E7%AB%AF%20+%20%E9%9B%86%E7%BE%A4%E9%99%90%E6%B5%81/"/>
    <id>https://duia.github.io/2019/05/16/Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流/</id>
    <published>2019-05-16T11:45:00.000Z</published>
    <updated>2019-05-23T12:00:00.006Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/9434884/43697219-3cb4ef3a-9975-11e8-9a9c-73f4f537442d.png" alt="Sentinel Logo"></p><h1 id="Sentinel-分布式系统的流量防卫兵"><a href="#Sentinel-分布式系统的流量防卫兵" class="headerlink" title="Sentinel: 分布式系统的流量防卫兵"></a>Sentinel: 分布式系统的流量防卫兵</h1><h2 id="Sentinel-是什么？"><a href="#Sentinel-是什么？" class="headerlink" title="Sentinel 是什么？"></a>Sentinel 是什么？</h2><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>快速上手可以参照官网给出的<a href="https://github.com/alibaba/Sentinel/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">新手指南</a>进行尝试了解。</p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5" target="_blank" rel="noopener">详细介绍</a></p><p>本文主要对实际开发中遇到的问题，以及官网推荐的使用方式进行整合的过程遇到的问题进行整理。</p><h2 id="Sentinel-Zookeeper动态数据源-Springboot客户端-集群限流"><a href="#Sentinel-Zookeeper动态数据源-Springboot客户端-集群限流" class="headerlink" title="Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流"></a>Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流</h2><p>控制台可以使用官方给提供的jar，springboot项目最快的集成过程可以参考<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/wiki/Sentinel" target="_blank" rel="noopener">Spring Cloud Alibaba Sentinel</a>，也可以看我如下整理的代码进行快速集成使用。</p><h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><p>下载官方提供的Sentinel 控制台jar，参考<a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0" target="_blank" rel="noopener">Sentinel 控制台</a>进行启动，其实就是普通的springboot项目，可以指定自己的启动参数，自行启动，不再赘诉。</p><p>首次启动登陆，左边的菜单和右边的内容为空，别急，因为我们还没有接入客户端。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在要接入Sentinel的springboot项目的pom.xml添加如下代码，放到适合的位置。<code>spring-cloud-starter-alibaba-sentinel</code>包含了所有官网提供能的关于sentinel的组件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springboot 1.x 用0.1.2.RELEASE  springboot 2.x 用0.2.2.RELEASE--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>application.properties中添加一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.sentinel.transport.dashboard=localhost:8080</span><br></pre></td></tr></table></figure></p><p>集成完成。</p><p>启动我们项目进行访问。返回Sentinel 控制台即可看到如下界面。</p><p><img src="https://github.com/alibaba/Sentinel/wiki/image/resourceTree.png" alt="簇点链路"></p><p>每个url都是我们刚才访问过的路径，对于Sentinel称之为资源，即我们可以对该资源进行限流等的操作。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>Sentinel定义资源分为5种，具体可以查看<a href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">定义资源</a>，我们可以根据业务的需要进行资源的选择。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>Sentinel<a href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E8%A7%84%E5%88%99%E7%9A%84%E7%A7%8D%E7%B1%BB" target="_blank" rel="noopener">规则的种类</a>如下图，有5种规则供我们使用。</p><p><img src="https://user-images.githubusercontent.com/9434884/48189045-2ae58400-e37a-11e8-84aa-2e2c0dd042e2.png" alt="规则管理"></p><p>以上是最基本的配置，如果不做任何修改，Dashboard的推送规则方式是通过 API 将规则推送至客户端并直接更新到内存中：</p><p><img src="https://camo.githubusercontent.com/96b07d598c9eee5a513801cecc68f266fbe58d14/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f34373638382f313533363636303239363237332d34663434306262612d356239652d343230352d393430322d6662363038336236363931322e706e67" alt></p><p>此模式为原始模式，<strong>缺点</strong>是每次重启客户端后所有的规则将丢失。Sentinel还提供了Pull 模式、Push 模式。详细可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel" target="_blank" rel="noopener">在生产环境中使用 Sentinel</a>。</p><p>官方给的建议：<strong>生产环境下一般采用 push 模式的数据源</strong>。要使用<a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel#Push%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">push 模式</a>就需要对官方给提供的控制台进行改造，以及对客户端进行相应的配置。</p><p><img src="https://user-images.githubusercontent.com/9434884/45406233-645e8380-b698-11e8-8199-0c917403238f.png" alt></p><h2 id="控制台改造"><a href="#控制台改造" class="headerlink" title="控制台改造"></a>控制台改造</h2><p>官方给的说明有点混乱，整合过程中遇了不少问题，所幸是一步步走出来了。以下就将整理过程整理出来。</p><p><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel源码</a>，要改造控制台，源码是必不可少的，下载源码。其实要改造的就是加入Zookeeper动态数据源，源码中已经有了代码，可以拿来直接使用（也提供了apollo、nacos数据源的支持），位置在<code>sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/rule</code>下，将<code>zookeeper</code>包从test拖到main包下，修改<code>FlowControllerV2.java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"flowRuleZookeeperProvider"</span>)</span><br><span class="line"><span class="keyword">private</span> DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"flowRuleZookeeperPublisher"</span>)</span><br><span class="line"><span class="keyword">private</span> DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;</span><br></pre></td></tr></table></figure></p><p>这部分是<code>sentinel-dashboard</code>隐藏的代码及功能，应该是处于开发阶段，估计后期会有更好的集成方式。</p><p>启动sentinel-dashboard项目，点击菜单<strong>流控规则</strong>，可以看到访问路径如：<code>&lt;localhost:port&gt;/#/dashboard/flow/xxxxx</code>，需要手动添加“v2”为<code>&lt;localhost:port&gt;/#/dashboard/v2/flow/xxxxx</code>，一个隐藏的界面，此处添加的流控规则会被保存到我们配置好的zookeeper中。</p><p>或者找到<code>sidebar.html</code>将如下代码放开：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"dashboard.flow(&#123;app: entry.app&#125;)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-filter"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>  流控规则 V2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>控制台会多一菜单。</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>客户端集成相对容易一点，<code>application.properties</code>中添加如下代码即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.sentinel.datasource.ds3.zk.server-addr=localhost:2181</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.group-id=SENTINEL_GROUP</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.data-id=xxxxxx</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.rule-type=flow</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.data-type=json</span><br></pre></td></tr></table></figure></p><p>官方给的例子点<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/sentinel-example/sentinel-core-example/readme-zh.md" target="_blank" rel="noopener">Sentinel Example</a>。</p><p>在整合过程中废了点时间，因为官方给的说明有点混乱，是给控制台的代码还是给客户端的代码没有明确的说明，还有如上代码中的group-id、data-id等也没有明确的说明，一不注意配置不对，流控规则就不会生效。</p><p><code>InitFunc</code>接口，可以用作<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95#%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%BA%90" target="_blank" rel="noopener">注册数据源</a>，在尝试过程中发现这段代码配置到客户端是起作用的，即相当于上边客户端集成的在<code>application.properties</code>中添加的那段代码作用一样。具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; ruleSource = <span class="keyword">new</span> ZookeeperDataSource&lt;&gt;(remoteAddress, groupId,</span><br><span class="line">flowDataId, source -&gt; JSON.parseObject(source, <span class="keyword">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));</span><br><span class="line">FlowRuleManager.register2Property(ruleSource.getProperty());</span><br></pre></td></tr></table></figure></p><p>其中groupId、flowDataId注意，需要与控制台改造中设计到的zookeeper的path一致，否则规则不生效。</p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7" target="_blank" rel="noopener">集群流控</a>，控制台已经集成了该功能，我们拿来可以直接用，省去了调用API的麻烦，但该功能是需要客户端的支持。</p><p>Sentinel 集群限流服务端有两种启动方式：独立模式（Alone）；嵌入模式（Embedded）。调试集群限流看代码的过程中发现了<a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-cluster/sentinel-demo-cluster-embedded" target="_blank" rel="noopener">嵌入模式Demo</a>，此处是给springboot客户端集成的demo示例，将entity包、init包、DemoConstants类、META-INF文件夹及它们里边的类和文件，复制到咱们的springboot项目对应位置，自行配置集群，通过jmeter压测接口，会发现集群限流起作用了。</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>1、在控制台的日志里面显示setRules:success，但设置限流规则为什么不显示（不起作用）</p><pre><code>查看fastjson 版本，移除我们引入的jar，使用sentinel中的版本。</code></pre><p>2、convert error：客户端报错有这样的关键字，可以在Sentinel控制台的源码中找到<code>FlowRuleEntity.java</code>，将以下属性添加注解<code>@JSONField(serialize = false)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> String app;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> String ip;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Date gmtCreate;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Date gmtModified;</span><br></pre></td></tr></table></figure></p><p>3、集群限流不准确，项目添加以下启动参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dcsp.sentinel.log.use.pid=true</span><br></pre></td></tr></table></figure></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Sentinel官方源码中其实已经包含了所有需要到的代码，就是没有比较系统直白的使用demo，可能也是还在开发阶段吧，期待官方的完善。</p><p>个人感觉目前源码中缺失的功能，亦或是我没有发现的功能，除了集群限流规则能做到持久化数据库，其它规则没有提供，包括集群应用的配置信息也没有持久化。所幸的是如果不配置客户端集群功能，即人为设置token server失败，如果Token Server不可用，各应用自动退化到单机限流。</p><p>官方提供了各种接口供我们使用，可以根据自己的需要，自行设置。还有更多功能等待挖掘，有什么更好的使用方式可以联系我，一起研究。</p><p>相关链接：<br><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel源码</a></p><p><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba" target="_blank" rel="noopener">Sentinel 与 Spring Boot / Spring Cloud 的整合</a></p><p><a href="https://github.com/all4you/sentinel-tutorial" target="_blank" rel="noopener">Sentinel 教程，包括原理分析，源码阅读，实战分享</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/9434884/43697219-3cb4ef3a-9975-11e8-9a9c-73f4f537442d.png&quot; alt=&quot;Sentinel Logo&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="spring boot" scheme="https://duia.github.io/categories/JAVA/spring-boot/"/>
    
    
      <category term="Sentinel" scheme="https://duia.github.io/tags/Sentinel/"/>
    
      <category term="限流" scheme="https://duia.github.io/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Nginx Linux详细安装部署教程及配置SSL</title>
    <link href="https://duia.github.io/2019/03/21/Nginx%20Linux%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B%E5%8F%8A%E9%85%8D%E7%BD%AESSL/"/>
    <id>https://duia.github.io/2019/03/21/Nginx Linux详细安装部署教程及配置SSL/</id>
    <published>2019-03-21T03:48:00.000Z</published>
    <updated>2019-05-23T12:00:00.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Nginx简介"><a href="#一、Nginx简介" class="headerlink" title="一、Nginx简介"></a>一、Nginx简介</h2><p>Nginx是一个web服务器也可以用来做负载均衡及反向代理使用，目前使用最多的就是负载均衡，具体简介我就不介绍了百度一下有很多，下面直接进入安装步骤</p><h2 id="二、Nginx安装"><a href="#二、Nginx安装" class="headerlink" title="二、Nginx安装"></a>二、Nginx安装</h2><h3 id="1、下载Nginx及相关组件"><a href="#1、下载Nginx及相关组件" class="headerlink" title="1、下载Nginx及相关组件"></a>1、下载Nginx及相关组件</h3><p>Linux系统是Centos 6.5 64位，我直接切换到root用户下安装</p><p>进入用户目录下载程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# cd /usr/local/src/</span><br></pre></td></tr></table></figure><p>下载相关组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# wget http://nginx.org/download/nginx-1.10.2.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# wget http://www.openssl.org/source/openssl-fips-2.0.10.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>安装c++编译环境，如已安装可略过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# yum install gcc-c++</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>期间会有确认提示输入y回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is this ok [y/N]:y</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><h3 id="2、安装Nginx及相关组件"><a href="#2、安装Nginx及相关组件" class="headerlink" title="2、安装Nginx及相关组件"></a>2、安装Nginx及相关组件</h3><p>openssl安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf openssl-fips-2.0.10.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd openssl-fips-2.0.10</span><br><span class="line">[root@localhost openssl-fips-2.0.10]# ./config &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>pcre安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf pcre-8.40.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd pcre-8.40</span><br><span class="line">[root@localhost pcre-8.40]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>zlib安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf zlib-1.2.11.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd zlib-1.2.11</span><br><span class="line">[root@localhost zlib-1.2.11]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>nginx安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf nginx-1.10.2.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd nginx-1.10.2</span><br><span class="line">[root@localhost nginx-1.10.2]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><h3 id="3、启动Nginx"><a href="#3、启动Nginx" class="headerlink" title="3、启动Nginx"></a>3、启动Nginx</h3><p>先找一下nginx安装到什么位置上了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# whereis nginx</span><br><span class="line">nginx: /usr/local/nginx</span><br></pre></td></tr></table></figure><p>进入nginx目录并启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# cd /usr/local/nginx</span><br><span class="line">[root@localhost nginx]# sbin/nginx</span><br><span class="line">sbin/nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>报错了，按照下面方式解决</p><ol><li>用whereis libpcre.so.1命令找到libpcre.so.1在哪里</li><li>用ln -s /usr/local/lib/libpcre.so.1 /lib64命令做个软连接就可以了</li><li>用sbin/nginx启动Nginx</li><li>用ps -aux | grep nginx查看状态</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# whereis libpcre.so.1</span><br><span class="line">[root@localhost nginx]# ln -s /usr/local/lib/libpcre.so.1 /lib64</span><br><span class="line">[root@localhost nginx]# sbin/nginx</span><br><span class="line">[root@localhost nginx]# ps -aux | grep nginx</span><br></pre></td></tr></table></figure><p>进入Linux系统的图形界面，打开浏览器输入localhost会看到下图，说明nginx启动成功<br><img src="https://www.duia.online/upload/2019/2/90-46173693220190320183342795.png" alt="image"></p><p><strong>nginx的基本操作</strong></p><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>停止/重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -s stop(quit、reload)</span><br></pre></td></tr></table></figure><p>命令帮助</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -h</span><br></pre></td></tr></table></figure><p>验证配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="4、简单配置Nginx"><a href="#4、简单配置Nginx" class="headerlink" title="4、简单配置Nginx"></a>4、简单配置Nginx</h3><p>打开nginx配置文件位于nginx目录下的conf文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# vim conf/nginx.conf</span><br></pre></td></tr></table></figure><p>简单介绍一下vim的语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">默认vim打开后是不能录入的，需要按键才能操作，具体如下：</span><br><span class="line">开启编辑：按“i”或者“Insert”键</span><br><span class="line">退出编辑：“Esc”键</span><br><span class="line">退出vim：“:q”</span><br><span class="line">保存vim：“:w”</span><br><span class="line">保存退出vim：“:wq”</span><br><span class="line">不保存退出vim：“:q!”</span><br></pre></td></tr></table></figure><p>“#”代表注释，最重要的是server{}块这部分就代表每一个web站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream testserver&#123;</span><br><span class="line">    server localhost:81;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.domain.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         proxy_pass http://testserver;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加如上代码，监听80端口，将域名访问<code>www.domain.com</code>的访问指到<code>localhost:81</code>，保存退出并且重启nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# ./sbin/nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="5-配置本地域名多服务"><a href="#5-配置本地域名多服务" class="headerlink" title="5.配置本地域名多服务"></a>5.配置本地域名多服务</h3><p>扩展upstream{}、server{}即可实现二级域名访问同一服务器的多服务项目。</p><h3 id="6-开启HTTPS、Nginx-证书部署"><a href="#6-开启HTTPS、Nginx-证书部署" class="headerlink" title="6.开启HTTPS、Nginx 证书部署"></a>6.开启HTTPS、Nginx 证书部署</h3><h4 id="获取证书略"><a href="#获取证书略" class="headerlink" title="获取证书略"></a>获取证书略</h4><h4 id="证书安装"><a href="#证书安装" class="headerlink" title="证书安装"></a>证书安装</h4><p>将域名 <a href="http://www.domain.com" target="_blank" rel="noopener">www.domain.com</a> 的证书文件 <code>1_www.domain.com_bundle.crt</code> 、私钥文件 <code>2_www.domain.com.key</code> 保存到同一个目录，例如 <code>/usr/local/nginx/conf</code> 目录下。<br>修改 Nginx 根目录下 <code>conf/nginx.conf</code> 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate 1_www.domain.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key 2_www.domain.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://testserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，请先执行命令 <code>sbin/nginx –t</code> 测试 Nginx 配置是否有误。若无报错，重启 Nginx 之后，即可使用 <code>https://www.domain.com</code> 来访问。</p><p>相关参数说明如下：</p><table><thead><tr><th>配置文件参数</th><th>说明</th></tr></thead><tbody><tr><td>listen 443</td><td>SSL 访问端口号为 443</td></tr><tr><td>ssl on</td><td>启用 SSL 功能</td></tr><tr><td>ssl_certificate</td><td>证书文件</td></tr><tr><td>ssl_certificate_key</td><td>私钥文件</td></tr><tr><td>ssl_protocols</td><td>使用的协议</td></tr><tr><td>ssl_ciphers</td><td>配置加密套件，写法遵循 openssl 标准</td></tr></tbody></table><p>如果配置完成后出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx:[emerg]unknown directive &quot;ssl&quot;</span><br></pre></td></tr></table></figure><p>因为我们配置这个SSL证书需要引用到nginx的中SSL这模块，然而我们一开始编译的Nginx的时候并没有把SSL模块一起编译进去，所以导致这个错误的出现。</p><h4 id="错误解决步骤"><a href="#错误解决步骤" class="headerlink" title="错误解决步骤"></a>错误解决步骤</h4><p>既然在安装的时候没有编译ssl，难道把nginx卸载重新安装一次？不不不，我们只需要在原有的基础上添加ssl模块就行了。</p><p>我们先来到当初下载nginx的包压缩的解压目录，解压目录应该在<code>/usr/loacl/src/</code>，绝大多数应该都是在这个目录下的，已经是一种规范了。</p><p>来到解压目录下后，按顺序执行一下命令：</p><p>命令1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# ./configure --with-http_ssl_module  //重新添加这个ssl模块</span><br></pre></td></tr></table></figure></p><p>注意如果没有出现错误，则直接看命令2即可 </p><p>执行以上一条命令出现这个错误<code>./configure：错误：SSL模块需要OpenSSL库。</code>，原因是因为缺少了OpenSSL，那我们再来安装一个即可执行：<code>yum -y install openssl openssl-devel</code></p><p>等待OpenSSL的安装完成后，再执行<code>./configure</code> ，最后在执行<code>命令1</code> 即可。</p><p>命令2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# make</span><br></pre></td></tr></table></figure></p><p>不要执行make install，因为make是用来编译的，而make install是安装，不然你整个nginx会重新覆盖的。</p><p>命令3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak // 先将原来的nginx备份想删除也可以</span><br><span class="line"></span><br><span class="line">[root@localhost nginx]# cp objs/nginx /usr/local/nginx/sbin/nginx // objs 目录中是编译后产生的文件</span><br></pre></td></tr></table></figure><p>再次<code>sbin/nginx –t</code>即可看见成功。</p><h4 id="使用全站加密，HTTP-自动跳转-HTTPS（可选）"><a href="#使用全站加密，HTTP-自动跳转-HTTPS（可选）" class="headerlink" title="使用全站加密，HTTP 自动跳转 HTTPS（可选）"></a>使用全站加密，HTTP 自动跳转 HTTPS（可选）</h4><p>对于用户不知道网站可以进行 HTTPS 访问的情况下，让服务器自动把 HTTP 的请求重定向到 HTTPS。</p><p>在服务器这边的话配置的话，可以在页面里加 js 脚本，也可以在后端程序里写重定向，当然也可以在 web 服务器来实现跳转。Nginx 是支持 rewrite 的（只要在编译的时候没有去掉 pcre）</p><p>在 HTTP 的 server 里增加 <code>rewrite ^(.*) https://$host$1 permanent;</code><br>这样就可以实现 80 进来的请求，重定向为 HTTPS 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.duia.online;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         proxy_pass http://haloserver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rewrite ^(.*) https://$host$1 permanent;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Nginx简介&quot;&gt;&lt;a href=&quot;#一、Nginx简介&quot; class=&quot;headerlink&quot; title=&quot;一、Nginx简介&quot;&gt;&lt;/a&gt;一、Nginx简介&lt;/h2&gt;&lt;p&gt;Nginx是一个web服务器也可以用来做负载均衡及反向代理使用，目前使用最多的就是负
      
    
    </summary>
    
      <category term="服务器" scheme="https://duia.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="nginx" scheme="https://duia.github.io/tags/nginx/"/>
    
      <category term="https" scheme="https://duia.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机学习之二：垃圾收集器和内存分配策略（转载）</title>
    <link href="https://duia.github.io/2019/02/26/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://duia.github.io/2019/02/26/虚拟机学习之二：垃圾收集器和内存分配策略（转载）/</id>
    <published>2019-02-26T05:25:00.000Z</published>
    <updated>2019-05-23T12:00:00.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-对象是否可回收"><a href="#1-对象是否可回收" class="headerlink" title="1.对象是否可回收"></a>1.对象是否可回收</h2><h3 id="1-1引用计数算法"><a href="#1-1引用计数算法" class="headerlink" title="1.1引用计数算法"></a>1.1引用计数算法</h3><p>引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时候计数器值为0的对象就是不可能再被使用的对象。</p><p>客观来说，引用计数算法的实现简单，判定效率高，在大部分情况下都是不错的算法，但是在主流的java虚拟机里面都没有选用该算法进行内存管理，主要原因是它很难解决对象之间相互循环引用的情况。如下面代码例子：</p><p>配置：输出垃圾回收日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC</span><br></pre></td></tr></table></figure><p>代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line"></span><br><span class="line">private ReferenceCountingGC instance = null;</span><br><span class="line"></span><br><span class="line">private static final int _1M = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">private byte[] bsize = new byte[2 * _1M];</span><br><span class="line"></span><br><span class="line">public static void testGC() &#123;</span><br><span class="line">ReferenceCountingGC rc1 = new ReferenceCountingGC();</span><br><span class="line">ReferenceCountingGC rc2 = new ReferenceCountingGC();</span><br><span class="line"></span><br><span class="line">//两个对象互相引用</span><br><span class="line">rc1.instance = rc2;</span><br><span class="line">rc2.instance = rc1;</span><br><span class="line"></span><br><span class="line">rc1 = null;</span><br><span class="line">rc2 = null;</span><br><span class="line">//提醒虚拟机执行垃圾回收</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">testGC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  6092K-&gt;736K(125952K), 0.0009621 secs]</span><br><span class="line">[Full GC (System.gc())  736K-&gt;612K(125952K), 0.0068694 secs]</span><br></pre></td></tr></table></figure><p> 从运行结果中可以清楚看到，GC日志中包含6092K-&gt;736K，意味着虚拟机并没有因为这两个对象相互引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否或者。（配置-XX:+PrintGC或者-verbose:gc输出基本回收信息，配置-XX:+PrintGCDetails可以输出详细的GC信息）。</p><h3 id="1-2可达性分析算法"><a href="#1-2可达性分析算法" class="headerlink" title="1.2可达性分析算法"></a>1.2可达性分析算法</h3><p>在虚拟机的主流实现中，都是通过可达性分析算法来判定对象是否存活的。这个算法的基本思路就是：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（也就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p>在java语言中可以作为“GC Roots”的对象包括以下几种：</p><ul><li>虚拟机栈中引用的对象，也就是栈帧中本地变量表中的对象。</li><li>方法区中静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（一般说的是Native方法）引用的对象。</li></ul><p>如下面图中所示：虽然obj5、obj6、obj7之间相互引用但是它们到GC Roots没有可达的调用链，所以他们将会被判定为可回收的对象。</p><p><img src="/upload/2019/2/fa5ab4f8625338ec9983cc7fcc4280a78b020190322114841890.jpg" alt="image"></p><h3 id="1-3对象引用类别"><a href="#1-3对象引用类别" class="headerlink" title="1.3对象引用类别"></a>1.3对象引用类别</h3><p>在JDK1.2之前定义引用：如果reference类型的数据中存储的数值代表另一块内存的起始地址，就称这块内存代表着一个引用。这种定义虽然比较纯粹但是太过狭隘，我们实际中更希望能代表一种情况：当内存空间足够时，则保留在内存之中，当内存空间在进行垃圾回收之后依然比较紧张，则可以抛弃这些对象。所以在JDK1.2之后java就对引用概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。这四种引用强度依次减弱。</p><ul><li>强引用：这种引用在代码中普遍存在，类似“Object obj = new Object()”这类的引用只要引用还在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用：这种引用用来描述一些“还有用但并非必须”的对象，对于软引用关联的对象，在系统将要发生内存溢出之前，会将这些对象列入回收对象之中进行二次回收，如果回收之后依然没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用：是用来描述非必须对象的，但它的强度比软引用更弱一些，被若引用关联的对象只能生存到下一次垃圾回收之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉被弱引用关联的对象。</li><li>虚引用：也被成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用存在完全不会对其生存时间产生影响，也不能通过虚引用取得一个对象实例。为对象设置虚引用的唯一目的就是能够在对象被回收时收到一个通知。</li></ul><h3 id="1-4finalize方法"><a href="#1-4finalize方法" class="headerlink" title="1.4finalize方法"></a>1.4finalize方法</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候他们暂时处于“缓刑”阶段，要真正宣布一个对象死亡，至少要经理两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的调用链，那么这个对象将会被进行第一次标记并且进行一次筛选，筛选的条件就是是否有必要执行finalize方法，如果没有覆盖该方法或者已经被虚拟机调用过，就会被认为“没有必要执行”。如果被判定为有必要执行finalize方法，就会将对象放置在一个叫做“F-Queue”的队列中，并由一个虚拟机自建的优先级低的线程去执行它（虚拟机只是触发调用，并不保证执行成功或完成）。如果在执行finalize方法的过程中对象重新与引用链上的任何一个对象建立关联则在稍后的第二次标记中该对象就会被移除“即将回收队列”，如果这时候依然没有和引用链上的对象建立关联，则该对象就会被回收。虚拟机调用对象finalize方法只有一次，不会进行第二次调用。如下代码实例：</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class FinalizeEscapeGC &#123;</span><br><span class="line"></span><br><span class="line">public static FinalizeEscapeGC SAVE_HOOK = null;</span><br><span class="line"></span><br><span class="line">public void isAlive()&#123;</span><br><span class="line">System.out.println(&quot;yes,I am still alive!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void finalize() throws Throwable &#123;</span><br><span class="line">super.finalize();</span><br><span class="line">//与成员变量建立关联</span><br><span class="line">System.out.println(&quot;finalize method executed!&quot;);</span><br><span class="line">FinalizeEscapeGC.SAVE_HOOK = this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">SAVE_HOOK = new FinalizeEscapeGC();</span><br><span class="line">//对象第一次拯救自己</span><br><span class="line">SAVE_HOOK = null;</span><br><span class="line">System.gc();</span><br><span class="line">//因为虚拟机调用finalize方法优先级比较低，暂停1s等待执行。</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">if(SAVE_HOOK != null)&#123;</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;I am dead!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二次时不会再调用finalize方法</span><br><span class="line">SAVE_HOOK = null;</span><br><span class="line">System.gc();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">if(SAVE_HOOK != null)&#123;</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;I am dead!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize method executed!</span><br><span class="line">yes,I am still alive!</span><br><span class="line">I am dead!</span><br></pre></td></tr></table></figure><p>可以看到回收的第一次执行了finalize方法然后对象没有被回收，第二次时没有调用finalize方法，对象被回收掉了。</p><p>这种方法虽然能在对象被回收时自救一次，但在编写代码时不建议使用此种操作。</p><h3 id="1-5回收方法区（JDK8中是回收元空间）"><a href="#1-5回收方法区（JDK8中是回收元空间）" class="headerlink" title="1.5回收方法区（JDK8中是回收元空间）"></a>1.5回收方法区（JDK8中是回收元空间）</h3><p>按照JDK7介绍，永久代中的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><p>废弃常量：废弃常量的回收和java堆中对象的回收非常类似。以常量池为例，如果一个字符串“abc”已经进入常量池中，但是当前系统中没有任何一个String字符串对象叫做“abc”，也就是没有任何一个对象引用这个“abc”常量，也没有任何一个地方引用这个字面量。这个时候发生内存回收，有必要的话常量池中的“abc”常量会被系统清理出常量池。</p><p>无用的类：类的回收判定比较严格要满足一下三个条件才可以会被回收。</p><ul><li>该类所有的实例都已经被回收。</li><li>加载该类的ClassLoader也已经被回收。</li><li>该类对应的class对象也没有在任何地方被引用，也就是不能通过反射访问该类。</li></ul><h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2.垃圾收集算法"></a>2.垃圾收集算法</h2><h3 id="2-1标记-清除算法"><a href="#2-1标记-清除算法" class="headerlink" title="2.1标记-清除算法"></a>2.1标记-清除算法</h3><p>标记-清除算法：最基础的收集算法，主要分为“标记”和“清除”两个阶段完成，首先标记出所有需要回收的对象，在标记完成之后进行统一回收。之所以说它时最基础的收集算法是因为后续的收集算法都是基于这种思路进行对其不足进行改进而得到的。</p><p>这种算法有两种不足：第一个就是这两个阶段的效率都不高；第二个是在标记清除之后会产生大量的不连续的内存碎片，空间碎片太多可能会导致在后面程序运行过程中如果分配较大对象时，无法找到足够的连续内存空间，而不得不提前进行下一次垃圾回收。</p><h3 id="2-2复制算法"><a href="#2-2复制算法" class="headerlink" title="2.2复制算法"></a>2.2复制算法</h3><p>复制算法：将可用内存分为大小相等的两部分，每次只使用其中的一块，当这一块内存用完，就进行垃圾回收将还存活的对象复制到另一块上面，然后清除掉刚才使用的内存空间。这样做的好处就是每次对整个板块内存进行回收，不用考虑内存碎片等复杂问题。但是这种算法的代价就是讲内存可用空间直接缩小了一半。</p><p>在商业虚拟机中都使用这种算法来回收新生代。IBM研究表明大部分情况新生代中有98%的对象会被第一次收集时被回收掉，所以在实现中把内存分为较大的一块Eden空间和两个较小的Survivor空间，比例是8:1:1.每次使用时将新创建的对象分配到Eden区其中一个Surivivor区保存上次回收存活下来的对象，当进行垃圾收集时将Eden和使用中的Survivor中的存活对象复制到另一个Survivor中，然后清空Eden和使用过的Survivor空间，依次循环使用。当然并不是每次存活的对象都不足10%，当存活对象大于10%时Surivivor中的空间就不够使用，就需要依赖其他内存进行分配担保（老年代）。也就是当另一块Surivivor内存不够时就会将存活的对象分配到老年代中。</p><h3 id="2-3标记-整理算法"><a href="#2-3标记-整理算法" class="headerlink" title="2.3标记-整理算法"></a>2.3标记-整理算法</h3><p>复制算法在对象存活率较高时就要进行较多的复制操作，从而降低效率。还要预留担保空间，以应对存活对象较多时新生代内存不够分配的情况。所以在老年代提出了“标记-整理”算法，标记同样跟前面的“标记-清除”算法中标记操作一样，但是标记之后不会将对象清除掉，而是将对象移动到整块内存空间的一端，然后直接清理掉边界以外的内存。</p><h3 id="2-4分代收集算法"><a href="#2-4分代收集算法" class="headerlink" title="2.4分代收集算法"></a>2.4分代收集算法</h3><p>当前商业虚拟机都采用“分代收集算法”，这种算法只是将整块内存按照对象存活周期分为几个块，一般把java堆分为新生代、老年代。这样就可以根据各个年代特点使用不同算法进行收集。例如在新生代每次回收时都有少量对象可以存活，就是用复制算法，将少量存活对象复制到Survivor区。而老年代对象存活率比较高只有少量对象会被清除掉，就选用“标记-清除”或者“标记-整理”算法。</p><h2 id="3-HotSpot算法实现"><a href="#3-HotSpot算法实现" class="headerlink" title="3.HotSpot算法实现"></a>3.HotSpot算法实现</h2><h3 id="3-1枚举根节点"><a href="#3-1枚举根节点" class="headerlink" title="3.1枚举根节点"></a>3.1枚举根节点</h3><p>在可达性分析算法中可以作为GC Roots节点的主要在全局性引用（例如常量、静态属性）或者执行上下文（栈中本地变量表）中。在查找调用链的时候并不会这个检查这里面的引用，因为这样会消耗很多时间。</p><p>HotSopt实现中，使用一组称为OopMap的数据结构，在类加载完成的时候就已经计算出来对象“哪些”偏移量上面存储“哪些”数据类型。例如：在JIT编译过程中会在特定位置记录栈和寄存器中哪些位置是引用。这样在GC扫描的时候可以直接引用。</p><p>另外在执行GC 的时候所有java线程都必须停顿下来（Stop The World），因为在执行可达性分析算法的时候对象的引用关系不能发生变化。</p><h3 id="3-2安全点"><a href="#3-2安全点" class="headerlink" title="3.2安全点"></a>3.2安全点</h3><p>上面提到记录引用的特定位置称为“安全点”，线程在GC的时候需要暂停执行，但并不是在任何地方都可以停下来的，需要线程跑到“安全点”上时如果这时候有GC标识就暂停执行，这样可以保证在GC时引用不会发生变化。</p><h3 id="3-3安全区域"><a href="#3-3安全区域" class="headerlink" title="3.3安全区域"></a>3.3安全区域</h3><p>安全区域：指在一段代码片段之中，引用关系不会发生变化。这个区域中的任何位置开始GC 都是安全的。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4.垃圾收集器"></a>4.垃圾收集器</h2><h3 id="4-1Serial收集器"><a href="#4-1Serial收集器" class="headerlink" title="4.1Serial收集器"></a>4.1Serial收集器</h3><p>新生代收集器，复制算法。</p><p>Serial收集器是最基本、发展历史最悠久的收集器。这个收集器是一个单线程的收集器，它有一条专门的线程负责垃圾收集工作，更重要的是它在垃圾回收的时候要停止所有其他线程。主要用在Client模式下（用户的桌面场景中）。</p><h3 id="4-2ParNew收集器"><a href="#4-2ParNew收集器" class="headerlink" title="4.2ParNew收集器"></a>4.2ParNew收集器</h3><p>新生代收集器，复制算法。</p><p>ParNew收集器是Serial收集器的多线程版本。除了使用多线程进行垃圾收集之外其他的所有包括控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial完全一样。</p><h3 id="4-3Paralle-Scavenge收集器"><a href="#4-3Paralle-Scavenge收集器" class="headerlink" title="4.3Paralle Scavenge收集器"></a>4.3Paralle Scavenge收集器</h3><p>Parallel Scavenge收集器是一个新生代收集器，也是使用复制算法的收集器，有事并行的多线程收集器。</p><p>Paralle Scavenge收集器的特点就是关注吞吐量：运行用户代码时间 / CPU总运行时间（用户代码时间+垃圾收集时间）。</p><p>Paralle Scavenge收集器提供了可以配置精准控制吞吐量的参数。所以又称为“吞吐量优先”收集器。</p><h3 id="4-4Serial-Old收集器"><a href="#4-4Serial-Old收集器" class="headerlink" title="4.4Serial Old收集器"></a>4.4Serial Old收集器</h3><p>Serial Old收集器是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。</p><p>主要给client模式下的虚拟机使用。</p><h3 id="4-5Parallel-Old收集器"><a href="#4-5Parallel-Old收集器" class="headerlink" title="4.5Parallel Old收集器"></a>4.5Parallel Old收集器</h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。和Paralle Scavenge收集器搭配实现名副其实的“吞吐量优先”收集器。</p><h3 id="4-6CMS收集器"><a href="#4-6CMS收集器" class="headerlink" title="4.6CMS收集器"></a>4.6CMS收集器</h3><p>CMS收集器（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器。CMS收集器主要分四个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>初始标记、重新标记：这两个步骤虽然很快但是还是需要“Stop The World”。</p><p>并发标记：进行GC Roots tracing，在这个阶段jvm收集线程会和用户线程并行执行。（时间较长，降低用户系统信息）。</p><p>缺点：</p><ul><li>占用用户CPU资源，4核以上服务器至少占用1/4CPU资源。</li><li>产生“浮动垃圾”由于CMS收集器和用户线程并发执行，在收集过程中用户线程可能产生新的垃圾对象。</li><li>标记清除算法产生碎片内存空间，多次执行标记清除回收之后要进行一次内存压缩。</li></ul><h3 id="4-7G1收集器"><a href="#4-7G1收集器" class="headerlink" title="4.7G1收集器"></a>4.7G1收集器</h3><p>G1收集器是当今收集技术最前沿成果之一。</p><p>特点：</p><ul><li>并行和并发，缩短“Stop The World”时间，让用户线程和收集线程并发执行。</li><li>分代收集</li><li>空间整合，不会产生内存碎片。</li><li>可预测停顿时间，可以让使用者明确指定在一个长度为M毫米的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li></ul><p>G1之前的收集器收集范围都是整个新生代或者老年代。而G1收集器将整个java堆划分为多个大小相等的独立区域（Region），虽然还保留着新生代和老年代，但新生代和老年代不再是物理隔离的了，他们都是有一部分Region的集合组成。G1维护一个优先列表记录每个Region回收的价值大小，每次根据允许收集时间，首先回收价值最大的Region。</p><h3 id="4-8理解GC日志"><a href="#4-8理解GC日志" class="headerlink" title="4.8理解GC日志"></a>4.8理解GC日志</h3><p>JVM中可以配置使用不同的收集器，不同收集器输出的日志格式虽然相同，但每种收集器都有自己的标识。</p><p>例如：</p><p>1、配置：”-XX:+UseSerialGC” 使用Serial+Serial Old的收集器组合进行内存回收。</p><p>日志格式：[GC (Allocation Failure) [DefNew: 7292K-&gt;612K(9216K), 0.0055084 secs] 7292K-&gt;6756K(19456K), 0.0055700 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </p><p>2、配置：”-XX:+UseParallelOldGC” 使用Paralle Scavenge + Parallel Old的收集器组合进行内存回收。</p><p>日志格式：[GC (Allocation Failure) –[PSYoungGen: 7292K-&gt;7292K(9216K)] 11388K-&gt;15492K(19456K), 0.0030434 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (Ergonomics) [PSYoungGen: 7292K-&gt;2658K(9216K)] [ParOldGen: 8200K-&gt;8193K(10240K)] 15492K-&gt;10851K(19456K), [Metaspace: 2664K-&gt;2664K(1056768K)], 0.0078503 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </p><p>JDK8 HotSopt虚拟机默认使用的是并行收集器，日志如下格式进行讲解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;32K(38400K)] 1943K-&gt;644K(125952K), 0.0004471 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 612K-&gt;611K(87552K)] 644K-&gt;611K(125952K), [Metaspace: 2662K-&gt;2662K(1056768K)], 0.0076396 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>[GC 和[Full GC 代表收集停顿来下，Full表示有停顿及“Stop The World”。</p><p>[PSYongGen 和 [ParOldGen、[Metaspace表示GC发生的区域，[PSYongGen新生代；[ParOldGen老年代；[Metaspace元空间。</p><p>区域后面“[ ]”之内的32K-&gt;0K(38400K) 表示：该区域回收之前占用容量-&gt;回收之后占用容量(该区域总容量)。</p><p>“[ ]”之外的644K-&gt;611K(125952K)表示：java堆GC之前的占用容量-&gt;GC之后占用容量(java堆总用量)。</p><h2 id="5内存分配与回收策略"><a href="#5内存分配与回收策略" class="headerlink" title="5内存分配与回收策略"></a>5内存分配与回收策略</h2><h3 id="5-1对象优先在Eden分配"><a href="#5-1对象优先在Eden分配" class="headerlink" title="5.1对象优先在Eden分配"></a>5.1对象优先在Eden分配</h3><p>通过例子讲解：首先创建4个数组对象allocation1、allocation2、allocation3、allocation4，占用空间分别为2M、2M、2M、4M，然后指定虚拟机堆内存20M，新生代内存10M，新生代中Eden区域Survivor区域占比为8:1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class EdenTest &#123;</span><br><span class="line"></span><br><span class="line">private static final int _1MB = 1024 * 1024;</span><br><span class="line">    /**</span><br><span class="line"> * -verbose:gc -Xms20M(堆初始大小) -Xmx20M(堆最大值) -Xmn10M(堆中年轻代大小) -XX:+PrintGCDetails -XX:SurvivorRatio=8(表示Eden与一个Survivor比例为8:1)</span><br><span class="line"> */</span><br><span class="line">private static void testAllocation() &#123;</span><br><span class="line">byte[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">allocation1 = new byte[2 * _1MB];</span><br><span class="line">allocation2 = new byte[2 * _1MB];</span><br><span class="line">allocation3 = new byte[2 * _1MB];</span><br><span class="line">allocation4 = new byte[4 * _1MB];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">testAllocation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Serial+Serial Old收集器组合进行内存回收（UseSerialGC配置指定收集器）</p><p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+UseSerialGC</p><p>运行日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 7292K-&gt;613K(9216K), 0.0050167 secs] 7292K-&gt;6757K(19456K), 0.0050693 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4791K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  59% used [0x00000000ff500000, 0x00000000ff599460, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 2668K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>日志解读</p><p>GC (Allocation Failure)：表示向young generation(eden)给新对象申请空间，但是young generation(eden)剩余的合适空间不够所需的大小导致的minor gc。</p><p>DefNew：表示新生代使用Serial串行GC垃圾收集器，defNew提供新生代空间信息。</p><p>7292K-&gt;613K(9216K)：新生代占用内存7292K -&gt; 收集器回收之后占用内存613K（新生代可用内存9216K）。</p><p>7292K-&gt;6757K(19456K)：java堆被占用内存7292K -&gt; 收集器回收之后占用内存6757K （堆内存总空间19456K）。</p><p>Heap则表示此时堆内存中每个区域分配内存大小以及被使用的空间比例。</p><p>下面我们通过日志分析allocation1、allocation2、allocation3、allocation4这四个对象分配的位置。</p><p>首先日志的第一行进行新生代收集出现日志：7292K-&gt;613K(9216K)，说明allocation1、allocation2、allocation3这三个对象共计6M大小在Eden区，收集过后使用空间为613K，对象被移走，正常情况下Eden区对象首次会被移到其中一个Survivor区，但是Survivor区空间只用1M不足存放6M对象大小，所以这些对象直接被移送到了老年代中。堆内存收集前后并没有发生大的变化7292K-&gt;6757K(19456K)，也表示这些对象还在堆内存中，只是从新生代的Eden区直接被移送到了老年代中。</p><p>从最后堆内存各个区域内存占用的情况也可以分析得出我们的推论</p><table><thead><tr><th>区域</th><th>大小</th><th>使用比例</th><th>说明</th></tr></thead><tbody><tr><td>新生代：eden</td><td>8192K</td><td>51%</td><td>被占用4M空间，被allocation4占用</td></tr><tr><td>新生代：from</td><td>1024K</td><td>59%</td><td>空间不足1M，并未存放测试对象</td></tr><tr><td>新生代：to</td><td>1024K</td><td>0%</td><td>Survivor只有一个被使用</td></tr><tr><td>老年代区域</td><td>10240K</td><td>60%</td><td>老年代占用6M，为3个2M的对象</td></tr></tbody></table><h3 id="5-2大对象直接进入老年代"><a href="#5-2大对象直接进入老年代" class="headerlink" title="5.2大对象直接进入老年代"></a>5.2大对象直接进入老年代</h3><p>大对象就是在虚拟机中需要大量连续空间存放的对象。比如字符串对象或数组等。</p><p>虚拟提供一个-XX:PretenureSizeThreshold参数，可以设置令大于该参数值的对象直接进入老年代。这个参数只对Serial和ParNew收集器有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class PretenureSizeThresholdTest &#123;</span><br><span class="line"></span><br><span class="line">private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * -verbose:gc -Xms20M(堆初始大小) -Xmx20M(堆最大值) -Xmn10M(堆中年轻代大小)</span><br><span class="line"> * -XX:+PrintGCDetails -XX:SurvivorRatio=8(表示Eden与一个Survivor比例为8:1)</span><br><span class="line"> * -XXPretenureSizeThreshold=3145728(超过该值的对象直接进入老年代)</span><br><span class="line"> */</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">byte[] allocation;</span><br><span class="line">allocation = new byte[4 * _1MB];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM执行参数配置：</p><p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+UseSerialGC -XX:PretenureSizeThreshold=3145728</p><p>执行日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1312K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  16% used [0x00000000fec00000, 0x00000000fed480b0, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 2670K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>其中the space 10240K,  40% used，老年代使用40%，说明对象直接进入了老年代区域。</p><h3 id="5-3长期存活的对象将进入老年代"><a href="#5-3长期存活的对象将进入老年代" class="headerlink" title="5.3长期存活的对象将进入老年代"></a>5.3长期存活的对象将进入老年代</h3><pre><code>虚拟机采用分代收集的思想来管理内存，虚拟机为每个对象定义了一个年龄（Age）计数器，如果对象在Eden出生，并经历一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。此后对象在Survivor中每熬过一次Minor GC对象年龄就增加1岁，当年龄增加到一定程度时（默认15岁），该对象就会被移动到老年代中。对象晋升到老年代的这个阈值可以通过参数设定 -XX:MaxTenuringThreshold=2，表示对象经理过两次Minor GC 就可以被移动到老年代。</code></pre><h3 id="5-4动态对象年龄判定"><a href="#5-4动态对象年龄判定" class="headerlink" title="5.4动态对象年龄判定"></a>5.4动态对象年龄判定</h3><p>对象移动到老年代的另一个规则：当Survivor空间中相同年龄的对象所占用空间大小的总和大于Survivor空间的一半时，年龄大于或等于该年龄的对象就可以被直接移动到老年代中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-对象是否可回收&quot;&gt;&lt;a href=&quot;#1-对象是否可回收&quot; class=&quot;headerlink&quot; title=&quot;1.对象是否可回收&quot;&gt;&lt;/a&gt;1.对象是否可回收&lt;/h2&gt;&lt;h3 id=&quot;1-1引用计数算法&quot;&gt;&lt;a href=&quot;#1-1引用计数算法&quot; class
      
    
    </summary>
    
      <category term="服务器" scheme="https://duia.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="jvm" scheme="https://duia.github.io/tags/jvm/"/>
    
      <category term="虚拟机" scheme="https://duia.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机学习之一：java内存区域与内存溢出异常（转载）</title>
    <link href="https://duia.github.io/2019/02/26/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80%EF%BC%9Ajava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://duia.github.io/2019/02/26/虚拟机学习之一：java内存区域与内存溢出异常（转载）/</id>
    <published>2019-02-26T03:00:00.000Z</published>
    <updated>2019-05-23T12:00:00.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h2><p>java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途和创建、销毁时间，有的区域伴随虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p><p><img src="/upload/2019/2/6b79171b89315c21a0f6b680968edb9380c20190322113155882.jpg" alt="image"></p><h3 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看成是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变这个计数器的值来选取下一条要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等都依赖与这个计数器完成。</p><p>java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，所以在任何时刻一个处理器只能执行一条线程的指令。因此，为了线程切换之后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间程序计数器互不影响，独立存储。这类内存区域被称为“线程私有”内存。</p><p>如果线程正在执行的是java方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址。如果线程正在执行的是Native方法，计数器值为空。此区域是java虚拟机规范中唯一一个没有规定任何“OutOfMemoryError”情况的区域。</p><h3 id="1-2-java虚拟机栈"><a href="#1-2-java虚拟机栈" class="headerlink" title="1.2 java虚拟机栈"></a>1.2 java虚拟机栈</h3><p>与程序计数器一样，java虚拟机栈也是线程私有的，他的声明周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型。其中long和double数据会占用两个局部变量空间，其他的占用一个局部变量空间。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在java虚拟机规范中对虚拟机栈规定了两种异常状况：如果线程请求深度大于虚拟机运行的请求深度，抛出StackOverflowError异常；如果虚拟栈可以扩展，当扩展时无法申请到足够的内存空间，抛出OutOfMemoryError异常。</p><h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><p>本地方法栈与java虚拟栈非常相似，他们之间的区别只不过是java虚拟机栈是为虚拟机执行java方法服务的，而本地方法栈是为虚拟机执行Native方法服务的。</p><h3 id="1-4-java堆"><a href="#1-4-java堆" class="headerlink" title="1.4 java堆"></a>1.4 java堆</h3><p>对于大多数应用来说，java堆是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。次内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分片内存。</p><p>java堆也是垃圾收集器管理的主要内存区域，由于现在的收集器基本都采用分代收集算法，所以java堆可以再划分为新生代和老年代；再细致一点可以划分为Eden空间、From Survivor空间、To Survivor空间等。</p><p>在实现时java堆既可以是固定大小的内存区域，也可以是可扩展的，当前主流的虚拟机都是可扩展的（通过-Xmx和-Xms控制）。如果堆中内存用完，且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h3><p>方法区（Method Area）与java堆一样，也是一个各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>不同的虚拟机在这块的实现不一样。</p><p>在java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h3 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h3><p>运行时常量池是方法区的一部分。主要用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。java语言并不要求常量一定只有在编译期才能产生，也就是说并非预置入Class文件中的常量池内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。这种特性被开发人员利用的比较多的是String的intern()方法。</p><p>当运行时常量池在无法申请到内存时也会抛出OutOfMemoryError异常。</p><h3 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但是这块内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。</p><p>被使用的例子：NIO类引入了一种基于通道与缓冲区的I/O方式。它可以使用Native函数库直接分配堆外内存，然后通过存储在java堆中的一个DirectByteBuffer对象作为这块内存的引用进行操作。这样就避免了java堆和Native堆之间来回复制数据。</p><h2 id="2-java中对象的创建和使用"><a href="#2-java中对象的创建和使用" class="headerlink" title="2.java中对象的创建和使用"></a>2.java中对象的创建和使用</h2><p>以HotSpot虚拟机为例介绍java堆内存对象的创建、内存布局以及访问定位。</p><h3 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h3><p>在java语言中对象的创建通常是通过new关键字进行创建，但在虚拟机中时一个什么过程？</p><p>1.虚拟机接受到new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。（如果没有先进行类加载）</p><p>2.虚拟机将为新对象分配内存，在类加载之后已经确定对象需要的内存大小。这个过程等同于从堆内存中为对象划分出一块确定大小的内存空间。</p><p>分配方式</p><p>指针碰撞：如果java堆中内存时绝对规整的，所有用过的内存存放在一边，空闲内存在另一边，中间放着一个指针作为分界点指示器。那分配内存就是把指针向空闲内存方向移动对象大小相等的距离。</p><p>空闲列表：如果java堆中内存并不规整，虚拟机就必须维护一个列表，在列表上记录那些内存时可用的，在分配的时候就从列表中找一块足够大的空间分给对象实例，并更新列表上的记录。</p><p>分配时线程安全问题也有两种方案</p><p>一种是在分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性，</p><p>另一种是为每个线程预先在java堆中分配一小块内存空间（线程分配缓冲）哪个线程需要分配内存就在该线程事先分好的内存空间进行。</p><p>3.内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值。</p><p>4.虚拟机对对象进行必要的设置，会在对象头中设置例如该对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p><p>5.对象进行初始化，一般会执行<init>方法按照程序员的意愿为对象初始化。这样一个真正可用的对象才算创建出来。</init></p><h3 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h3><p>在HotSpot虚拟机中对象在内存中的布局可以划分为3块区域：对象头、实例数据、对齐填充。</p><p>对象头：对象头又分为两部分信息，第一部分存储对象自身运行时数据如哈希码、GC分代年龄、所状态标志、线程所持有的锁、偏向线程ID、偏向时间戳等；第二部分是类型指针，对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（不是所有虚拟机实现都需要保留类型指针，当然如果是数组类型在对象头中还要有一块用于存储数组长度）。</p><p>实例数据：对象真正存储的有效信息，程序代码中定义的各种类型字段的内容。</p><p>对齐填充：这部分并不是必然存在的，因为HotSpot虚拟机要去对象起始地址必须是8字节的整数倍，换句话说也就是对象大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数，因此当对象实例数据内容没有对齐时，就需要通过对齐填充来补全。</p><h3 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h3><p>建立对象是为了使用对象，java程序需要通过栈上的reference数据来操作堆上具体对象。对象的访问方式根据虚拟机实现主要有两种：使用句柄访问和指针访问。</p><p>句柄访问：如果使用句柄访问那么java堆中就必须划分出一块内存来作为句柄池，reference中存储的就是句柄池中对象句柄的地址。而句柄中就要保存对象实例数据地址和对象类型数据地址。</p><p><img src="/upload/2019/2/898a664bd3e401280b56de0b844c40e5d5420190322113317854.jpg" alt="image"></p><p>指针访问：如果使用直接指针访问，在java堆中对象的内存布局就要考虑如何放置对象类型数据的相关信息。</p><p><img src="/upload/2019/2/95ecca86087422a71f686d455e838b2114720190322113421996.jpg" alt="image"></p><p>使用句柄的优势就是reference中存储的是稳定的句柄地址，在对象被移动是只会改变句柄中实例数据指针，而reference本身不需要修改。</p><p>使用直接指针访问方式的好处就是速度更快，它节省了一次指针定位的时间开销。</p><h2 id="3-实战：OutOfMemoryError异常"><a href="#3-实战：OutOfMemoryError异常" class="headerlink" title="3.实战：OutOfMemoryError异常"></a>3.实战：OutOfMemoryError异常</h2><h3 id="3-1-java堆溢出"><a href="#3-1-java堆溢出" class="headerlink" title="3.1 java堆溢出"></a>3.1 java堆溢出</h3><p>java堆用于存储对象实例，只要不断创建对象实例，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量限制之后就会出现内存溢出的异常。</p><p>我们可以通过实例来演示：首先限制java堆内存大小，不可扩展然后不停创建对象。</p><p>虚拟机运行参数配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dfile.encoding=UTF-8 -verbose.gc -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\data -XX:SurvivorRatio=8</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class VmTest &#123;</span><br><span class="line"></span><br><span class="line">static class OOMObject&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">while(true)&#123;</span><br><span class="line">list.add(new OOMObject());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to D:\data\java_pid8168.hprof ...</span><br><span class="line">Heap dump file created [28070894 bytes in 0.145 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">at java.util.ArrayList.grow(ArrayList.java:261)</span><br><span class="line">at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</span><br><span class="line">at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:458)</span><br><span class="line">at com.sean.esapi.client.VmTest.main(VmTest.java:15)</span><br></pre></td></tr></table></figure><p>java堆的内存OOM异常是实际应用中常见的内存溢出异常情况。当出现java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。</p><p>要解决这个区的异常主要就是确认内存中的对象是否必要的，也就是要分清楚是内存泄露还是内存溢出。如果是内存泄露就要找到泄露对象到GC Roots的引用链，于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法回收他们的。</p><p>如果不存内存泄露就要一方面根据物理机内存对比看看是否可以扩充java堆内存空间。另一方面从代码层面看看是否有对象生命周期过长或持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p><h3 id="3-2虚拟机栈和本地方法栈溢出"><a href="#3-2虚拟机栈和本地方法栈溢出" class="headerlink" title="3.2虚拟机栈和本地方法栈溢出"></a>3.2虚拟机栈和本地方法栈溢出</h3><p>由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说虽然-Xoss参数（设置本地方法栈大小）存在但实际上无效。虚拟机提供了为单个线程设置栈容量的参数设置-Xss。</p><p>java虚拟机规范中描述有两种异常：</p><p>StackOverflowError：如果线程请求的栈深度大于虚拟机允许的最大深度，抛出StackOverflowError异常。</p><p>OutOfMemoryError：如果虚拟机在扩展栈时无法申请到足够的内存空间，抛出OutOfMemoryError异常。</p><p>在单线程模式下通过递归方法测试设置-Xss参数减小栈内存的容量，出现StackOverflowError异常，减小-Xss参数之后再次运行发现出现StackOverflowError异常时递归的深度变小。说明当栈内存缩小时虚拟机允许的最大深度相应缩小。</p><p>设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss128k</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class VMStackTest &#123;</span><br><span class="line"></span><br><span class="line">private int stackLength = 1;</span><br><span class="line"></span><br><span class="line">public void stackLeak() &#123;</span><br><span class="line">stackLength ++;</span><br><span class="line">System.out.println(stackLength);</span><br><span class="line">stackLeak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">VMStackTest vmst = new VMStackTest();</span><br><span class="line">try &#123;</span><br><span class="line">vmst.stackLeak();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">...</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77)</span><br><span class="line">at sun.nio.cs.UTF_8.access$200(UTF_8.java:57)</span><br><span class="line">at sun.nio.cs.UTF_8$Encoder.encodeArrayLoop(UTF_8.java:636)</span><br><span class="line">at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691)</span><br><span class="line">at java.nio.charset.CharsetEncoder.encode(CharsetEncoder.java:579)</span><br><span class="line">at sun.nio.cs.StreamEncoder.implWrite(StreamEncoder.java:271)</span><br><span class="line">at sun.nio.cs.StreamEncoder.write(StreamEncoder.java:125)</span><br><span class="line">at java.io.OutputStreamWriter.write(OutputStreamWriter.java:207)</span><br><span class="line">at java.io.BufferedWriter.flushBuffer(BufferedWriter.java:129)</span><br><span class="line">at java.io.PrintStream.write(PrintStream.java:526)</span><br><span class="line">at java.io.PrintStream.print(PrintStream.java:597)</span><br><span class="line">at java.io.PrintStream.println(PrintStream.java:736)</span><br></pre></td></tr></table></figure><p>重新设置-Xss参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss512k</span><br></pre></td></tr></table></figure><p>同样运行上面代码</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">...</span><br><span class="line">5064</span><br><span class="line">5065</span><br><span class="line">5066</span><br><span class="line">5067</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at java.io.FileOutputStream.write(FileOutputStream.java:326)</span><br><span class="line">at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)</span><br><span class="line">at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)</span><br><span class="line">at java.io.PrintStream.write(PrintStream.java:482)</span><br><span class="line">at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)</span><br><span class="line">at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)</span><br><span class="line">at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)</span><br><span class="line">at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)</span><br><span class="line">at java.io.PrintStream.write(PrintStream.java:527)</span><br><span class="line">at java.io.PrintStream.print(PrintStream.java:597)</span><br></pre></td></tr></table></figure><p>当定义大量的本地变量，增大方法帧中本地变量表的长度，在较小的调用深度就会出现抛出StackOverflowError异常。</p><p>JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常（这种方式容易耗尽操作系统资源导致宕机）</p><p>配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss128k</span><br></pre></td></tr></table></figure><p>运行如下代码没有得到OutOfMemoryError异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class VMStackTest &#123;</span><br><span class="line"></span><br><span class="line">public void stackLeak() &#123;</span><br><span class="line">String name;</span><br><span class="line">while (true) &#123;</span><br><span class="line">name = &quot;nihao&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(100000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void stackLeakByThread()&#123;</span><br><span class="line">int count = 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">count ++;</span><br><span class="line">Thread t = new Thread(new Runnable()&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">stackLeak();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">VMStackTest vmst = new VMStackTest();</span><br><span class="line">vmst.stackLeakByThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3方法区和运行时常量池溢出"><a href="#3-3方法区和运行时常量池溢出" class="headerlink" title="3.3方法区和运行时常量池溢出"></a>3.3方法区和运行时常量池溢出</h3><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字符描述、方法描述等。对于这些区域的测试，基本思路就是运行时产生大量的类去填满方法区，直到溢出。这里通过CGLib直接操作字节码运行时生成了大量的动态类。</p><p>注意：JVM8中把运行时常量池、静态变量也移到堆区进行存储。方法区方法区主要是存储类的元数据的，如虚拟机加载的类信息、编译后的代码等。JDK8之前方法区的实现是被称为一种“永久代”的区域，这部分区域使用JVM内存，但是JDK8的时候便移除了“永久代（Per Gen）”，转而使用“元空间（MetaSpace）”的实现，而且很大的不同就是元空间不在共用JVM内存，而是使用的系统内存。</p><h3 id="3-4本机直接内存溢出"><a href="#3-4本机直接内存溢出" class="headerlink" title="3.4本机直接内存溢出"></a>3.4本机直接内存溢出</h3><p>DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认为与java堆最大值(-Xmx指定)一样，我们测试时直接越过DirectByteBuffer类，直接通过反射获取Unsafe实例进行内存分配。因为虽然使用DirectByteBuffer分配内存也会出现内存溢出异常，但它抛出异常时并没有去向操作系统申请内存，而是通过计算得知内存无法分配手动抛出内存溢出异常。真正申请分配内存的方法是unsafe.allocateMemory()。</p><p>配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20M -XX:MaxDirectMemorySize=10M</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DirectMeoryOOM &#123;</span><br><span class="line"></span><br><span class="line">private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //通过反射获取到unsafe实例，再通过unsafe实例申请内存</span><br><span class="line">Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">unsafeField.setAccessible(true);</span><br><span class="line">Unsafe unsafe = (Unsafe)unsafeField.get(null);</span><br><span class="line">while(true)&#123;</span><br><span class="line">unsafe.allocateMemory(_1MB);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</span><br><span class="line">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">at com.sean.esapi.client.DirectMeoryOOM.main(DirectMeoryOOM.java:16)</span><br></pre></td></tr></table></figure><p>由DirectMemory导致内存溢出的一个明显特征就是在Heap Dump文件中不会看到明显的异常，如果发现OOM之后Dump文件有很小，程序直接或间接又使用了NIO，可以考虑这方面原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-运行时数据区域&quot;&gt;&lt;a href=&quot;#1-运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;1. 运行时数据区域&quot;&gt;&lt;/a&gt;1. 运行时数据区域&lt;/h2&gt;&lt;p&gt;java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据
      
    
    </summary>
    
      <category term="服务器" scheme="https://duia.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="jvm" scheme="https://duia.github.io/tags/jvm/"/>
    
      <category term="虚拟机" scheme="https://duia.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ueditor+公式插件</title>
    <link href="https://duia.github.io/2019/02/22/ueditor+%E5%85%AC%E5%BC%8F%E6%8F%92%E4%BB%B6/"/>
    <id>https://duia.github.io/2019/02/22/ueditor+公式插件/</id>
    <published>2019-02-22T11:07:00.000Z</published>
    <updated>2019-05-23T12:00:00.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ueditor-公式插件"><a href="#ueditor-公式插件" class="headerlink" title="ueditor+公式插件"></a>ueditor+公式插件</h2><p>本文主要说一说ueditor和公式插件KityFormula在使用过程中遇到的问题。</p><p>ueditor和项目的集成可以自行百度，KityFormula 可以看这里<a href="https://ueditor.baidu.com/website/kityformula.html" target="_blank" rel="noopener">KityFormula</a>，也相对简单，没啥问题。下边进入主题：</p><h3 id="生成公式图片"><a href="#生成公式图片" class="headerlink" title="生成公式图片"></a>生成公式图片</h3><p>默认生成<code>data:image/jpeg;base64</code>图片代码，找到kityFormulaDialog.html文件，有一段如下代码，加入一行代码即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dialog.onok = function()&#123;</span><br><span class="line">       kfe.execCommand(&apos;get.image.data&apos;, function(data)&#123;</span><br><span class="line">           var latex = kfe.execCommand(&apos;get.source&apos;);</span><br><span class="line">           editor.execCommand(&apos;inserthtml&apos;, &apos;&lt;img class=&quot;kfformula&quot; src=&quot;&apos;+ data.img +&apos;&quot; data-latex=&quot;&apos; + latex + &apos;&quot; /&gt;&apos;);</span><br><span class="line">           editor.getKfContent(function(html)&#123;&#125;);//新增代码</span><br><span class="line">           dialog.close();</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>editor.getKfContent()方法是KityFormula提供的生成图片的功能，生成图片需要后台代码的支持。这部分功能正式ueditor提供的涂鸦图片生成的功能。</p><h3 id="公式图片背景透明"><a href="#公式图片背景透明" class="headerlink" title="公式图片背景透明"></a>公式图片背景透明</h3><p>Ueditor生成的图片默认JPG格式，经过尝试发现只需要将生成的图片格式修改为PNG图片即可。做如下修改：<br>FileType.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final String JPG = &quot;JPG&quot;;</span><br><span class="line">public static final String PNG = &quot;PNG&quot;;</span><br><span class="line"></span><br><span class="line">private static final Map&lt;String, String&gt; types = new HashMap&lt;String, String&gt;()&#123;&#123;</span><br><span class="line"></span><br><span class="line">put( FileType.JPG, &quot;.jpg&quot; );</span><br><span class="line">put( FileType.PNG, &quot;.png&quot; );</span><br><span class="line"></span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">//......</span><br></pre></td></tr></table></figure></p><p>Base64Uploader.java文件中”JPG”改为”PNG”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String suffix = FileType.getSuffix(&quot;JPG&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="生成图片后富文本中图片标签加宽高"><a href="#生成图片后富文本中图片标签加宽高" class="headerlink" title="生成图片后富文本中图片标签加宽高"></a>生成图片后富文本中图片标签加宽高</h3><p>getKfContent.js文件设置item属性的地方加以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var width=&apos;&apos;;</span><br><span class="line">var height=&apos;&apos;;</span><br><span class="line">// 创建对象</span><br><span class="line">var img = new Image();</span><br><span class="line">// 设置图片的src</span><br><span class="line">img.src = url;</span><br><span class="line">//console.log(&quot;link:&quot;+link);</span><br><span class="line">img.onload = function()&#123;</span><br><span class="line">    width=img.width;</span><br><span class="line">    height=img.height;</span><br><span class="line">    item.setAttribute(&apos;width&apos;,width);</span><br><span class="line">    item.setAttribute(&apos;height&apos;,height);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="新增限制条件"><a href="#新增限制条件" class="headerlink" title="新增限制条件"></a>新增限制条件</h3><p>AppInfo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int WIDTH_MAX_SIZE = 9;</span><br><span class="line"></span><br><span class="line">// &quot;文件大小超出限制&quot;</span><br><span class="line">put( AppInfo.WIDTH_MAX_SIZE, &quot;图片宽度超出限制&quot; );</span><br></pre></td></tr></table></figure></p><p>StorageManager.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedImage sourceImg = ImageIO.read(new FileInputStream(tmpFile));</span><br><span class="line">if (sourceImg.getWidth() &gt; 400) &#123;</span><br><span class="line">tmpFile.delete();</span><br><span class="line">return new BaseState(false, AppInfo.WIDTH_MAX_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ueditor-公式插件&quot;&gt;&lt;a href=&quot;#ueditor-公式插件&quot; class=&quot;headerlink&quot; title=&quot;ueditor+公式插件&quot;&gt;&lt;/a&gt;ueditor+公式插件&lt;/h2&gt;&lt;p&gt;本文主要说一说ueditor和公式插件KityFormula
      
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="js" scheme="https://duia.github.io/categories/JAVA/js/"/>
    
    
      <category term="ueditor" scheme="https://duia.github.io/tags/ueditor/"/>
    
  </entry>
  
  <entry>
    <title>springboot+mongo分库分表通用策略</title>
    <link href="https://duia.github.io/2019/02/17/springboot+mongo%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E9%80%9A%E7%94%A8%E7%AD%96%E7%95%A5/"/>
    <id>https://duia.github.io/2019/02/17/springboot+mongo分库分表通用策略/</id>
    <published>2019-02-17T11:30:00.000Z</published>
    <updated>2019-05-23T12:00:00.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景和基本思路"><a href="#背景和基本思路" class="headerlink" title="背景和基本思路"></a>背景和基本思路</h2><p>题库项目开发过程中，选用mongodb作为用户数据储存的数据库，在前期开发过程中，也做了简单的分表策略——按照业务场景分表，即某一科目的考试练习所产生的数据，会进入一个collection，在涉及到mongodb操作的时候，通过以下方法获取操作的集合名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCollectionName</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.collectionName+<span class="string">"_"</span>+skuId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">find</span><span class="params">(Query query, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.find(query, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Query query, Update update, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.update(query, update, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">insert</span><span class="params">(T entity, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.insert(entity, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">save</span><span class="params">(T entity, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.save(entity, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其它方法略</span></span><br></pre></td></tr></table></figure><p>经过一段时间的运行后发现，分表数据产生的严重的倾斜，分析后，于是修改了分表策略，不能按照科目业务分表，于是修改为对用户id进行取余的方式来进行分表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCollectionName</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.collectionName+<span class="string">"_"</span>+skuId % <span class="keyword">this</span>.shardingCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上便是mongodb分表的基本思想，对于mongodb分表这个概念，有点争议，有些人说mongodb自带分片基因，可以通过相应的配置实现mongodb的分片，所以无需分表，在这里暂不考虑分表的必要性，总的来说，当mongodb单个集合数据上亿，在项目实践中感觉还是可以通过分表功能得到很大的缓解。</p><h2 id="通用模块"><a href="#通用模块" class="headerlink" title="通用模块"></a>通用模块</h2><p>废话不多说，先上代码。百度云盘<a href="https://pan.baidu.com/s/12RoXqnbWmDMJphvi8v__Cg" target="_blank" rel="noopener">下载</a> 提取码: <code>phf8</code></p><p>一个相对独立的模块，如果你的项目使用的是springboot的话，直接复制进去就可以使用了，大可不必过多的描述，但其中也有几点比较特殊的地方，所以还是列出来做些说明：</p><h3 id="1、MongoConfig"><a href="#1、MongoConfig" class="headerlink" title="1、MongoConfig"></a>1、MongoConfig</h3><p>由于我们项目是springboot框架，这里就优先说一下这个配置项，搭配springboot的application.properties文件很容易就可以实现mongodb的配置，并且支持多mongo数据源配置，为分库做准备。</p><p>application.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#mongodb://[username:password@]host1[:port1][,host2[:port2],¡­[,hostN[:portN]]][/[database][?options]]</span><br><span class="line"># mongdb1</span><br><span class="line">spring.data.mongodb.one.uri=mongodb://127.0.0.1:27017/wpc</span><br><span class="line"># mongdb2</span><br><span class="line">spring.data.mongodb.two.uri=mongodb://112.126.91.194:27017/tiku_dev</span><br></pre></td></tr></table></figure></p><p>MongoConfig.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自动注入第一个 mongondb</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.mongodb.one.uri&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String MONGO_URI;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自动注入第二个 mongondb</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.mongodb.two.uri&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String MONGO_URI2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure></p><h3 id="2、dao"><a href="#2、dao" class="headerlink" title="2、dao"></a>2、dao</h3><p>dao包下有两个子包：multimongo和shardcollection，分别是分库和分表的基础类，根据实际需要进行继承即可。</p><p>其中分库策略需要借助<code>MultiMongo.java</code>类来选择具体的策略，以及索要使用的mongo库，根据指定注入的对象名来指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MultiMongo</span>(strategy = DefaultDecisionHandler.DEFAULT, specify = <span class="string">"mongoMain"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Title&gt; <span class="title">findTitles</span><span class="params">(Integer status)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>分表策略需要借助<code>ShardingKey.java</code>类，注解在具体操作类的分表依据的字段上来使用，指定分表个数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ShardingKey</span>(shardingColumn = <span class="string">"userId"</span>, value = <span class="string">"userId"</span>, shardingCount = <span class="number">128</span>)</span><br><span class="line">   <span class="keyword">private</span> Long userId;</span><br></pre></td></tr></table></figure><h3 id="3、DBDecisionDaoAop-java"><a href="#3、DBDecisionDaoAop-java" class="headerlink" title="3、DBDecisionDaoAop.java"></a>3、DBDecisionDaoAop.java</h3><p>分库策略的AOP，需要修改<code>doAround</code>方法的注解，进入加有<code>@MultiMongo</code>注解的dao层具体方法前，动态切换指定mongo库。</p><h3 id="4、handler"><a href="#4、handler" class="headerlink" title="4、handler"></a>4、handler</h3><p>定义具体的分库信息，默认提供了<code>DefaultDecisionHandler</code>分库策略，即根据指定库名来获取mongo库。也可以参照<code>DateDecisionHandler</code>来扩展我们所需要的分库策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景和基本思路&quot;&gt;&lt;a href=&quot;#背景和基本思路&quot; class=&quot;headerlink&quot; title=&quot;背景和基本思路&quot;&gt;&lt;/a&gt;背景和基本思路&lt;/h2&gt;&lt;p&gt;题库项目开发过程中，选用mongodb作为用户数据储存的数据库，在前期开发过程中，也做了简单的分表策
      
    
    </summary>
    
      <category term="spring boot" scheme="https://duia.github.io/categories/spring-boot/"/>
    
      <category term="mongodb" scheme="https://duia.github.io/categories/spring-boot/mongodb/"/>
    
      <category term="数据库" scheme="https://duia.github.io/categories/spring-boot/mongodb/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MongoDB" scheme="https://duia.github.io/tags/MongoDB/"/>
    
      <category term="springboot" scheme="https://duia.github.io/tags/springboot/"/>
    
      <category term="分表" scheme="https://duia.github.io/tags/%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>EJS学习总结</title>
    <link href="https://duia.github.io/2017/07/28/EJS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://duia.github.io/2017/07/28/EJS学习总结/</id>
    <published>2017-07-28T13:50:00.000Z</published>
    <updated>2019-05-19T00:00:00.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是EJS"><a href="#一、什么是EJS" class="headerlink" title="一、什么是EJS"></a>一、什么是EJS</h3><p>EJS是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。</p><h3 id="二、为什么要使用EJS"><a href="#二、为什么要使用EJS" class="headerlink" title="二、为什么要使用EJS"></a>二、为什么要使用EJS</h3><p>与最初的JavaScript相比较，一些不太了解你的代码的人可以更容易地通过EJS模板代码看得懂你的代码。 让我们放松一下，一起来享受下令人激动的干净简洁的感觉。</p><p>总之可以让代码更加干净整洁，让人易懂。</p><a id="more"></a><p>可以看如下的例子：</p><p>这是用javascript实现的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">"&lt;h1&gt;"</span>+data.title+<span class="string">"&lt;/h1&gt;"</span></span><br><span class="line">html += <span class="string">"&lt;ul&gt;"</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;data.supplies.length; i++) &#123;</span><br><span class="line">    html += <span class="string">"&lt;li&gt;&lt;a href='supplies/"</span>+data.supplies[i]+<span class="string">"'&gt;"</span></span><br><span class="line">    html += data.supplies[i]+<span class="string">"&lt;/a&gt;&lt;/li&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line">html += <span class="string">"&lt;/ul&gt;"</span></span><br></pre></td></tr></table></figure></p><p>最终要实现的效果如下：</p><p><img src="/upload/2019/1/ejs120190216143859415.png" alt="image"></p><p>但是上面的代码看起来很乱，虽然实现了功能，但是不容易让人弄懂。不仅代码丑陋，而且你的HTML结构完全在JavaScript代码中丢失。</p><p>下面学习EJS同样实现上面的功效，它的工作原理如下：</p><p><img src="/upload/2019/1/ejs220190216143859306.png" alt="image"></p><p>使用EJS来找回你的明确、维护性良好的HTML代码结构。</p><p>注:data是json对象，不能使json字符串。</p><p>在HTML中引入EJS,以使javascript能够使用它，引入EJS的语句如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/ejs.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>创建一个EJS模板,命名为<code>cleaning.ejs</code>文件，内容如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">%=title</span> %&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &lt;% for(var i=0; i&lt;supplies.length; i++) &#123; %&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'supplies/&lt;%=supplies[i] %&gt;'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">%=</span> <span class="attr">supplies</span>[<span class="attr">i</span>] %&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我的HTML文档如下，引入EJS,并更加我们的提供EJS模板创建EJS对象，然后调用EJS对象成员函数解析JSON对象到模板中。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/ejs.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">myfunction</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> data=<span class="string">'&#123;"title":"cleaning","supplies":["mop","broom","duster"]&#125;'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> html = <span class="keyword">new</span> EJS(&#123;<span class="attr">url</span>: <span class="string">'/js/tmpl/cleaning.ejs'</span>&#125;).render(<span class="built_in">JSON</span>.parse(data));</span></span><br><span class="line"><span class="javascript">    <span class="comment">//JSON.parse(data) 把JSON字符串解析为原生的javascript值。</span></span></span><br><span class="line"><span class="undefined">    alert(html);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>).innerHTML=html;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"myfunction()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>从上面这个例子我们可以看到EJS模板的基本用法。</p><h3 id="三、下面介绍下EJS的语法和功能："><a href="#三、下面介绍下EJS的语法和功能：" class="headerlink" title="三、下面介绍下EJS的语法和功能："></a>三、下面介绍下EJS的语法和功能：</h3><ol><li>缓存功能，能够缓存已经解析好的html模版</li><li><p><code>&lt;% code %&gt;</code>用于执行其中javascript代码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% alert(&apos;hello world&apos;) %&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;%= code %&gt;</code>会对code进行html转义；</p><ul><li><code>&lt;h1&gt;&lt;%=title %&gt;&lt;/h1&gt;</code>                    注：会把title里面存的值给显示出来在h1中。</li><li><code>&lt;p&gt;&lt;%= &#39;hello world&#39; %&gt;&lt;/p&gt;</code>             注：会把hello world显示在h1中。</li><li><code>&lt;h1&gt;&lt;%= &#39;&lt;b&gt;hello world&lt;/b&gt;&#39; %&gt;&lt;/h1&gt;</code>    注：会把hello world变粗，然后显示在h1中。</li></ul></li><li><code>&lt;%- code %&gt;</code>将不会进行转义<br>这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。<ul><li><code>&lt;h1&gt;&lt;%-title %&gt;asd&lt;/h1&gt;</code>          最后显示asd，及显示原网页</li><li><code>&lt;p&gt;&lt;%# &#39;hello world&#39; %&gt;asd&lt;/p&gt;</code>   最后显示asd，及显示原网页</li></ul></li><li><p>支持自定义标签<br> ejs 里，默认的闭合标记是 <code>&lt;%  .. %&gt;</code>，我们也可以定义自己的标签。例如：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">"view options"</span>,&#123;</span><br><span class="line">   <span class="string">"open"</span>:<span class="string">"&#123;&#123;"</span>,</span><br><span class="line">   <span class="string">"close"</span>:<span class="string">"&#125;&#125;"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>提供一些辅助函数，用于模版中使用</p><ol><li>first，返回数组的第一个元素；</li><li>last，返回数组的最后一个元素；</li><li>capitalize，返回首字母大写的字符串；</li><li>downcase，返回字符串的小写；</li><li>upcase，返回字符串的大写；</li><li>sort，排序（Object.create(obj).sort()？）；</li><li>sort_by:’prop’，按照指定的prop属性进行升序排序；</li><li>size，返回长度，即length属性，不一定非是数组才行；</li><li>plus:n，加上n，将转化为Number进行运算；</li><li>minus:n，减去n，将转化为Number进行运算；</li><li>times:n，乘以n，将转化为Number进行运算；</li><li>divided_by:n，除以n，将转化为Number进行运算；</li><li>join:’val’，将数组用’val’最为分隔符，进行合并成一个字符串；</li><li>truncate:n，截取前n个字符，超过长度时，将返回一个副本</li><li>truncate_words:n，取得字符串中的前n个word，word以空格进行分割；</li><li>replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串；</li><li>prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面；</li><li>append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面；</li><li>map:’prop’，返回对象数组中属性为prop的值组成的数组；</li><li>reverse，翻转数组或字符串；</li><li>get:’prop’，取得属性为’prop’的值；</li><li>json，转化为json格式字符串</li></ol></li><li>利用<code>&lt;%- include filename %&gt;</code>加载其他页面模版<h3 id="四、使用创建好的EJS模板"><a href="#四、使用创建好的EJS模板" class="headerlink" title="四、使用创建好的EJS模板"></a>四、使用创建好的EJS模板</h3></li></ol><p>基于我们之前写的模拟生成一个EJS对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> EJS(&#123;<span class="attr">url</span>: <span class="string">'/js/tmpl/cleaning.ejs'</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>对象有下面两个成员函数</p><ul><li><code>ejs.compile(str, options)</code> 将返回内部解析好的Function函数</li><li><p><code>ejs.render(str, options)</code> 返回经过解析的字符串，ejs的render函数有两个参数 第一个是字符串，第二个是可选的对象，和其他javascript模版一样需要渲染的数据也是包含在option对象中的。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ejs.render(str,option);  <span class="comment">// 渲染字符串 str 一般是通过nodejs文件系统的readfile方法读取</span></span><br><span class="line">ejs.render(str,&#123;</span><br><span class="line">    data : user_data  <span class="comment">// 需要渲染的数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  其中options的一些参数为：</p><ol><li>cache：是否缓存解析后的模版，需要filename作为key；</li><li>filename：模版文件名；</li><li>scope：complile后的Function执行所在的上下文环境；</li><li>debug：标识是否是debeg状态，debug为true则会输出生成的Function内容；</li><li>compileDebug：标识是否是编译debug，为true则会生成解析过程中的跟踪信息，用于调试；</li><li>client，标识是否用于浏览器客户端运行，为true则返回解析后的可以单独运行的Function函数；</li><li>open，代码开头标记，默认为’&lt;%’；</li><li>close，代码结束标记，默认为’%&gt;’；</li><li><p>其他的一些用于解析模版时提供的变量。</p><p>在express中使用时，options参数将由response.render进行传入，其中包含了一些express中的设置，以及用户提供的变量值。</p></li></ol></li></ul><h3 id="五、最后总结一下EJS的应用场所"><a href="#五、最后总结一下EJS的应用场所" class="headerlink" title="五、最后总结一下EJS的应用场所"></a>五、最后总结一下EJS的应用场所</h3><ul><li><p>用JavaScript创建HTML字符串</p><p>  正如我们在新手教程中所讨论的，在JavaScript中拼字符串的缺点是可维护性不好。当你在JavaScript中将这些字符串拼到一起时，很难看出你正在写的HTML是什么-–|一个你页面展现的结构。而使用模板可以让你通过代码的空行和缩进来清楚地展现出你的HTML。</p></li><li><p>基于WebService的AJAX网站开发</p><p>  EJS可以接收WebService异步传送过来的JSON格式的数据，将这种数据直接传入你的模板里，然后将结果插入到你的页面中。你所需要做的只是通过以下代码:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> EJS(&#123;<span class="attr">url</span>: <span class="string">'comments.ejs'</span>&#125;).update(<span class="string">'element_id'</span>, <span class="string">'/comments.json'</span>);</span><br></pre></td></tr></table></figure></li><li><p>程序换肤功能</p><p>  如果你想给用户自制页面显示的功能，EJS提供了非常适合的机制。EJS的模板只在浏览器里执行，因此对你的服务器没有任何安全风险。你可以允许你的用户上传EJS模板以及其关联的样式表，从而实现定制你的网站页面的功能。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、什么是EJS&quot;&gt;&lt;a href=&quot;#一、什么是EJS&quot; class=&quot;headerlink&quot; title=&quot;一、什么是EJS&quot;&gt;&lt;/a&gt;一、什么是EJS&lt;/h3&gt;&lt;p&gt;EJS是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。&lt;/p&gt;
&lt;h3 id=&quot;二、为什么要使用EJS&quot;&gt;&lt;a href=&quot;#二、为什么要使用EJS&quot; class=&quot;headerlink&quot; title=&quot;二、为什么要使用EJS&quot;&gt;&lt;/a&gt;二、为什么要使用EJS&lt;/h3&gt;&lt;p&gt;与最初的JavaScript相比较，一些不太了解你的代码的人可以更容易地通过EJS模板代码看得懂你的代码。 让我们放松一下，一起来享受下令人激动的干净简洁的感觉。&lt;/p&gt;
&lt;p&gt;总之可以让代码更加干净整洁，让人易懂。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://duia.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://duia.github.io/tags/js/"/>
    
      <category term="ejs" scheme="https://duia.github.io/tags/ejs/"/>
    
      <category term="html" scheme="https://duia.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的增删改查</title>
    <link href="https://duia.github.io/2017/04/11/MongoDB%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>https://duia.github.io/2017/04/11/MongoDB的增删改查/</id>
    <published>2017-04-11T13:37:00.000Z</published>
    <updated>2019-05-20T05:00:00.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB-查询所有数据库"><a href="#MongoDB-查询所有数据库" class="headerlink" title="MongoDB 查询所有数据库"></a>MongoDB 查询所有数据库</h3><blockquote><p>show dbs;</p></blockquote><h3 id="MongoDB-切换-创建数据库"><a href="#MongoDB-切换-创建数据库" class="headerlink" title="MongoDB 切换/创建数据库"></a>MongoDB 切换/创建数据库</h3><blockquote><p>use DATABASE_NAME;</p></blockquote><p>如果数据库不存在，则创建数据库，否则切换到指定数据库。</p><h3 id="MongoDB-删除数据库"><a href="#MongoDB-删除数据库" class="headerlink" title="MongoDB 删除数据库"></a>MongoDB 删除数据库</h3><blockquote><p>db.dropDatabase()</p></blockquote><p>删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。<br><a id="more"></a></p><h3 id="MongoDB-插入文档"><a href="#MongoDB-插入文档" class="headerlink" title="MongoDB 插入文档"></a>MongoDB 插入文档</h3><p>文档的数据结构和JSON基本一样。</p><p>所有存储在集合中的数据都是BSON格式。</p><p>BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。</p><h4 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h4><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：</p><blockquote><p>db.COLLECTION_NAME.insert(document)</p></blockquote><p>插入文档你也可以使用 db.col.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。</p><h3 id="MongoDB-更新文档"><a href="#MongoDB-更新文档" class="headerlink" title="MongoDB 更新文档"></a>MongoDB 更新文档</h3><p>MongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。</p><h4 id="update-方法"><a href="#update-方法" class="headerlink" title="update() 方法"></a>update() 方法</h4><p>update() 方法用于更新已存在的文档。语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>query : update的查询条件，类似sql update查询内where后面的。</li><li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li><li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew，true为插入，默认是false，不插入。</li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li><li>writeConcern :可选，抛出异常的级别。</li></ul><h4 id="save-方法"><a href="#save-方法" class="headerlink" title="save() 方法"></a>save() 方法</h4><p>save() 方法通过传入的文档来替换已有文档。语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.save(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>document : 文档数据。</li><li>writeConcern :可选，抛出异常的级别。</li></ul><h3 id="MongoDB-删除文档"><a href="#MongoDB-删除文档" class="headerlink" title="MongoDB 删除文档"></a>MongoDB 删除文档</h3><p>MongoDB remove()函数是用来移除集合中的数据。</p><p>MongoDB数据更新可以使用update()函数。在执行remove()函数前先执行find()命令来判断执行的条件是否正确，这是一个比较好的习惯。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;justOne&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>如果你的 MongoDB 是 2.6 版本以后的，语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>query :（可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除一个文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul><h3 id="MongoDB-查询文档"><a href="#MongoDB-查询文档" class="headerlink" title="MongoDB 查询文档"></a>MongoDB 查询文档</h3><p>MongoDB 查询文档使用 find() 方法。</p><p>find() 方法以非结构化的方式来显示所有文档。</p><blockquote><p>db.COLLECTION_NAME.find(query, projection)</p></blockquote><ul><li>query ：可选，使用查询操作符指定查询条件</li><li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li></ul><p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p><blockquote><p>db.COLLECTION_NAME.find().pretty()</p></blockquote><p>pretty() 方法以格式化的方式来显示所有文档。</p><p>除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。</p><h4 id="MongoDB-与-RDBMS-Where-语句比较"><a href="#MongoDB-与-RDBMS-Where-语句比较" class="headerlink" title="MongoDB 与 RDBMS Where 语句比较"></a>MongoDB 与 RDBMS Where 语句比较</h4><p>如果你熟悉常规的 SQL 数据，通过下表可以更好的理解 MongoDB 的条件语句查询：</p><table><thead><tr><th>操作</th><th>格式</th><th>范例</th><th>RDBMS中的类似语句</th></tr></thead><tbody><tr><td>等于</td><td>{<key>:<value>}</value></key></td><td>db.col.find({“by”:”菜鸟教程”}).pretty()</td><td>where by = ‘菜鸟教程’</td></tr><tr><td>小于</td><td>{<key>:{$lt:<value>}}</value></key></td><td>db.col.find({“likes”:{$lt:50}}).pretty()</td><td>where likes &lt; 50</td></tr><tr><td>小于或等于</td><td>{<key>:{$lte:<value>}}</value></key></td><td>db.col.find({“likes”:{$lte:50}}).pretty()</td><td>where likes &lt;= 50</td></tr><tr><td>大于</td><td>{<key>:{$gt:<value>}}</value></key></td><td>db.col.find({“likes”:{$gt:50}}).pretty()</td><td>where likes &gt; 50</td></tr><tr><td>大于或等于</td><td>{<key>:{$gte:<value>}}</value></key></td><td>db.col.find({“likes”:{$gte:50}}).pretty()</td><td>where likes &gt;= 50</td></tr><tr><td>不等于</td><td>{<key>:{$ne:<value>}}</value></key></td><td>db.col.find({“likes”:{$ne:50}}).pretty()</td><td>where likes != 50</td></tr></tbody></table><h4 id="MongoDB-AND-条件"><a href="#MongoDB-AND-条件" class="headerlink" title="MongoDB AND 条件"></a>MongoDB AND 条件</h4><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开。</p><p>语法格式如下：</p><blockquote><p>db.COLLECTION_NAME.find({key1:value1, key2:value2}).pretty()</p></blockquote><h4 id="MongoDB-OR-条件"><a href="#MongoDB-OR-条件" class="headerlink" title="MongoDB OR 条件"></a>MongoDB OR 条件</h4><p>MongoDB OR 条件语句使用了关键字 $or,语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">     &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure></p><h3 id="MongoDB-Limit与Skip方法"><a href="#MongoDB-Limit与Skip方法" class="headerlink" title="MongoDB Limit与Skip方法"></a>MongoDB Limit与Skip方法</h3><h4 id="MongoDB-Limit-方法"><a href="#MongoDB-Limit-方法" class="headerlink" title="MongoDB Limit() 方法"></a>MongoDB Limit() 方法</h4><p>如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</p><blockquote><p>db.COLLECTION_NAME.find().limit(NUMBER)</p></blockquote><p>注：如果你们没有指定limit()方法中的参数则显示集合中的所有数据。</p><h4 id="MongoDB-Skip-方法"><a href="#MongoDB-Skip-方法" class="headerlink" title="MongoDB Skip() 方法"></a>MongoDB Skip() 方法</h4><p>我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。</p><blockquote><p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</p></blockquote><p>注:skip()方法默认参数为 0 。</p><h3 id="MongoDB-排序"><a href="#MongoDB-排序" class="headerlink" title="MongoDB 排序"></a>MongoDB 排序</h3><p>在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。</p><blockquote><p>db.COLLECTION_NAME.find().sort({KEY:1})</p></blockquote><h3 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB 聚合"></a>MongoDB 聚合</h3><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p><h4 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h4><p>MongoDB中聚合的方法使用aggregate()。</p><blockquote><p>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</p></blockquote><h4 id="聚合的表达式"><a href="#聚合的表达式" class="headerlink" title="聚合的表达式"></a>聚合的表达式</h4><table><thead><tr><th>表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>$sum</td><td>计算总和。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td></tr><tr><td>$avg</td><td>计算平均值</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td></tr><tr><td>$min</td><td>获取集合中所有文档对应值得最小值。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td></tr><tr><td>$max</td><td>获取集合中所有文档对应值得最大值。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td></tr><tr><td>$push</td><td>在结果文档中插入值到一个数组中。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td></tr><tr><td>$addToSet</td><td>在结果文档中插入值到一个数组中，但不创建副本。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td></tr><tr><td>$first</td><td>根据资源文档的排序获取第一个文档数据。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td></tr><tr><td>$last</td><td>根据资源文档的排序获取最后一个文档数据</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td></tr></tbody></table><h4 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h4><p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。</p><p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p><p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p><p>这里我们介绍一下聚合框架中常用的几个操作：</p><ul><li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</li><li>$limit：用来限制MongoDB聚合管道返回的文档数。</li><li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li>$group：将集合中的文档分组，可用于统计结果。</li><li>$sort：将输入文档排序后输出。</li><li>$geoNear：输出接近某一地理位置的有序文档。</li></ul><h3 id="spring-data-mongodb提供的丰富的api"><a href="#spring-data-mongodb提供的丰富的api" class="headerlink" title="spring-data-mongodb提供的丰富的api"></a>spring-data-mongodb提供的丰富的api</h3><p>在实际开发中，我们可以利用spring为我们提供的相关的操作mongodb的api进行数据的增删改查会方便很多，以下摘录就是实际开发中出现率最高的一批类及方法：</p><p>Criteria.java：组合查询条件，类似于我们sql中拼接where语句。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = Criteria.where(<span class="string">"..."</span>).is(...).and(<span class="string">"..."</span>).is(...);</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>Criteria</th><th>Mongodb</th><th>说明</th></tr></thead><tbody><tr><td>Criteria and (String key)</td><td>$and</td><td>并且</td></tr><tr><td>Criteria andOperator (Criteria…​ criteria)</td><td>$and</td><td>并且</td></tr><tr><td>Criteria orOperator (Criteria…​ criteria)</td><td>$or</td><td>或者</td></tr><tr><td>Criteria gt (Object o)</td><td>$gt</td><td>大于</td></tr><tr><td>Criteria gte (Object o)</td><td>$gte</td><td>大于等于</td></tr><tr><td>Criteria in (Object…​ o)</td><td>$in</td><td>包含</td></tr><tr><td>Criteria is (Object o)</td><td>$is</td><td>等于</td></tr><tr><td>Criteria lt (Object o)</td><td>$lt</td><td>小于</td></tr><tr><td>Criteria lte (Object o)</td><td>$lte</td><td>小等于</td></tr><tr><td>Criteria nin (Object…​ o)</td><td>$nin</td><td>不包含</td></tr></tbody></table><p>Query.java：类似于sql中将where语句和order by等组合起来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Query query = <span class="keyword">new</span> Query();</span><br><span class="line">query.addCriteria(criteria);</span><br><span class="line">query.with(<span class="keyword">new</span> Sort(<span class="keyword">new</span> Sort.Order(Sort.Direction.DESC, <span class="string">"age"</span>)));</span><br><span class="line">query.skip(<span class="number">5</span>).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p>AggregationOperation、Aggregation：聚合函数，类似于sql中count、sum等的函数</p><p>提供了类似于mongod管道操作功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AggregationOperation match = Aggregation.match(criteria);</span><br><span class="line">AggregationOperation sort = Aggregation.sort(Direction.DESC,<span class="string">"beginTime"</span>);</span><br><span class="line">AggregationOperation group = Aggregation.group(<span class="string">"$..."</span>).first().as(<span class="string">"..."</span>).avg()...</span><br><span class="line">Aggregation aggregation = Aggregation.newAggregation(match, sort, group);</span><br></pre></td></tr></table></figure></p><p>BasicDBObject.java 继承 BasicBSONObject 的一个 BSONObject 对象，类似于JSON对象。</p><p>MongoTemplate.java：spring的封装的api类，提供了各种对mongodb的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save();</span><br><span class="line">insert();</span><br><span class="line">upsert();</span><br><span class="line">find();</span><br><span class="line">findOne();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MongoDB-查询所有数据库&quot;&gt;&lt;a href=&quot;#MongoDB-查询所有数据库&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 查询所有数据库&quot;&gt;&lt;/a&gt;MongoDB 查询所有数据库&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;show dbs;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;MongoDB-切换-创建数据库&quot;&gt;&lt;a href=&quot;#MongoDB-切换-创建数据库&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 切换/创建数据库&quot;&gt;&lt;/a&gt;MongoDB 切换/创建数据库&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;use DATABASE_NAME;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果数据库不存在，则创建数据库，否则切换到指定数据库。&lt;/p&gt;
&lt;h3 id=&quot;MongoDB-删除数据库&quot;&gt;&lt;a href=&quot;#MongoDB-删除数据库&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 删除数据库&quot;&gt;&lt;/a&gt;MongoDB 删除数据库&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;db.dropDatabase()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="mongodb" scheme="https://duia.github.io/categories/JAVA/mongodb/"/>
    
      <category term="数据库" scheme="https://duia.github.io/categories/JAVA/mongodb/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://duia.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MongoDB" scheme="https://duia.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>CKEDITOR拖拽及单例化实现</title>
    <link href="https://duia.github.io/2017/03/30/CKEDITOR%E6%8B%96%E6%8B%BD%E5%8F%8A%E5%8D%95%E4%BE%8B%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    <id>https://duia.github.io/2017/03/30/CKEDITOR拖拽及单例化实现/</id>
    <published>2017-03-30T14:31:00.000Z</published>
    <updated>2019-05-21T23:00:00.003Z</updated>
    
    <content type="html"><![CDATA[<p><style type="text/css"><br>.sortClass { line-height: 34px; rgin-bottom: 5px; }<br>.editor{ border: 1px solid #ccc; padding: 5px; display: inline-block; width: 80%; }<br></style></p><div class="parentClass"><p></p></div><p></p><button type="button" class="btn btn-default add">新增一行</button><script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.min.js"></script><script src="//cdn.bootcss.com/ckeditor/4.0.1/ckeditor.js"></script><script type="text/javascript">(function(){    var myCkeditor;    $('.parentClass').sortable({        cancel:'.editor',        update: function (event, ui) {            ui.item.find('div[contenteditable=true]').blur();            if (myCkeditor) {                CKEDITOR.remove(myCkeditor);                $('#cke_'+myCkeditor.element.$.id).remove();                myCkeditor = undefined;            }            for (var editor in CKEDITOR.instances) {                $('#cke_'+editor).remove();                CKEDITOR.remove(CKEDITOR.instances[editor]);            }        }    });    $('.add').on('click', function(event) {        event.preventDefault();        var i = new Date().getTime();        $('.parentClass').append(htmlTemp(i));        // CKEDITOR.inline('editor'+i);    });    var htmlTemp = function(i){        var str = [];        str.push('<div class="sortClass">');        str.push('<span>选项 </span><div id="editor'+i+'" class="editor" contenteditable="true" placeholder="选项">'+i+'</div>');        str.push('</div>');        return str.join('');    }    var indexs = [0, 1, 2, 3, 4];    setTimeout(function(){        $.each(indexs, function(index, val) {            $('.parentClass').append(htmlTemp(index));        });        // CKEDITOR.inlineAll();    }, 1000);    $('.parentClass').off('blur', 'div[contenteditable=true]');    $('.parentClass').delegate('div[contenteditable=true]', 'blur', function(event){        event = event || window.event;        var $target = $(event.target);        $target.text()==''?$target.html(''):null;    });    $('.parentClass').off('focus', 'div[contenteditable=true]');    $('.parentClass').delegate('div[contenteditable=true]', 'focus', function(event){        event = event || window.event;        if (!myCkeditor) {//未实例化            myCkeditor = CKEDITOR.inline(event.target);        } else {            // console.log(myCkeditor.element.$.id);            // console.log(event.target.id);            if (myCkeditor.element.$.id === event.target.id) {            } else {//已实例化，但不是该文本框的实例                //清除并重新实例化                CKEDITOR.remove(myCkeditor);                $('#cke_'+myCkeditor.element.$.id).remove();                myCkeditor = CKEDITOR.inline(event.target);            }        }    });})();</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;br&gt;.sortClass { line-height: 34px; rgin-bottom: 5px; }&lt;br&gt;.editor{ border: 1px solid #ccc; padding: 5px; display:
      
    
    </summary>
    
      <category term="js" scheme="https://duia.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://duia.github.io/tags/js/"/>
    
      <category term="ckeditor" scheme="https://duia.github.io/tags/ckeditor/"/>
    
  </entry>
  
  <entry>
    <title>利用Kettle进行数据迁移</title>
    <link href="https://duia.github.io/2017/03/16/%E5%88%A9%E7%94%A8Kettle%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"/>
    <id>https://duia.github.io/2017/03/16/利用Kettle进行数据迁移/</id>
    <published>2017-03-16T04:41:00.000Z</published>
    <updated>2019-05-17T19:00:00.007Z</updated>
    
    <content type="html"><![CDATA[<p>Kettle是一款国外开源的ETL工具，纯java编写，又名pentaho。它提供了大量的组件进行数据操作，前段时间涉及到相关的数据迁移工作，利用kettle，简单概括一下使用率比较高的一部分组件。</p><p>具体内容分享在了有道云笔记网站，此处贴个链接，有兴趣的小伙伴们可以去看看。</p><p><a href="http://note.youdao.com/noteshare?id=bb03cfbca76563555ad38ddd2ac4ccea&amp;sub=549C87186C7543E39AF7BE32B6A70E7F" target="_blank" rel="noopener">利用Kettle进行数据迁移</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kettle是一款国外开源的ETL工具，纯java编写，又名pentaho。它提供了大量的组件进行数据操作，前段时间涉及到相关的数据迁移工作，利用kettle，简单概括一下使用率比较高的一部分组件。&lt;/p&gt;
&lt;p&gt;具体内容分享在了有道云笔记网站，此处贴个链接，有兴趣的小伙伴们可以去看看。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=bb03cfbca76563555ad38ddd2ac4ccea&amp;amp;sub=549C87186C7543E39AF7BE32B6A70E7F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;利用Kettle进行数据迁移&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="数据库" scheme="https://duia.github.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="数据库" scheme="https://duia.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>高级排序算法</title>
    <link href="https://duia.github.io/2017/02/28/%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://duia.github.io/2017/02/28/高级排序算法/</id>
    <published>2017-02-28T14:04:00.000Z</published>
    <updated>2019-05-20T05:00:00.003Z</updated>
    
    <content type="html"><![CDATA[<p>学习算法过程中自己写的一些高级排序的算法代码，做点记录，供以后复习。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wpc.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by admin on 2017/2/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span>[] arrS;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//循环 归并 排序</span></span><br><span class="line">        <span class="comment">/*int[] arrA = new int[]&#123;23, 34, 42, 65&#125;;</span></span><br><span class="line"><span class="comment">        int[] arrB = new int[]&#123;12, 21, 38, 58, 65, 75&#125;;</span></span><br><span class="line"><span class="comment">        int[] arrC = new int[10];</span></span><br><span class="line"><span class="comment">        merge(arrA, arrB, arrC);</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arrC.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            System.out.print(arrC[i]+" ");</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        mergeSort();</span></span><br><span class="line"><span class="comment">//        shellSort();</span></span><br><span class="line"><span class="comment">//        partitionIt();</span></span><br><span class="line"><span class="comment">//        System.out.println("");</span></span><br><span class="line">        quickSort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环 归并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrB</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arrA, <span class="keyword">int</span>[] arrB, <span class="keyword">int</span>[] arrC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; arrA.length &amp;&amp; b &lt; arrB.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrA[a] &lt; arrB[b]) &#123;</span><br><span class="line">                arrC[c++] = arrA[a++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arrC[c++] = arrB[b++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; arrA.length) &#123;</span><br><span class="line">            arrC[c++] = arrA[a++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; arrB.length) &#123;</span><br><span class="line">            arrC[c++] = arrB[b++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归 归并</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">long</span>[] arrs = getArrs(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">            System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span>[] tmpArr = <span class="keyword">new</span> <span class="keyword">long</span>[arrs.length];</span><br><span class="line">        recMergeSort(arrs, <span class="number">0</span>, arrs.length - <span class="number">1</span>, tmpArr);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">            System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recMergeSort</span><span class="params">(<span class="keyword">long</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">long</span>[] tmpArr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end)/<span class="number">2</span>;</span><br><span class="line">            recMergeSort(data, start, mid, tmpArr);</span><br><span class="line">            recMergeSort(data, mid + <span class="number">1</span>, end, tmpArr);</span><br><span class="line">            merge(data, start, mid + <span class="number">1</span>, end, tmpArr);</span><br><span class="line"><span class="comment">//            System.out.println("");</span></span><br><span class="line"><span class="comment">//            for (long l : data) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.print(l+" ");</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">long</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end, <span class="keyword">long</span>[] tmpArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = mid - <span class="number">1</span>, b = start, c = <span class="number">0</span>, n = end - start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= a &amp;&amp; mid &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[start] &lt; data[mid]) &#123;</span><br><span class="line">                tmpArr[c++] = data[start++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpArr[c++] = data[mid++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= a) &#123;</span><br><span class="line">            tmpArr[c++] = data[start++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (mid &lt;= end) &#123;</span><br><span class="line">            tmpArr[c++] = data[mid++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            data[b + i] = tmpArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序 插入排序的变形 按照h = h * 3 +1计算的间隔进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] arrs = getArrs(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">            System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= arrs.length/<span class="number">3</span>) &#123;</span><br><span class="line">            h = h * <span class="number">3</span> +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">while</span> (h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; arrs.length; i++) &#123;</span><br><span class="line">                temp = arrs[i];</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">while</span> (index &gt; h - <span class="number">1</span> &amp;&amp; temp &lt; arrs[index - h]) &#123;</span><br><span class="line">                    arrs[index] = arrs[index - h];</span><br><span class="line">                    index -= h;</span><br><span class="line">                &#125;</span><br><span class="line">                arrs[index] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            h = (h - <span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">            System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] arrs = getArrs(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">            System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        recQuickSort(arrs, <span class="number">0</span>, arrs.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">            System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recQuickSort</span> <span class="params">(<span class="keyword">long</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            manualSort(data, left, right);</span><br><span class="line"><span class="comment">//            insertionSort(data, left, right);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> pivot = medianOf3(data, left, right);<span class="comment">//三项数据取中//data[right];//简单快速排序</span></span><br><span class="line">            <span class="keyword">int</span> index = partitionIt(data, left, right, pivot);</span><br><span class="line">            recQuickSort(data, left, index - <span class="number">1</span>);</span><br><span class="line">            recQuickSort(data, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三项数据取中</span></span><br><span class="line"><span class="comment">     * 如果数据默认本来就是顺序或者倒叙排列，排序效率为O(N2),利用三项数据取中法，可以消除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">medianOf3</span> <span class="params">(<span class="keyword">long</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> center = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (data[left] &gt; data[right]) &#123;</span><br><span class="line">            swap(data, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data[left] &gt; data[center]) &#123;</span><br><span class="line">            swap(data, left, center);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data[center] &gt; data[right]) &#123;</span><br><span class="line">            swap(data, center, right);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(data, center, right - <span class="number">1</span>);<span class="comment">//将找到的枢纽放在数据后边（三项数据最大的数据前边），类似于取最后一位为枢纽</span></span><br><span class="line">        <span class="keyword">return</span> data[right - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序中处理小于切割界限时处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">manualSort</span> <span class="params">(<span class="keyword">long</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[left] &gt; data[right]) &#123;</span><br><span class="line">                swap(data, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[left] &gt; data[right]) &#123;</span><br><span class="line">                swap(data, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data[left] &gt; data[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(data, left, right - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data[right - <span class="number">1</span>] &gt; data[right]) &#123;</span><br><span class="line">                swap(data, right - <span class="number">1</span>, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序中处理小于切割界限时处理方法 也可以使用插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span> <span class="params">(<span class="keyword">long</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            temp = data[i];</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;left &amp;&amp; temp &lt; data[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                data[i] = data[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            data[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 划分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pivot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partitionIt</span><span class="params">(<span class="keyword">long</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">long</span> pivot)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftPrt = left, rightPrt = right - <span class="number">1</span>;<span class="comment">//三项数据取中，可以将首位项跳过，因为先前已经确定好分区位置</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (data[++leftPrt] &lt; pivot) &#123;&#125;<span class="comment">//无需leftPrt &lt; right的判断，因为pivot=data[right]，最终肯定不会越过right处</span></span><br><span class="line">            <span class="keyword">while</span> (data[--rightPrt] &gt; pivot) &#123;&#125;<span class="comment">//应用了三项数据取中无需rightPrt &gt; left，确定pivot前三个数据已排序</span></span><br><span class="line">            <span class="keyword">if</span> (leftPrt &gt;= rightPrt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(data, leftPrt, rightPrt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将找到的划分点数据和末尾的枢纽互换</span></span><br><span class="line">        swap(data, leftPrt, right - <span class="number">1</span>);<span class="comment">//三项数据取中末尾要前一位上</span></span><br><span class="line">        <span class="keyword">return</span> leftPrt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">long</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        temp = data[left];</span><br><span class="line">        data[left] = data[right];</span><br><span class="line">        data[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[] getArrs(<span class="keyword">int</span> count)&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">long</span>[] arrs;</span><br><span class="line">        arrs = <span class="keyword">new</span> <span class="keyword">long</span>[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; count; a++) &#123;</span><br><span class="line">            arrs[a] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习算法过程中自己写的一些高级排序的算法代码，做点记录，供以后复习。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://duia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://duia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="高级排序" scheme="https://duia.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单的排序算法</title>
    <link href="https://duia.github.io/2017/02/28/%E7%AE%80%E5%8D%95%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://duia.github.io/2017/02/28/简单的排序算法/</id>
    <published>2017-02-28T13:55:00.000Z</published>
    <updated>2019-05-20T01:00:00.006Z</updated>
    
    <content type="html"><![CDATA[<h3 id="共用的方法："><a href="#共用的方法：" class="headerlink" title="共用的方法："></a>共用的方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组生成：随机生成1~20个100范围内的数的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[] getArrs()&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">long</span>[] arrs;</span><br><span class="line">    <span class="keyword">int</span> count = random.nextInt(<span class="number">20</span>) + <span class="number">1</span>;</span><br><span class="line">    arrs = <span class="keyword">new</span> <span class="keyword">long</span>[count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; count; a++) &#123;</span><br><span class="line">        arrs[a] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序：比较相邻两个数据，如果前边的值大于后边的值，将大值交换到小值的位置，后边的值即大值先有序</span></span><br><span class="line"><span class="comment"> * 比较次数为n(n-1)/2次 ≈n²/2 平均交换次数大约为比较次数的一半，即 n²/4 所以时间复杂度为 O(n²)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maopao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] arrs = getArrs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">        System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arrs.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrs[j] &gt; arrs[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">long</span> temp = arrs[j];</span><br><span class="line">                arrs[j] = arrs[j+<span class="number">1</span>];</span><br><span class="line">                arrs[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">        System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序：标记下起始值，比较起始值和后边的每一个值，找出最小值，与起始值互换位置，前边的值即小值先有序</span></span><br><span class="line"><span class="comment"> * 比较次数为n(n-1)/2次 ≈n²/2 最大的交换次数为 n-1次 时间复杂度为 O(n²)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xuanze</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] arrs = getArrs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">        System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrs.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arrs.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrs[j] &lt; arrs[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != index) &#123;</span><br><span class="line">            <span class="keyword">long</span> temp = arrs[i];</span><br><span class="line">            arrs[i] = arrs[index];</span><br><span class="line">            arrs[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">        System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序：标记下起始值和起始标记，再前边有序的部分中找到该插入的位置，并移动后边的值。</span></span><br><span class="line"><span class="comment"> * 比较次数为n(n-1)/2次 ≈n²/2 平均交换次数和比较次数的一样 所以时间复杂度为 O(n²)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] arrs = getArrs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">        System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> temp;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">        temp = arrs[i];</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">0</span> &amp;&amp; temp &lt; arrs[k-<span class="number">1</span>]) &#123;</span><br><span class="line">            arrs[k] = arrs[k-<span class="number">1</span>];</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        arrs[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> l : arrs) &#123;</span><br><span class="line">        System.out.print(l+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找：查找有序数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">long</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">int</span> index = (start + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[index] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[index] &lt; key) &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[index] &gt; key) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归方式实现 二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find2</span><span class="params">(<span class="keyword">long</span> key, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = (start + end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[index] == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[index] &lt; key) &#123;</span><br><span class="line">            <span class="keyword">return</span> find2(key, index + <span class="number">1</span>, end);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[index] &gt; key) &#123;</span><br><span class="line">            <span class="keyword">return</span> find2(key, start, index - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;共用的方法：&quot;&gt;&lt;a href=&quot;#共用的方法：&quot; class=&quot;headerlink&quot; title=&quot;共用的方法：&quot;&gt;&lt;/a&gt;共用的方法：&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 数组生成：随机生成1~20个100范围内的数的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;[] getArrs()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Random random = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Random();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;[] arrs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count = random.nextInt(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    arrs = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;[count];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; a &amp;lt; count; a++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        arrs[a] = random.nextInt(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arrs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="https://duia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="简单排序" scheme="https://duia.github.io/tags/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法" scheme="https://duia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java利用WebSocket实现长连接</title>
    <link href="https://duia.github.io/2017/02/26/Java%E5%88%A9%E7%94%A8WebSocket%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    <id>https://duia.github.io/2017/02/26/Java利用WebSocket实现长连接/</id>
    <published>2017-02-26T10:30:00.000Z</published>
    <updated>2019-05-11T15:00:00.083Z</updated>
    
    <content type="html"><![CDATA[<p>在java web开发中，考虑性能时其中有一点：尽可能的减少http请求数。这样除了能加快页面加载速度，更大的好处就是为服务器节省资源，降低服务器压力。但是有时候会遇到一些需求，例如需要实时的从服务器获取一些数据信息，我们最快的想到的办法就是写个定时器，不停的向服务器发送请求，来获取最新数据。这样恰恰与我们上边说的相违背。</p><p>以前的自己也是这样处理的，这种方式被称为“轮询”。可以想象到，当很多人同时打开网页时，轮询全部开启，服务器同一时间收到的请求会很大，后来慢慢的接触到了websocket，为解决这种问题带来了便利，总结学习一下，以供大家共同学习。<br><a id="more"></a><br>其实网上现在搜索一下也会有很多了案例，大部分都是通过三个类来实现的：一个拦截器——供用户建立握手链接，一个消息处理器——分发信息使用，还有一个关于websocket的配置类——配置websocket。</p><p>其实还有更简单的配置方法，spring-websocket为我们提供了很便利的使用方法，只通过一个websocket的配置类即可完成对websocket的支持，先上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wpc.web.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.config.MessageBrokerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.StompEndpointRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.wpc.web"</span>)<span class="comment">//这个路径为下边要配置的controller的包</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">"/socket"</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.enableSimpleBroker(<span class="string">"/topic"</span>);</span><br><span class="line">    registry.setApplicationDestinationPrefixes(<span class="string">"/app"</span>);</span><br><span class="line">    registry.setUserDestinationPrefix(<span class="string">"/user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>相关说明：</p></blockquote><blockquote><p>registerStompEndpoints(StompEndpointRegistry registry)<br>这个方法的作用是添加一个服务端点，来接收客户端的连接。</p></blockquote><blockquote><p>registry.addEndpoint(“/socket”)<br>表示添加了一个<code>/socket</code>端点，客户端就可以通过这个端点来进行连接。</p></blockquote><blockquote><p>withSockJS()的作用是开启SockJS支持</p></blockquote><blockquote><p>configureMessageBroker(MessageBrokerRegistry config)<br>这个方法的作用是定义消息代理，通俗一点讲就是设置消息连接请求的各种规范信息。</p></blockquote><blockquote><p>registry.enableSimpleBroker(“/topic”)<br>表示客户端订阅地址的前缀信息，也就是客户端接收服务端消息的地址的前缀信息（比较绕，看完整个例子，大概就能明白了）</p></blockquote><blockquote><p>registry.setApplicationDestinationPrefixes(“/app”)<br>指服务端接收地址的前缀，意思就是说客户端给服务端发消息的地址的前缀<br>上面两个方法定义的信息其实是相反的，一个定义了客户端接收的地址前缀，一个定义了客户端发送地址的前缀</p></blockquote><blockquote><p>registry.setUserDestinationPrefix(“/user”)<br>用于针对某个客户端接收地址的前缀，也就是说服务端如果需要有针对性的给客户端推送消息时，除了enableSimpleBroker中配置的前缀，需要额外的添加的前缀（更绕，下边举例说明）</p></blockquote><p>这里有比较绕一点的地方就是方法<code>configureMessageBroker</code>里边配置的几个路径，下边我会详细的举例说明的，在这之前需要配置一个controller，代码如下，这个controller其实就是咱们在spring-mvc中经常使用的控制器，唯一不同的是多了几个注解，这是spring为我们提供的，先看代码，后边说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wpc.web.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.MessageMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.SendTo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.annotation.SendToUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Principal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/socket"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/change-notice"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"/topic/notice"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/user-change-notice"</span>)</span><br><span class="line"><span class="meta">@SendToUser</span>(<span class="string">"/topic/notice"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">greeting2</span><span class="params">(String value, Principal principal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value + principal.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上述的基本配置信息，我们就可以编写基本功能了。这里先简单说明两个知识点：</p><blockquote><p>MessageMapping<br>Spring对于WebSocket封装的特别简单，提供了一个@MessageMapping注解，功能类似@RequestMapping，它是存在于Controller中的，定义一个消息的基本请求，功能也跟@RequestMapping类似，包括支持通配符的url定义等等</p></blockquote><blockquote><p>@SendTo、@SendToUser<br>定义了消息的目的地，会将方法返回的字符串定向发送到指定路径上。@SendTo是发送给所有客户端，@SendToUser是发送到指定客户端，具体发送指定客户端是通过session来区分的，所以使用该功能必须进行登陆，来产生session。</p></blockquote><p>以上所有配置就算是完成了，有几个比较绕一点的地方现在具体说明一下，就按上边的配置路径来直接说明：</p><ul><li>服务端向所有客户端发送信息的路径为<code>/topic/notice</code></li><li>服务端向指定客户端发送消息的路径为<code>/user/topic/notice</code></li><li>客户端向服务端发送信息的路径为<code>/app/change-notice</code>和<code>/app/user-change-notice</code></li></ul><p>topic、user、app全为websocket配置类中配置的前缀路径。为了简化说明，我上边在同一个方法上同时配置了@MessageMapping和@SendTo，也很容易理解——客户端发送到服务端来的消息直接再向所有的客户端发送出去。</p><p>如果单纯的要从服务端产生消息向客户端发送，spring也为我们提供了一个类——<code>SimpMessagingTemplate</code>，<code>SimpMessagingTemplate</code>是Spring-WebSocket内置的一个消息发送工具，可以将消息发送到指定的客户端。具体使用方法大家看看api。</p><p>前端代码</p><p>这里利用了<code>sockjs.js</code>和<code>stomp.js</code>。</p><p>其中SockJS 是一个浏览器上运行的 JavaScript 库，如果浏览器不支持 WebSocket，该库可以模拟对 WebSocket 的支持，实现浏览器和 Web 服务器之间低延迟、全双工、跨域的通讯通道。</p><p>Stomp 提供了客户端和代理之间进行广泛消息传输的框架。Stomp 是一个非常简单而且易用的通讯协议实现，尽管代理端的编写可能非常复杂，但是编写一个 Stomp 客户端却是很简单的事情，另外你可以使用 Telnet 来与你的 Stomp 代理进行交互。</p><p>以下是代码，很简单了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stompClient = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 开启socket连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(<span class="string">'/socket'</span>);        </span><br><span class="line">    stompClient = Stomp.over(socket);        </span><br><span class="line">    stompClient.connect(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">frame</span>) </span>&#123;            </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'notice socket connected!'</span>);</span><br><span class="line">        stompClient.subscribe(<span class="string">'/topic/notice'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//对所有信息监听</span></span><br><span class="line">        &#125;);</span><br><span class="line">        stompClient.subscribe(<span class="string">'/user/topic/notice'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//对针对性信息监听</span></span><br><span class="line">        &#125;);       </span><br><span class="line">    &#125;);    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 断开socket连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disconnect</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (stompClient != <span class="literal">null</span>) &#123;            </span><br><span class="line">        stompClient.disconnect();        </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Disconnected"</span>);    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 向‘/app/change-notice’服务端发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendName</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">    stompClient.send(<span class="string">"/app/change-notice"</span>, &#123;&#125;, <span class="string">"......"</span>);    </span><br><span class="line">&#125;    </span><br><span class="line">connect();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java web开发中，考虑性能时其中有一点：尽可能的减少http请求数。这样除了能加快页面加载速度，更大的好处就是为服务器节省资源，降低服务器压力。但是有时候会遇到一些需求，例如需要实时的从服务器获取一些数据信息，我们最快的想到的办法就是写个定时器，不停的向服务器发送请求，来获取最新数据。这样恰恰与我们上边说的相违背。&lt;/p&gt;
&lt;p&gt;以前的自己也是这样处理的，这种方式被称为“轮询”。可以想象到，当很多人同时打开网页时，轮询全部开启，服务器同一时间收到的请求会很大，后来慢慢的接触到了websocket，为解决这种问题带来了便利，总结学习一下，以供大家共同学习。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="websocket" scheme="https://duia.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>jquery.validate自定义验证和返回多种结果</title>
    <link href="https://duia.github.io/2016/12/17/jquery.validate%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E5%92%8C%E8%BF%94%E5%9B%9E%E5%A4%9A%E7%A7%8D%E7%BB%93%E6%9E%9C/"/>
    <id>https://duia.github.io/2016/12/17/jquery.validate自定义验证和返回多种结果/</id>
    <published>2016-12-17T13:08:00.000Z</published>
    <updated>2019-05-20T02:00:00.003Z</updated>
    
    <content type="html"><![CDATA[<p>在使用jquery validate做表单验证时遇到如下需求：</p><p>验证需要请求服务器，且验证结果有多种情况，要根据不同验证结果提示不同信息。</p><p>很显然利用<code>remote</code>是无法满足需求的，所以只能通过自定义验证方法来进行验证，现总结如下：<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jQuery.validator.addMethod(<span class="string">"checkUser"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'...'</span>,<span class="comment">//请求路径</span></span><br><span class="line">        <span class="keyword">async</span>:<span class="literal">false</span>,<span class="comment">//要指定不能异步,必须等待后台服务校验完成再执行后续代码</span></span><br><span class="line">        type: <span class="string">"post"</span>,</span><br><span class="line">        dataType:<span class="string">"json"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            str: $.trim(value)</span><br><span class="line">        &#125;,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;<span class="comment">//返回数据data里包含了验证结果true或false以及提示信息</span></span><br><span class="line">            <span class="keyword">if</span>(data.result)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//动态修改自定义验证的提示信息</span></span><br><span class="line">                jQuery.validator.modifyMessages(<span class="string">"checkUser"</span>,data.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>服务器代码略，根据上边注解应该大概了解是什么样子了…</p><p>以下提供了一些常用的自定义验证，留档备用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符最小长度验证（一个中文字符长度为2）</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"stringMinLength"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> length = value.length;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.charCodeAt(i) &gt; <span class="number">127</span>) &#123;</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (length &gt;= param);</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"长度不能小于&#123;0&#125;!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符最大长度验证（一个中文字符长度为2）</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"stringMaxLength"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> length = value.length;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.charCodeAt(i) &gt; <span class="number">127</span>) &#123;</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (length &lt;= param);</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"长度不能大于&#123;0&#125;!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"stringCheck"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || <span class="regexp">/^[\u0391-\uFFE5\w]+$/</span>.test(value);</span><br><span class="line">    &#125;, <span class="string">"只能包括中文字、英文字母、数字和下划线"</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中文字两个字节       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"byteRangeLength"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> length = value.length;       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; value.length; i++)&#123;       </span><br><span class="line">            <span class="keyword">if</span>(value.charCodeAt(i) &gt; <span class="number">127</span>)&#123;       </span><br><span class="line">                length++;       </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || ( length &gt;= param[<span class="number">0</span>] &amp;&amp; length &lt;= param[<span class="number">1</span>] );       </span><br><span class="line">    &#125;, <span class="string">"请确保输入的值在3-15个字节之间(一个中文字算2个字节)"</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符验证</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"string"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || <span class="regexp">/^[\u0391-\uFFE5\w]+$/</span>.test(value);</span><br><span class="line">    &#125;, <span class="string">"不允许包含特殊符号!"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须以特定字符串开头验证</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"begin"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> begin = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^"</span> + param);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (begin.test(value));</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"必须以 &#123;0&#125; 开头!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证两次输入值是否不相同</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"notEqualTo"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value != $(param).val();</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"两次输入不能相同!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证值不允许与特定值等于</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"notEqual"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value != param;</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"输入值不允许为&#123;0&#125;!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证值必须大于特定值(不能等于)</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"gt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt; param;</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"输入值必须大于&#123;0&#125;!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证值小数位数不能超过两位</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"decimal"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> decimal = <span class="regexp">/^-?\d+(\.\d&#123;1,2&#125;)?$/</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (decimal.test(value));</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"小数位数不能超过两位!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字母数字</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"alnum"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || <span class="regexp">/^[a-zA-Z0-9]+$/</span>.test(value);</span><br><span class="line">    &#125;, <span class="string">"只能包括英文字母和数字"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 汉字</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"chcharacter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tel = <span class="regexp">/^[\u4e00-\u9fa5]+$/</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (tel.test(value));</span><br><span class="line">    &#125;, <span class="string">"请输入汉字"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 身份证号码验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isIdCardNo"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || <span class="regexp">/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/</span>.test(value)||<span class="regexp">/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d&#123;4&#125;)|\d&#123;3&#125;[A-Z])$/</span>.test(value);</span><br><span class="line">    &#125;, <span class="string">"请正确输入您的身份证号码"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手机号码验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isMobile"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;       </span><br><span class="line">        <span class="keyword">var</span> length = value.length;   </span><br><span class="line">        <span class="keyword">var</span> mobile = <span class="regexp">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/</span>;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (length == <span class="number">11</span> &amp;&amp; mobile.test(value));</span><br><span class="line">    &#125;, <span class="string">"请正确填写您的手机号码"</span>);       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 电话号码验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isTel"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;       </span><br><span class="line">        <span class="keyword">var</span> tel = <span class="regexp">/^\d&#123;3,4&#125;-?\d&#123;7,9&#125;$/</span>;    <span class="comment">//电话号码格式010-12345678   </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (tel.test(value));       </span><br><span class="line">    &#125;, <span class="string">"请正确填写您的电话号码"</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 联系电话(手机/电话皆可)验证   </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isPhone"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value,element</span>) </span>&#123;   </span><br><span class="line">        <span class="keyword">var</span> length = value.length;   </span><br><span class="line">        <span class="keyword">var</span> mobile = <span class="regexp">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/</span>;   </span><br><span class="line">        <span class="keyword">var</span> tel = <span class="regexp">/^\d&#123;3,4&#125;-?\d&#123;7,9&#125;$/</span>;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (tel.test(value) || mobile.test(value));</span><br><span class="line">    &#125;, <span class="string">"请正确填写您的联系电话"</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 邮政编码验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isZipCode"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;       </span><br><span class="line">        <span class="keyword">var</span> tel = <span class="regexp">/^[0-9]&#123;6&#125;$/</span>;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (tel.test(value));       </span><br><span class="line">    &#125;, <span class="string">"请正确填写您的邮政编码"</span>);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用jquery validate做表单验证时遇到如下需求：&lt;/p&gt;
&lt;p&gt;验证需要请求服务器，且验证结果有多种情况，要根据不同验证结果提示不同信息。&lt;/p&gt;
&lt;p&gt;很显然利用&lt;code&gt;remote&lt;/code&gt;是无法满足需求的，所以只能通过自定义验证方法来进行验证，现总结如下：&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="https://duia.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://duia.github.io/tags/js/"/>
    
      <category term="jquery" scheme="https://duia.github.io/tags/jquery/"/>
    
      <category term="dataTables" scheme="https://duia.github.io/tags/dataTables/"/>
    
  </entry>
  
  <entry>
    <title>讲解最详细的shiro的权限认证原理</title>
    <link href="https://duia.github.io/2016/12/04/%E8%AE%B2%E8%A7%A3%E6%9C%80%E8%AF%A6%E7%BB%86%E7%9A%84shiro%E7%9A%84%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/"/>
    <id>https://duia.github.io/2016/12/04/讲解最详细的shiro的权限认证原理/</id>
    <published>2016-12-04T13:52:00.000Z</published>
    <updated>2019-05-17T17:00:00.006Z</updated>
    
    <content type="html"><![CDATA[<p>最近喜欢上了看源码，正好又使用了shiro进行权限认证，一方面出于好奇，另一方面一直对shiro通过对比权限码的验证过程有点疑问，所以想看看shiro的运行过程。</p><p>在通过读源码的过程与程序运行的跟踪，也看出了一点点信息，现总结如下，和大家分享。shiro与spring整合的过程我也就不过多的说明了。简要说明一下需要注意的地方以及权限判断的对比过程。<br><a id="more"></a></p><h3 id="开启Shiro的注解"><a href="#开启Shiro的注解" class="headerlink" title="开启Shiro的注解"></a>开启Shiro的注解</h3><p>如@RequiresRoles，@RequiresPermissions，需借助SpringAOP扫描使用Shiro注解的类，并在必要时进行安全逻辑验证<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span> <span class="attr">depends-on</span>=<span class="string">"lifecycleBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyTargetClass"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这段代码必须放在spring-mvc.xml相关的配置文件中才会起作用。</p><h3 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h3><p>实现doGetAuthenticationInfo和doGetAuthorizationInfo两个方法。</p><h4 id="授权过程。"><a href="#授权过程。" class="headerlink" title="授权过程。"></a>授权过程。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法实现一般需要从数据库获取登陆人员所具有的权限和角色。</p><h4 id="认证回调函数，登录时调用，获取认证信息。"><a href="#认证回调函数，登录时调用，获取认证信息。" class="headerlink" title="认证回调函数，登录时调用，获取认证信息。"></a>认证回调函数，登录时调用，获取认证信息。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticatingRealm</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的实现方法需要从数据库获取登陆用户的用户名和密码，以便进行和用户输入的信息进行匹配。</p><h3 id="Permission和WildcardPermission"><a href="#Permission和WildcardPermission" class="headerlink" title="Permission和WildcardPermission"></a>Permission和WildcardPermission</h3><p><code>WildcardPermission</code>实现了<code>Permission</code>接口，接口的主要方法是<code>implies</code>。</p><p><code>WildcardPermission</code>是shiro默认的权限对比类。对比权限的方法如：<code>checkPermission</code>、<code>isPermitted</code>等，以及相关的注解最终的权限判断方式全是<code>WildcardPermission</code>的<code>implies</code>实现。</p><p>核心代码摘录：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">implies</span><span class="params">(Permission p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// By default only supports comparisons with other WildcardPermissions</span></span><br><span class="line">    <span class="keyword">if</span> (!(p <span class="keyword">instanceof</span> WildcardPermission)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WildcardPermission wp = (WildcardPermission) p;</span><br><span class="line"></span><br><span class="line">    List&lt;Set&lt;String&gt;&gt; otherParts = wp.getParts();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Set&lt;String&gt; otherPart : otherParts) &#123;</span><br><span class="line">        <span class="comment">// If this permission has less parts than the other permission, everything after the number of parts contained</span></span><br><span class="line">        <span class="comment">// in this permission is automatically implied, so return true</span></span><br><span class="line">        <span class="keyword">if</span> (getParts().size() - <span class="number">1</span> &lt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;String&gt; part = getParts().get(i);</span><br><span class="line">            <span class="keyword">if</span> (!part.contains(WILDCARD_TOKEN) &amp;&amp; !part.containsAll(otherPart)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this permission has more parts than the other parts, only imply it if all of the other parts are wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; getParts().size(); i++) &#123;</span><br><span class="line">        Set&lt;String&gt; part = getParts().get(i);</span><br><span class="line">        <span class="keyword">if</span> (!part.contains(WILDCARD_TOKEN)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>模拟测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WildcardPermission p1 = <span class="keyword">new</span> WildcardPermission(<span class="string">"user:del:0"</span>);</span><br><span class="line">WildcardPermission p2 = <span class="keyword">new</span> WildcardPermission(<span class="string">"user:del:2"</span>);</span><br><span class="line">System.out.println(p1.implies((Permission) p2));</span><br></pre></td></tr></table></figure></p><p>对比抽取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; part = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; otherPart = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">part.add(<span class="string">"del"</span>);</span><br><span class="line">otherPart.add(<span class="string">"del"</span>);</span><br><span class="line">System.out.println(part.contains(<span class="string">"*"</span>));</span><br><span class="line">System.out.println(part.containsAll(otherPart));</span><br></pre></td></tr></table></figure></p><p>最终说明：前后匹配的字符串全部被<code>WildcardPermission</code>封装，<code>new WildcardPermission(&quot;user:del:0&quot;);</code>这个过程中将形如<code>user:del:0</code>类型的字符串按<code>:</code>分割字符串，转换成了<code>List&lt;Set&lt;String&gt;&gt;</code>的集合，对比时，按对应位置（脚标）的<code>Set&lt;String&gt;</code>进行对比，所有位置全部对应则匹配成功，只要有一个位置不对应则匹配失败，在对比过程中如遇<code>*</code>，跳过该位置，表示此位有所有权限，对比到某一位不匹配时直接短路，匹配失败。之所以是<code>Set&lt;String&gt;</code>考虑有<code>user:save,del,update:0</code>类型的字符串，用<code>,</code>分割存入<code>Set&lt;String&gt;</code>中。</p><p>了解了以上原理，我们即可更灵活的使用shiro来做一些权限验证。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近喜欢上了看源码，正好又使用了shiro进行权限认证，一方面出于好奇，另一方面一直对shiro通过对比权限码的验证过程有点疑问，所以想看看shiro的运行过程。&lt;/p&gt;
&lt;p&gt;在通过读源码的过程与程序运行的跟踪，也看出了一点点信息，现总结如下，和大家分享。shiro与spring整合的过程我也就不过多的说明了。简要说明一下需要注意的地方以及权限判断的对比过程。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="源码阅读" scheme="https://duia.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="shiro" scheme="https://duia.github.io/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>通用的权限系统设计</title>
    <link href="https://duia.github.io/2016/11/27/%E9%80%9A%E7%94%A8%E7%9A%84%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://duia.github.io/2016/11/27/通用的权限系统设计/</id>
    <published>2016-11-27T08:13:00.000Z</published>
    <updated>2019-05-11T15:00:00.099Z</updated>
    
    <content type="html"><![CDATA[<p>以前也做过大概两三次的权限系统了吧，每次开发的时候都需要去根据相应的业务设置具体的权限规则及管理系统。所以产生了这样的想法，能不能设计一个比较通用的权限管理系统，以后如果在遇到需要权限系统可以直接套用。经过查资料、自己整理、开发测试，整理出了一套比较通用的权限管理系统，以做记录，和大家共同探讨学习，看看哪里有不对的、或什么更好的设计方案，一起进步。</p><p>不敢说很通用，任何系统的不存在最完美，只有更完美，所以我也只能说是比较通用，由于本人是做java开发的，所以实现和测试全是通过java语言进行开发的，但本人感觉思想是通用的。以下的设计也是基于网络上现有的比较大路的做法，结合自己以前的开发经验进行的整理和总结，大部分博客网站都比较粗略提点，所以也促使我自己整理一套比较容易阅读的设计方案。<br><a id="more"></a></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>先上图，以下是我关于数据库的设计，具体有什么注意点我会在之后一一介绍：</p><p><img src="/upload/2019/1/user_role_permission20190216145048318.png" alt="image"></p><h3 id="主体数据"><a href="#主体数据" class="headerlink" title="主体数据"></a>主体数据</h3><p>user（用户表）、role（角色表）、permission（权限表），三个表构成了权限系统的主体，这也就是常说的RBAC（Role-Based Access Control，基于角色的访问控制）权限管理。</p><p>用户与角色之间、角色与权限之间，都是多对多的关系，所以需要中间表进行关联维护，即图中role_user表和role_permission表。</p><p>用法：有了这样的关系，当人员登陆后，根据人员获取角色，通过角色获取权限的通道就打通了。</p><h3 id="权限数据控制"><a href="#权限数据控制" class="headerlink" title="权限数据控制"></a>权限数据控制</h3><p>我们经常用到的系统有具体的菜单、页面上有按钮、有可下载的文件等等，其实这些都不是权限，这只是系统中可操作的一些资源，我们一般也是在控制这些资源的可见性、是否有使用的权利，如某个菜单是否可见、某个按钮是否可点击、某个文件是否可下载等。所以我们也就将这些资源作为了权利的载体，对权限的控制也就是在控制资源的可见可用性。</p><p>这段话不知道表达明白我的意思没，为啥会先写这么一段话，因为我在很多网站上看到大家其实都没明白了资源和权限的关系，甚至有人会问：权限表和菜单表具体在表里面是怎么体现的，我怎样把这几个功能菜单给某个权限呢？这就是问题的关键，明白了上边我所说的，也就明白了这个问题了。下边我会给出两种方案，具体实现资源与权限的关联。</p><p>回归到上边表设计上，permission（权限表）和menu（菜单表）、button（按钮表）、file（文件表）其实是一一对应的关系，每产生一个菜单，也就相应的产生了一条权限数据。所以为了区分具体的资源权限，permission表有个字段permission_type，可以定义不同的常量字符串来区分。</p><p>这时候有两种方案可以采取：</p><ul><li>每次维护菜单、按钮、文件等资源时，同时维护权限表中相应的权限数据，之后为角色授权时，主要维护role_permission（角色权限关联表）。</li><li>每次维护菜单、按钮、文件等资源时不维护权限数据，如上边所说的隐性的将三种资源数据看成权限数据，在给角色授权时，相应的写入到permission表中。（需要加个角色id字段）</li></ul><p>个人感觉方案1比较好点，方案2的缺点在于时间长了权限表中的数据量会比较大。</p><h3 id="其他扩展"><a href="#其他扩展" class="headerlink" title="其他扩展"></a>其他扩展</h3><h4 id="如上设计权限表和资源表一对一关联的结构，有两个好处"><a href="#如上设计权限表和资源表一对一关联的结构，有两个好处" class="headerlink" title="如上设计权限表和资源表一对一关联的结构，有两个好处"></a>如上设计权限表和资源表一对一关联的结构，有两个好处</h4><p>其一在维护资源数据的时候产生的权限数据，在授权时就无需在关注具体资源类型，所有的权限数据当成一种数据处理即可。</p><p>其二方便扩展，每新增一种资源时，多添加一个表和权限类型即可。如上图有个operation（操作表），在开发过程中发现有部分权限都不属于以上三种资源，即新扩展一种资源。</p><h4 id="人员授权、分组授权"><a href="#人员授权、分组授权" class="headerlink" title="人员授权、分组授权"></a>人员授权、分组授权</h4><p>如上图设计，部门对人员属于一对多的关系，如有一个成员可以属于多个分组或部门的情况可以添加中间表进行维护。</p><p>如需要对某个人员进行授权，新增人员与权限之间的关联表即可，同理，部门或分组授权同理。</p><h2 id="权限码的使用"><a href="#权限码的使用" class="headerlink" title="权限码的使用"></a>权限码的使用</h2><p>有无权限的判断主要通过权限码来判断，为不同的资源赋予不同的资源编码，在每次使用时利用权限码判断是否有权限。为了提高效率我们可以应用shiro整合项目进行权限的判断。</p><p>我的项目是springMVC，整合shiro的过程网上一搜一大片，我就不在这里写具体的实现过程了，我上边设计的权限数据库的实现与shiro是没有关系的，我们完全可以自己实现权限判断的逻辑，当然利用shiro可以更高效的完成权限判断，并利用shiro提供的一整套注解和标签进行权限控制。在这里我就提点一下shiro的底层原理。</p><p>其实shiro底层实现权限判断的功能就是通过对比权限码字符串来判断的。shiro默认的为我们提供了一种效率较高的对比规则，即用“<code>:</code>”来区分权限的层级关系，并可以利用“<code>*</code>”来代表该层级的全部权限。之所以要提这一点是因为我发现网上好多地方直接全部都是直接利用这种规则，没有任何说明，造成了使用误区，让咱们误以为利用shiro只能按那种规则进行权限码的规定。</p><p>WildcardPermission.java中implies方法（shiro默认的对比器）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">implies</span><span class="params">(Permission p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// By default only supports comparisons with other WildcardPermissions</span></span><br><span class="line">    <span class="keyword">if</span> (!(p <span class="keyword">instanceof</span> WildcardPermission)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WildcardPermission wp = (WildcardPermission) p;</span><br><span class="line"></span><br><span class="line">    List&lt;Set&lt;String&gt;&gt; otherParts = wp.getParts();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Set&lt;String&gt; otherPart : otherParts) &#123;</span><br><span class="line">        <span class="comment">// If this permission has less parts than the other permission, everything after the number of parts contained</span></span><br><span class="line">        <span class="comment">// in this permission is automatically implied, so return true</span></span><br><span class="line">        <span class="keyword">if</span> (getParts().size() - <span class="number">1</span> &lt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;String&gt; part = getParts().get(i);</span><br><span class="line">            <span class="keyword">if</span> (!part.contains(WILDCARD_TOKEN) &amp;&amp; !part.containsAll(otherPart)) &#123;<span class="comment">//WILDCARD_TOKEN = "*"</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this permission has more parts than the other parts, only imply it if all of the other parts are wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; getParts().size(); i++) &#123;</span><br><span class="line">        Set&lt;String&gt; part = getParts().get(i);</span><br><span class="line">        <span class="keyword">if</span> (!part.contains(WILDCARD_TOKEN)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有兴趣的大家跟踪一下这段代码，可以学到一些知识，shiro的对比器会将已有权限的权限码和要判断的权限码用“<code>:</code>”分割成集合，按对应位置对比，发现是“<code>*</code>”时直接跳过对比下一位置。</p><p>所以既然要利用shiro提供便捷，就需要按照shiro的规则来指定权限码，可以将我们设计的权限数据中菜单看成权限码的第一级，按钮是第二级，之间用“<code>:</code>”分割，更具体的需要大家去设计了。</p><p>个人人为，如果将权限码设计好完全可以实现更灵活的细粒度权限控制，但目前我还没想到，大家有什么好想法可以共享一下。</p><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>这一块的东西就是仁者见仁智者见智了，如下是我的简单实现设计，给大家个参考：</p><p>人员管理的界面：<br><img src="/upload/2019/1/user2019021614504821.png" alt="image"></p><p>菜单管理的界面：<br><img src="/upload/2019/1/menu_button20190216145048519.png" alt="image"></p><p>人员授权的界面：<br><img src="/upload/2019/1/role_user20190216145048277.png" alt="image"></p><p>角色授权的界面：<br><img src="/upload/2019/1/role_permission20190216145048952.png" alt="image"></p><p>以上全为个人见解，如有错误，希望大家指出。或者有更好的设计或观点也可以分享一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前也做过大概两三次的权限系统了吧，每次开发的时候都需要去根据相应的业务设置具体的权限规则及管理系统。所以产生了这样的想法，能不能设计一个比较通用的权限管理系统，以后如果在遇到需要权限系统可以直接套用。经过查资料、自己整理、开发测试，整理出了一套比较通用的权限管理系统，以做记录，和大家共同探讨学习，看看哪里有不对的、或什么更好的设计方案，一起进步。&lt;/p&gt;
&lt;p&gt;不敢说很通用，任何系统的不存在最完美，只有更完美，所以我也只能说是比较通用，由于本人是做java开发的，所以实现和测试全是通过java语言进行开发的，但本人感觉思想是通用的。以下的设计也是基于网络上现有的比较大路的做法，结合自己以前的开发经验进行的整理和总结，大部分博客网站都比较粗略提点，所以也促使我自己整理一套比较容易阅读的设计方案。&lt;br&gt;
    
    </summary>
    
      <category term="设计" scheme="https://duia.github.io/categories/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="权限系统" scheme="https://duia.github.io/tags/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>spring源码阅读-context</title>
    <link href="https://duia.github.io/2016/11/27/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-context/"/>
    <id>https://duia.github.io/2016/11/27/spring源码阅读-context/</id>
    <published>2016-11-27T03:25:00.000Z</published>
    <updated>2019-05-19T15:00:00.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>入口方法在BeanDefinitionParserDelegate.parseCustomElement：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br></pre></td></tr></table></figure><p>parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parserContext.getReaderContext().fatal(</span><br><span class="line">            <span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>localName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。</p><h1 id="annotation-config"><a href="#annotation-config" class="headerlink" title="annotation-config"></a>annotation-config</h1><p>AnnotationConfigBeanDefinitionParser.parse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回null</span></span><br><span class="line">    Object source = parserContext.extractSource(element);</span><br><span class="line">    <span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">            AnnotationConfigUtils.</span><br><span class="line">                registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line">    <span class="comment">// Register component for the surrounding &lt;context:annotation-config&gt; element.</span></span><br><span class="line">    CompositeComponentDefinition compDefinition = </span><br><span class="line">        <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">    parserContext.pushContainingComponent(compDefinition);</span><br><span class="line">    <span class="comment">// Nest the concrete beans in the surrounding component.</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Finally register the composite component.</span></span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">    parserContext.popAndRegisterContainingComponent();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanPostProcessor注册"><a href="#BeanPostProcessor注册" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h2><p>AnnotationConfigUtils.registerAnnotationConfigProcessors源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数其实就是DefaultListableBeanFactory,第二个参数为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将registery强转为DefaultListableBeanFactory类型</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> </span><br><span class="line">            ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AnnotationAwareOrderComparator"><a href="#AnnotationAwareOrderComparator" class="headerlink" title="AnnotationAwareOrderComparator"></a>AnnotationAwareOrderComparator</h3><p>其继承体系如下:</p><p><img src="http://tu.duia.online/d3cd551dfbc11e93d7b3ef464e4b29ef" alt="Comparator继承体系"></p><p>其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考:</p><p><a href="http://www.tuicool.com/articles/VnqUv2" target="_blank" rel="noopener">Spring 4.2新特性-使用@Order调整配置类加载顺序</a></p><h3 id="ContextAnnotationAutowireCandidateResolver"><a href="#ContextAnnotationAutowireCandidateResolver" class="headerlink" title="ContextAnnotationAutowireCandidateResolver"></a>ContextAnnotationAutowireCandidateResolver</h3><p>此类用以决定一个bean是否可以当作一个依赖的候选者。其类图:</p><p><img src="http://tu.duia.online/9fec1500854a988e570244930dec7b6a" alt="ContextAnnotationAutowireCandidateResolver类图"></p><h3 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>此类用于处理标注了@Configuration注解的类。类图:</p><p><img src="http://tu.duia.online/e5b049a9c5420a98b778b409fa51066a" alt="ConfigurationClassPostProcessor类图"></p><h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>此类便用于对标注了@Autowire等注解的bean或是方法进行注入。</p><p><img src="http://tu.duia.online/7612add63fe6f0307267d9902d31ec0b" alt="AutowiredAnnotationBeanPostProcessor类图"></p><h3 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。</p><h3 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsr250Present =</span><br><span class="line">    ClassUtils.isPresent(<span class="string">"javax.annotation.Resource"</span>, AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure><p>此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图:</p><p><img src="http://tu.duia.online/fa4df4ce90fb570855653c7e8f4bf767" alt="CommonAnnotationBeanPostProcessor类图"></p><h3 id="PersistenceAnnotationBeanPostProcessor"><a href="#PersistenceAnnotationBeanPostProcessor" class="headerlink" title="PersistenceAnnotationBeanPostProcessor"></a>PersistenceAnnotationBeanPostProcessor</h3><p>用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jpaPresent =</span><br><span class="line">    ClassUtils.isPresent(<span class="string">"javax.persistence.EntityManagerFactory"</span>, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader()) &amp;&amp;</span><br><span class="line">    <span class="comment">//org.springframework.orm包</span></span><br><span class="line">    ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure><p>rt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。</p><h3 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系:</p><p><img src="http://tu.duia.online/cd1a542d1c14d51080a35a0da3523f0a" alt="EventListenerMethodProcessor类图"></p><h3 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a>DefaultEventListenerFactory</h3><p>此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图:</p><p><img src="http://tu.duia.online/0c0944f3d37508e5b80b7eca693fec3a" alt="DefaultEventListenerFactory类图"></p><h2 id="逻辑关系整理"><a href="#逻辑关系整理" class="headerlink" title="逻辑关系整理"></a>逻辑关系整理</h2><p>普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图:</p><p><img src="http://tu.duia.online/d04e58203466f1480dbc93f15e64dc14" alt="CompositeComponentDefinition类图"></p><p>最终形成的数据结构如下图:</p><p><img src="http://tu.duia.online/49c83baa78343a17ec6107091c13ed05" alt="数据结构"></p><p>不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="ConfigurationClassPostProcessor-1"><a href="#ConfigurationClassPostProcessor-1" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure><p>注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。</p><h4 id="postProcessBeanDefinitionRegistry"><a href="#postProcessBeanDefinitionRegistry" class="headerlink" title="postProcessBeanDefinitionRegistry"></a>postProcessBeanDefinitionRegistry</h4><p>此方法大体由两部分组成。</p><h5 id="BeanPostProcessor注册-1"><a href="#BeanPostProcessor注册-1" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h5><p>此部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    RootBeanDefinition iabpp = <span class="keyword">new</span> RootBeanDefinition(ImportAwareBeanPostProcessor.class);</span><br><span class="line">    iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);</span><br><span class="line">    RootBeanDefinition ecbpp = <span class="keyword">new</span> RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class);</span><br><span class="line">    ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ImportAwareBeanPostProcessor"><a href="#ImportAwareBeanPostProcessor" class="headerlink" title="ImportAwareBeanPostProcessor"></a>ImportAwareBeanPostProcessor</h6><p>是ConfigurationClassPostProcessor的私有内部类。其类图:</p><p><img src="http://tu.duia.online/0468b8bd2da0743c046df44c8b8a633d" alt="ImportAwareBeanPostProcessor类图"></p><p>此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起:</p><p>有一个类负责生成Student bean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setAge(<span class="number">22</span>);</span><br><span class="line">        student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"importaware"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(StudentConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentConfig studentConfig;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleBean <span class="title">getSimpleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bean依赖</span></span><br><span class="line">        SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean(studentConfig.student());</span><br><span class="line">        <span class="keyword">return</span> simpleBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = </span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(SimpleBeanConfig.class);</span><br><span class="line">    SimpleBean simpleBean = context.getBean(SimpleBean.class);</span><br><span class="line">    System.out.println(simpleBean.getStudent().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以ImportAware接口的作用就是<strong>使被引用的配置类可以获得引用类的相关信息</strong>。</p><h6 id="EnhancedConfigurationBeanPostProcessor"><a href="#EnhancedConfigurationBeanPostProcessor" class="headerlink" title="EnhancedConfigurationBeanPostProcessor"></a>EnhancedConfigurationBeanPostProcessor</h6><p>用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。</p><h5 id="类解析"><a href="#类解析" class="headerlink" title="类解析"></a>类解析</h5><p>这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。</p><h6 id="bean名字生成策略"><a href="#bean名字生成策略" class="headerlink" title="bean名字生成策略"></a>bean名字生成策略</h6><p>对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。</p><p>ConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">SingletonBeanRegistry singletonRegistry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">    singletonRegistry = (SingletonBeanRegistry) registry;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; </span><br><span class="line">        <span class="comment">//org.springframework.context.annotation.internalConfigurationBeanNameGenerator</span></span><br><span class="line">        singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.</span><br><span class="line">            getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">        <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">        <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认是一个AnnotationBeanNameGenerator对象，其类图:</p><p><img src="http://tu.duia.online/30892dbfe202f07e88c0821639febfc9" alt="BeanNameGenerator类图"></p><p>那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: <strong>配置解析、BeanDefinition加载之后，Singleton初始化之前</strong>，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。</p><h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h4><p>此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。简略版的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = </span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line">    <span class="comment">//寻找@Configuration的BeanDefinition</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">        Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">             <span class="comment">//替换</span></span><br><span class="line">            beanDef.setBeanClass(enhancedClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigurationClassEnhancer.newEnhancer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; superclass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(superclass);</span><br><span class="line">    <span class="comment">//这里印证了前面EnhancedConfigurationBeanPostProcessor的说明</span></span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">    enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    <span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CALLBACK_FILTER是个什么东西呢:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConditionalCallbackFilter CALLBACK_FILTER = </span><br><span class="line">    <span class="keyword">new</span> ConditionalCallbackFilter(CALLBACKS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">    <span class="keyword">new</span> BeanMethodInterceptor(),</span><br><span class="line">    <span class="keyword">new</span> BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">    NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这么做的原因有两个:</p><ul><li><p>提供Scope支持:</p><p>我们可以使用@Scope注解来使用注解的方式配置其Scope:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setAge(<span class="number">22</span>);</span><br><span class="line">    student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。</p></li><li><p>实现EnhancedConfiguration接口</p></li></ul><h3 id="AutowiredAnnotationBeanPostProcessor-1"><a href="#AutowiredAnnotationBeanPostProcessor-1" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。</p><h4 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><h5 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h5><p>其中前者首先被调用，时机是当BeanDefinition被合并(和父Bean)，但是还没有用来创建Bean实例时。回顾下其调用入口:</p><p>AbstractAutowireCapableBeanFactory.doCreateBean(简略):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applyMergedBeanDefinitionPostProcessors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, </span></span></span><br><span class="line"><span class="function"><span class="params">    String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String  beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findAutowiringMetadata:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">    <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">            metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                &#125;</span><br><span class="line">                metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">                <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>injectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因:</p><ul><li>假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。</li><li>对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。</li></ul><p>可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。</p><p>@Autowire注解的扫描在buildAutowiringMetadata方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = </span><br><span class="line">        <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line">    <span class="comment">//循环检测父类</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =</span><br><span class="line">                <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, <span class="keyword">new</span> ReflectionUtils.FieldCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//不支持静态变量</span></span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">                <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation should be used on </span></span><br><span class="line"><span class="string">                                methods with parameters: "</span> + method);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，<strong>Spring注入注解可以配置在此bean的父类上</strong>。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。</p><h5 id="变量扫描"><a href="#变量扫描" class="headerlink" title="变量扫描"></a>变量扫描</h5><p>之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。</p><p>ReflectionUtils的实现其实就是访问者模式，其源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithLocalFields</span><span class="params">(Class&lt;?&gt; clazz, FieldCallback fc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Field field : getDeclaredFields(clazz)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.doWith(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>determineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。</p><h5 id="方法扫描"><a href="#方法扫描" class="headerlink" title="方法扫描"></a>方法扫描</h5><h6 id="bridge方法"><a href="#bridge方法" class="headerlink" title="bridge方法"></a>bridge方法</h6><p>就是方法扫描的第一行源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br></pre></td></tr></table></figure><p>此句代码的作用是<strong>判断method是否是bridge方法，如果是，寻找其真正的方法。</strong>这里的bridge方法并不是所谓的bridge模式。</p><p>有这样的demo代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意父类的返回类型是Object</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : MyList.class.getDeclaredMethods()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name: "</span> + method.getName() + <span class="string">", return: "</span> + method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: get, return: class java.lang.String</span><br><span class="line">name: get, return: class java.lang.Object</span><br></pre></td></tr></table></figure><p>通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method; returns &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if and only if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method as defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBridge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getModifiers() &amp; Modifier.BRIDGE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。</p><p>可以参考: <a href="http://ifeve.com/syntethic-and-bridge-methods/" target="_blank" rel="noopener">Java那些不为人知的特殊方法</a></p><p>到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。</p><h6 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h6><p>用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。</p><h4 id="postProcessPropertyValues"><a href="#postProcessPropertyValues" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><h5 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h5><p>AbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。</p><h5 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h5><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInjection</span><span class="params">(Object bean)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = bean.getClass();</span><br><span class="line">     <span class="comment">// 查找缓存</span></span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, <span class="keyword">null</span>);</span><br><span class="line">    metadata.inject(bean, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。</p><h6 id="Field注入"><a href="#Field注入" class="headerlink" title="Field注入"></a>Field注入</h6><p>实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。</p><h6 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h6><p>实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。</p><h3 id="RequiredAnnotationBeanPostProcessor-1"><a href="#RequiredAnnotationBeanPostProcessor-1" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。</p><h4 id="postProcessMergedBeanDefinition-1"><a href="#postProcessMergedBeanDefinition-1" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>空实现，就是这么任性:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="postProcessPropertyValues-1"><a href="#postProcessPropertyValues-1" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.validatedBeanNames.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip(<span class="keyword">this</span>.beanFactory, beanName)) &#123;</span><br><span class="line">            List&lt;String&gt; invalidProperties = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123;</span><br><span class="line">                    invalidProperties.add(pd.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!invalidProperties.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(buildExceptionMessage</span><br><span class="line">                    (invalidProperties, beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.validatedBeanNames.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h5><p>validatedBeanNames是一个Set<string>类型，对于已经检查过的bean，将其name加入Set，防止做无用功。</string></p><h5 id="PropertyDescriptor-1"><a href="#PropertyDescriptor-1" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h5><p>从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢?</p><p>AbstractAutowireCapableBeanFactory.populateBean相关代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filterPropertyDescriptorsForDependencyCheck单参数方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) &#123;</span><br><span class="line">    List&lt;PropertyDescriptor&gt; pds =</span><br><span class="line">            <span class="keyword">new</span> LinkedList&lt;PropertyDescriptor&gt;(Arrays.asList(bw.getPropertyDescriptors()));</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;PropertyDescriptor&gt; it = pds.iterator(); it.hasNext();) &#123;</span><br><span class="line">        PropertyDescriptor pd = it.next();</span><br><span class="line">        <span class="keyword">if</span> (isExcludedFromDependencyCheck(pd)) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pds.toArray(<span class="keyword">new</span> PropertyDescriptor[pds.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢?</p><p>BeanWrapperImpl.getPropertyDescriptors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</span><br><span class="line">    <span class="keyword">return</span> getCachedIntrospectionResults().getPropertyDescriptors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> CachedIntrospectionResults <span class="title">getCachedIntrospectionResults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Assert.state(getWrappedInstance() != <span class="keyword">null</span>, <span class="string">"BeanWrapper does not hold a bean instance"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cachedIntrospectionResults == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cachedIntrospectionResults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这时BeanWrapper便会把自己”内省”一遍。这从侧面说明@Reqired注解只对setter方法有效。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>有一个bean如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"simpleBean"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果:</p><p><img src="http://tu.duia.online/48f64d414119e0795f9c00f04cad26ea" alt="@Required测试"></p><h3 id="CommonAnnotationBeanPostProcessor-1"><a href="#CommonAnnotationBeanPostProcessor-1" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。</p><h4 id="postProcessMergedBeanDefinition-2"><a href="#postProcessMergedBeanDefinition-2" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>此方法的执行入口以及调用时机上面已经说过了。其源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String  beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findResourceMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h5><p>可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String  beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是<strong>遍历所有method寻找初始化和销毁方法标记</strong>。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setInitAnnotationType(PostConstruct.class);</span><br><span class="line">    setDestroyAnnotationType(PreDestroy.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个标签来自于javax.annotation包。那么怎么自定义呢?</p><p>CommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initAnnotationType"</span> <span class="attr">value</span>=<span class="string">"annotation.Init"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Init是一个很简单的自定义注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Init &#123;&#125;</span><br></pre></td></tr></table></figure><p>在自己的bean中使用此注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Init</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Init!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Spring便可以看到效果。</p><p>另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，<strong>Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持</strong>。为了达到只有一个实例的目的，需要为前面的配置加上ID。</p><h5 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h5><p>findResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。</p><h4 id="postProcessPropertyValues-2"><a href="#postProcessPropertyValues-2" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>套路很明显了。</p><h4 id="postProcessBeforeInitialization"><a href="#postProcessBeforeInitialization" class="headerlink" title="postProcessBeforeInitialization"></a>postProcessBeforeInitialization</h4><p>实现在父类InitDestroyAnnotationBeanPostProcessor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">    metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invokeInitMethods:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(Object target, String beanName)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Collection&lt;LifecycleElement&gt; initMethodsToIterate =</span><br><span class="line">            (<span class="keyword">this</span>.checkedInitMethods != <span class="keyword">null</span> ? <span class="keyword">this</span>.checkedInitMethods : <span class="keyword">this</span>.initMethods);</span><br><span class="line">    <span class="keyword">if</span> (!initMethodsToIterate.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleElement element : initMethodsToIterate) &#123;</span><br><span class="line">             <span class="comment">// 反射调用</span></span><br><span class="line">            element.invoke(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过从源码来看应该支持多个init方法。</p><h4 id="postProcessBeforeDestruction"><a href="#postProcessBeforeDestruction" class="headerlink" title="postProcessBeforeDestruction"></a>postProcessBeforeDestruction</h4><p>反射调用销毁方法，没啥说的了。</p><h3 id="EventListenerMethodProcessor-1"><a href="#EventListenerMethodProcessor-1" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>就一个值得关注的方法: afterSingletonsInstantiated。</p><h5 id="入口-2"><a href="#入口-2" class="headerlink" title="入口"></a>入口</h5><p>DefaultListableBeanFactory.preInstantiateSingletons相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = </span><br><span class="line">            (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><p>略过。</p><h1 id="component-scan"><a href="#component-scan" class="headerlink" title="component-scan"></a>component-scan</h1><p>ComponentScanBeanDefinitionParser.parse源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base-package属性</span></span><br><span class="line">    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">    <span class="comment">// 解析占位符</span></span><br><span class="line">    basePackage = parserContext.getReaderContext().getEnvironment()</span><br><span class="line">        .resolvePlaceholders(basePackage);</span><br><span class="line">    <span class="comment">//分割成数据</span></span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    <span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClassPathBeanDefinitionScanner <span class="title">configureScanner</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> useDefaultFilters = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123;</span><br><span class="line">        useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delegate bean definition registration to scanner class.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = createScanner</span><br><span class="line">        (parserContext.getReaderContext(), useDefaultFilters);</span><br><span class="line">    scanner.setResourceLoader(parserContext.getReaderContext().getResourceLoader());</span><br><span class="line">    scanner.setEnvironment(parserContext.getReaderContext().getEnvironment());</span><br><span class="line">    scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());</span><br><span class="line">    scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123;</span><br><span class="line">        scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    parseBeanNameGenerator(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseScope(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseTypeFilters(element, scanner, parserContext);</span><br><span class="line">    <span class="keyword">return</span> scanner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始按顺序分部分说明。</p><h3 id="use-default-filters"><a href="#use-default-filters" class="headerlink" title="use-default-filters"></a>use-default-filters</h3><p>component-scan注解会默认扫描喜闻乐见的@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。</p><h3 id="扫描器-创建-amp-初始化"><a href="#扫描器-创建-amp-初始化" class="headerlink" title="扫描器:创建 &amp; 初始化"></a>扫描器:创建 &amp; 初始化</h3><p>就是createScanner方法和下面那一坨setter方法，没啥好说的。</p><h3 id="resource-pattern"><a href="#resource-pattern" class="headerlink" title="resource-pattern"></a>resource-pattern</h3><p>用以配置扫描器扫描的路径，默认<code>**/*.class</code>。</p><h3 id="name-generator"><a href="#name-generator" class="headerlink" title="name-generator"></a>name-generator</h3><p>可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。</p><h3 id="scope-resolver"><a href="#scope-resolver" class="headerlink" title="scope-resolver"></a>scope-resolver</h3><p>指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图:</p><p><img src="http://tu.duia.online/b0bfa94c5d8e4aca4aa4a2a4dc28fc72" alt="ScopeMetadataResolver类图"></p><p>默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。</p><h3 id="scoped-proxy"><a href="#scoped-proxy" class="headerlink" title="scoped-proxy"></a>scoped-proxy</h3><p>此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。</p><h3 id="exclude-filter-include-filter"><a href="#exclude-filter-include-filter" class="headerlink" title="exclude-filter/include-filter"></a>exclude-filter/include-filter</h3><p>用法示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"base"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"javax.annotation.Resource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>parseTypeFilters方法负责此部分的解析，只贴部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (INCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addIncludeFilter(typeFilter);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (EXCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addExcludeFilter(typeFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="annotation-config-1"><a href="#annotation-config-1" class="headerlink" title="annotation-config"></a>annotation-config</h3><p>此属性等同于&lt;context:annotation-config /&gt;配置，默认就是true，也就是说，如果配置了context:component-scan其实就没有必要配置annotation-config 了。</p><h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>入口方法便是ClassPathBeanDefinitionScanner.doScan:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">         <span class="comment">// 逐包扫描</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                 <span class="comment">// 为BeanDefinition设置默认的属性</span></span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations</span><br><span class="line">                    ((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode</span><br><span class="line">                    (scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逐包扫描-BeanDefinition解析"><a href="#逐包扫描-BeanDefinition解析" class="headerlink" title="逐包扫描/BeanDefinition解析"></a>逐包扫描/BeanDefinition解析</h3><p>扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图:</p><p><img src="http://tu.duia.online/82b40a73e614cba7ebe65397d8c56963" alt="MetadataReader类图"></p><p>对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SimpleMetadataReader(Resource resource, ClassLoader classLoader) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> BufferedInputStream(resource.getInputStream());</span><br><span class="line">    ClassReader classReader;</span><br><span class="line">    classReader = <span class="keyword">new</span> ClassReader(is);</span><br><span class="line"></span><br><span class="line">    AnnotationMetadataReadingVisitor visitor = <span class="keyword">new</span> AnnotationMetadataReadingVisitor(classLoader);</span><br><span class="line">    classReader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.annotationMetadata = visitor;</span><br><span class="line">    <span class="comment">// (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)</span></span><br><span class="line">    <span class="keyword">this</span>.classMetadata = visitor;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析的关键便在于AnnotationMetadataReadingVisitor，其类图:</p><p><img src="http://tu.duia.online/c454f6c01aeffa715882fb41a4878fc7" alt="AnnotationMetadataReadingVisitor类图"></p><p>核心在于其visitAnnotation方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(<span class="keyword">final</span> String desc, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">    String className = Type.getType(desc).getClassName();</span><br><span class="line">    <span class="keyword">this</span>.annotationSet.add(className);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnnotationAttributesReadingVisitor(</span><br><span class="line">        className, <span class="keyword">this</span>.attributesMap, <span class="keyword">this</span>.metaAnnotationMap, <span class="keyword">this</span>.classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图:</p><p><img src="http://tu.duia.online/8ce3498b680dd491f461567ca7258ed7" alt="ScannedGenericBeanDefinition类图"></p><h3 id="Scope解析"><a href="#Scope解析" class="headerlink" title="@Scope解析"></a>@Scope解析</h3><p>AnnotationScopeMetadataResolver.resolveScopeMetadata:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScopeMetadata <span class="title">resolveScopeMetadata</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    ScopeMetadata metadata = <span class="keyword">new</span> ScopeMetadata();</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line">         <span class="comment">// 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">                annDef.getMetadata(), <span class="keyword">this</span>.scopeAnnotationType);</span><br><span class="line">        <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// @Scope值</span></span><br><span class="line">            metadata.setScopeName(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">            ScopedProxyMode proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line">            <span class="keyword">if</span> (proxyMode == <span class="keyword">null</span> || proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">                proxyMode = <span class="keyword">this</span>.defaultProxyMode;</span><br><span class="line">            &#125;</span><br><span class="line">            metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxyMode和xml的scoped-proxy属性是一个概念:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = <span class="string">"singleton"</span>, proxyMode = ScopedProxyMode.DEFAULT)</span><br></pre></td></tr></table></figure><p><strong>XML的属性是全局的配置，这个是局部(针对单个bean)的配置</strong>，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。</p><h3 id="bean名字生成"><a href="#bean名字生成" class="headerlink" title="bean名字生成"></a>bean名字生成</h3><p>AnnotationBeanNameGenerator.generateBeanName:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Explicit bean name found.</span></span><br><span class="line">            <span class="keyword">return</span> beanName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line">    <span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据注解"><a href="#根据注解" class="headerlink" title="根据注解"></a>根据注解</h4><p>默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">    AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">    Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">    String beanName = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 遍历当前bean拥有的所有类级注解</span></span><br><span class="line">    <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">         <span class="comment">// 获取此注解所有的属性</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line">        <span class="keyword">if</span> (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) &#123;</span><br><span class="line">            Object value = attributes.get(<span class="string">"value"</span>);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String strVal = (String) value;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    beanName = strVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isStereotypeWithNameValue</span><span class="params">(String annotationType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Set&lt;String&gt; metaAnnotationTypes, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// org.springframework.stereotype.Component</span></span><br><span class="line">    <span class="keyword">boolean</span> isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">        (metaAnnotationTypes != <span class="keyword">null</span> &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) ||</span><br><span class="line">        annotationType.equals(<span class="string">"javax.annotation.ManagedBean"</span>) ||</span><br><span class="line">        annotationType.equals(<span class="string">"javax.inject.Named"</span>);</span><br><span class="line">    <span class="keyword">return</span> (isStereotype &amp;&amp; attributes != <span class="keyword">null</span> &amp;&amp; attributes.containsKey(<span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>metaAnnotationTypes用以判断元注解，针对这种情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。</p><h4 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h4><p>如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base.SimpleBean -&gt; SimpleBean</span></span><br><span class="line">    String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class="line">    <span class="comment">//SimpleBean -&gt; simpleBean</span></span><br><span class="line">    <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，对于内部类: OuterClassName.InnerClassName -&gt; outerClassName.InnerClassName.</p><h3 id="其它注解解析"><a href="#其它注解解析" class="headerlink" title="其它注解解析"></a>其它注解解析</h3><p>入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"student"</span>)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_APPLICATION)</span><br><span class="line"><span class="meta">@Description</span>(<span class="string">"This is a simple bean."</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个”hint”，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。</p><h3 id="冲突检测"><a href="#冲突检测" class="headerlink" title="冲突检测"></a>冲突检测</h3><p>Spring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkCandidate</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有同名的，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanDefinition existingDef = <span class="keyword">this</span>.registry.getBeanDefinition(beanName);</span><br><span class="line">    BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();</span><br><span class="line">    <span class="keyword">if</span> (originatingDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        existingDef = originatingDef;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isCompatible(beanDefinition, existingDef)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConflictingBeanDefinitionException(<span class="string">"冲突啦!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isCompatible用于判断和之前的BeanDefinition是否兼容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCompatible</span><span class="params">(BeanDefinition newDefinition, BeanDefinition existingDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//// explicitly registered overriding bean</span></span><br><span class="line">    <span class="keyword">return</span> (!(existingDefinition <span class="keyword">instanceof</span> ScannedGenericBeanDefinition) || </span><br><span class="line">            <span class="comment">//// scanned same file twice</span></span><br><span class="line">            newDefinition.getSource().equals(existingDefinition.getSource()) || </span><br><span class="line">            <span class="comment">// scanned equivalent class twice</span></span><br><span class="line">            newDefinition.equals(existingDefinition));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<strong>如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的。</strong></p><h3 id="代理生成"><a href="#代理生成" class="headerlink" title="代理生成"></a>代理生成</h3><p>入口: ClassPathBeanDefinitionScanner.doScan:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure><p>AnnotationConfigUtils.applyScopedProxyMode:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BeanDefinitionHolder <span class="title">applyScopedProxyMode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line">    <span class="comment">// 基本都是从这里跑了</span></span><br><span class="line">    <span class="keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">    <span class="keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点:</p><ul><li>这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。</li><li>被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。</li><li>将被代理者以scopedTarget.原名字注册到容器，返回代理者。</li><li>代理者和被代理者同时存在于容器中。</li></ul><p>可以看出，这其实是一个偷天换日的过程。</p><p>做个实验:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boostrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">        SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">         System.out.println(bean.getClass().getName());</span><br><span class="line">         context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleBean已开启代理，输出的结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base.SimpleBean$$EnhancerBySpringCGLIB$$27256c61</span><br></pre></td></tr></table></figure><p>那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢?</p><p>DefaultListableBeanFactory.getBean(Class<t> requiredType, Object… args)部分源码:</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] beanNames = getBeanNamesForType(requiredType);</span><br><span class="line"><span class="comment">//不止一个满足条件(代理者和被代理者)</span></span><br><span class="line"><span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">         <span class="comment">// here</span></span><br><span class="line">        <span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">            autowireCandidates.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (autowireCandidates.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        beanNames = autowireCandidates.toArray(<span class="keyword">new</span> String[autowireCandidates.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。</p><h3 id="BeanDefinition注册"><a href="#BeanDefinition注册" class="headerlink" title="BeanDefinition注册"></a>BeanDefinition注册</h3><p>你懂的。</p><h2 id="Component注册"><a href="#Component注册" class="headerlink" title="Component注册"></a>Component注册</h2><p>套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。</p><h1 id="property-override"><a href="#property-override" class="headerlink" title="property-override"></a>property-override</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo:</p><p>定义如下的属性文件(property.properties):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.name=dog</span><br></pre></td></tr></table></figure><p>格式为: bean名字.属性名字=值。由如下的bean:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进行如下的配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"property.properties"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>运行如下的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">    SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">    System.out.println(bean.getStudent().getName());</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的便是dog，而不是skywalker。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下:</p><p><img src="http://tu.duia.online/b3a522d200541134265ac2ab1254cded" alt="PropertyOverrideBeanDefinitionParser类图"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码: </p><p>AbstractPropertyLoadingBeanDefinitionParser.doParse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    String location = element.getAttribute(<span class="string">"location"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(location)) &#123;</span><br><span class="line">        String[] locations = StringUtils.commaDelimitedListToStringArray(location);</span><br><span class="line">        builder.addPropertyValue(<span class="string">"locations"</span>, locations);</span><br><span class="line">    &#125;</span><br><span class="line">    String propertiesRef = element.getAttribute(<span class="string">"properties-ref"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(propertiesRef)) &#123;</span><br><span class="line">        builder.addPropertyReference(<span class="string">"properties"</span>, propertiesRef);</span><br><span class="line">    &#125;</span><br><span class="line">    String fileEncoding = element.getAttribute(<span class="string">"file-encoding"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(fileEncoding)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"fileEncoding"</span>, fileEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">    String order = element.getAttribute(<span class="string">"order"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(order)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"order"</span>, Integer.valueOf(order));</span><br><span class="line">    &#125;</span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreResourceNotFound"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-resource-not-found"</span>)));</span><br><span class="line">    builder.addPropertyValue(<span class="string">"localOverride"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"local-override"</span>)));</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="properties-ref"><a href="#properties-ref" class="headerlink" title="properties-ref"></a>properties-ref</h3><p>此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span>  <span class="attr">properties-ref</span>=<span class="string">"property"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"property"</span> <span class="attr">class</span>=<span class="string">"java.util.Properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"student.name"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样便可以看到结果。</p><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。</p><h3 id="ignore-resource-not-found"><a href="#ignore-resource-not-found" class="headerlink" title="ignore-resource-not-found"></a>ignore-resource-not-found</h3><p>如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。</p><h3 id="ignore-unresolvable"><a href="#ignore-unresolvable" class="headerlink" title="ignore-unresolvable"></a>ignore-unresolvable</h3><p>如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。</p><h3 id="local-override"><a href="#local-override" class="headerlink" title="local-override"></a>local-override</h3><p>这个属性让我很迷惑。Spring说是此选项决定”local”的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Properties[] localProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set local properties, e.g. via the "props" tag in XML bean definitions.</span></span><br><span class="line"><span class="comment"> * These can be considered defaults, to be overridden by properties</span></span><br><span class="line"><span class="comment"> * loaded from files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localProperties = <span class="keyword">new</span> Properties[] &#123;properties&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这应该就是Spring所说的”local”属性。好，我们来注入一下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span>  <span class="attr">location</span>=<span class="string">"property.properties"</span> <span class="attr">local-override</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"student.name"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向”local”注入?(context:property-override不允许子标签存在)</p><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图:</p><p><img src="http://tu.duia.online/62625252e36e91a60de225abd66db8da" alt="PropertyOverrideConfigurer类图"></p><h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><p>入口当然是BeanFactoryPostProcessor.postProcessBeanFactory(PropertyResourceConfigurer):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 属性加载</span></span><br><span class="line">        Properties mergedProps = mergeProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert the merged properties, if necessary.</span></span><br><span class="line">        convertProperties(mergedProps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let the subclass process the properties.</span></span><br><span class="line">        processProperties(beanFactory, mergedProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性加载"><a href="#属性加载" class="headerlink" title="属性加载"></a>属性加载</h3><p>PropertiesLoaderSupport.mergeProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Properties <span class="title">mergeProperties</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties result = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">        <span class="comment">// Load properties from file upfront, to let local properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Properties localProp : <span class="keyword">this</span>.localProperties) &#123;</span><br><span class="line">            CollectionUtils.mergePropertiesIntoMap(localProp, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">        <span class="comment">// Load properties from file afterwards, to let those properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。</p><h3 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h3><p>convertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。</p><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory factory, String beanName, String property, String value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinition bd = factory.getBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">while</span> (bd.getOriginatingBeanDefinition() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bd = bd.getOriginatingBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    PropertyValue pv = <span class="keyword">new</span> PropertyValue(property, value);</span><br><span class="line">    pv.setOptional(<span class="keyword">this</span>.ignoreInvalidKeys);</span><br><span class="line">    bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。</p><h1 id="property-placeholder"><a href="#property-placeholder" class="headerlink" title="property-placeholder"></a>property-placeholder</h1><p>这个怎么用已经喜闻乐见了</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。</p><p>PropertyPlaceholderBeanDefinitionParser.doParse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.doParse(element, builder);</span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreUnresolvablePlaceholders"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-unresolvable"</span>)));</span><br><span class="line">    String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp;</span><br><span class="line">            !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"systemPropertiesModeName"</span>, <span class="string">"SYSTEM_PROPERTIES_MODE_"</span></span><br><span class="line">            + systemPropertiesModeName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"value-separator"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"valueSeparator"</span>, element.getAttribute(<span class="string">"value-separator"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"trim-values"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"trimValues"</span>, element.getAttribute(<span class="string">"trim-values"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"null-value"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"nullValue"</span>, element.getAttribute(<span class="string">"null-value"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="system-properties-mode"><a href="#system-properties-mode" class="headerlink" title="system-properties-mode"></a>system-properties-mode</h3><p>Spring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。</p><h3 id="value-separator"><a href="#value-separator" class="headerlink" title="value-separator"></a>value-separator</h3><p>用于配置默认的值的分隔符:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"$&#123;student.name:skywalker&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果属性文件里没有student.name，那么就是skywalker。默认就是:。</p><h3 id="null-value"><a href="#null-value" class="headerlink" title="null-value"></a>null-value</h3><p>遇到哪些值应该当做空处理，比如可以把空串””设为这个，默认不对任何值进行处理。</p><h3 id="trim-values"><a href="#trim-values" class="headerlink" title="trim-values"></a>trim-values</h3><p>是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。</p><h3 id="BeanDefinition-1"><a href="#BeanDefinition-1" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>这次是PropertySourcesPlaceholderConfigurer，其类图:</p><p><img src="http://tu.duia.online/374e1898d10ab7dfb7cab85d7785c85e" alt="PropertySourcesPlaceholderConfigurer类图"></p><h2 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h2><p>PropertySourcesPlaceholderConfigurer.postProcessBeanFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.propertySources = <span class="keyword">new</span> MutablePropertySources();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addLast(</span><br><span class="line">                <span class="keyword">new</span> PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, </span><br><span class="line">                    <span class="keyword">this</span>.environment) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.source.getProperty(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        PropertySource&lt;?&gt; localPropertySource =</span><br><span class="line">                <span class="keyword">new</span> PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addFirst(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addLast(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processProperties(beanFactory, <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources));</span><br><span class="line">    <span class="keyword">this</span>.appliedPropertySources = <span class="keyword">this</span>.propertySources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样:</p><p>不使用property-placeholder标签，以显式的bean定义代替。</p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。</p><h1 id="load-time-weaver-amp-spring-configured"><a href="#load-time-weaver-amp-spring-configured" class="headerlink" title="load-time-weaver &amp; spring-configured"></a>load-time-weaver &amp; spring-configured</h1><p>这两个配置是紧密相关的，所以在一起说了。</p><p>load-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。</p><p>可以参考:</p><p><a href="http://sexycoding.iteye.com/blog/1062372" target="_blank" rel="noopener">Spring之LoadTimeWeaver——一个需求引发的思考</a></p><p><a href="http://www.iteye.com/topic/481813" target="_blank" rel="noopener">Spring LoadTimeWeaver 的那些事儿</a></p><h2 id="javaagent"><a href="#javaagent" class="headerlink" title="javaagent"></a>javaagent</h2><p>要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例:</p><p>-javaagent:D:\Software\maven-repos\org\springframework\spring-agent\2.5.6.SEC03\spring-agent-2.5.6.SEC03.jar</p><p>此jar包的META-INF/MANIFEST.MF文件需要配置如下一行:</p><p>Premain-Class: org.springframework.instrument.InstrumentationSavingAge<br> nt</p><p>Spring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationSavingAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instrumentation instrumentation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        instrumentation = inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instrumentation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。</p><h3 id="LoadTimeWeaver"><a href="#LoadTimeWeaver" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h3><p>此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系:</p><p><img src="http://tu.duia.online/0726e81aba163c9b3a8ef1edec699646" alt="LoadTimeWeaver继承体系"></p><p>LoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getBeanClassName</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果配置了weaver-class属性，那么使用其值</span></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.getAttribute(WEAVER_CLASS_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// org.springframework.context.weaving.DefaultContextLoadTimeWeaver</span></span><br><span class="line">    <span class="keyword">return</span> DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个BeanDefinition的id/name又是什么呢?</p><p>LoadTimeWeaverBeanDefinitionParser.resolveId:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolveId</span><span class="params">(Element element, AbstractBeanDefinition definition, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// loadTimeWeaver</span></span><br><span class="line">    <span class="keyword">return</span> ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。</p><h3 id="LoadTimeWeaverBeanDefinitionParser"><a href="#LoadTimeWeaverBeanDefinitionParser" class="headerlink" title="LoadTimeWeaverBeanDefinitionParser"></a>LoadTimeWeaverBeanDefinitionParser</h3><p>LoadTimeWeaverBeanDefinitionParser.doParse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="keyword">if</span> (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) &#123;</span><br><span class="line">            RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);</span><br><span class="line">            parserContext.registerBeanComponent(</span><br><span class="line">                    <span class="keyword">new</span> BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser().parse(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aspectj-weaving"><a href="#aspectj-weaving" class="headerlink" title="aspectj-weaving"></a>aspectj-weaving</h3><p>这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。</p><p>此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。</p><h3 id="是否开启"><a href="#是否开启" class="headerlink" title="是否开启"></a>是否开启</h3><p>isAspectJWeavingEnabled方法用于判断是否启用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAspectJWeavingEnabled</span><span class="params">(String value, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"on"</span>.equals(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"off"</span>.equals(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找aop.xml</span></span><br><span class="line">        ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AspectJWeavingEnabler"><a href="#AspectJWeavingEnabler" class="headerlink" title="AspectJWeavingEnabler"></a>AspectJWeavingEnabler</h3><p>从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图:</p><p><img src="http://tu.duia.online/ec7d1a908f913e4a515d7d0f8dcd6a6e" alt="AspectJWeavingEnabler类图"></p><h3 id="SpringConfiguredBeanDefinitionParser"><a href="#SpringConfiguredBeanDefinitionParser" class="headerlink" title="SpringConfiguredBeanDefinitionParser"></a>SpringConfiguredBeanDefinitionParser</h3><p>如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br></pre></td></tr></table></figure><p>其parse方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// org.springframework.context.config.internalBeanConfigurerAspect</span></span><br><span class="line">    <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">         <span class="comment">// org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect</span></span><br><span class="line">        def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);</span><br><span class="line">        def.setFactoryMethodName(<span class="string">"aspectOf"</span>);</span><br><span class="line">        def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        def.setSource(parserContext.extractSource(element));</span><br><span class="line">        parserContext.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition</span><br><span class="line">            (def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图:</p><p><img src="http://tu.duia.online/e5f1c7643e36acaf6542da73ab606c32" alt="AnnotationBeanConfigurerAspect类图"></p><p>AnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。</p><p>下面就去aj文件中看看到底定义了哪些pointcut以及advise。</p><p>语法可以参考:</p><p><a href="http://jinnianshilongnian.iteye.com/blog/1415606" target="_blank" rel="noopener">Spring 之AOP AspectJ切入点详解</a></p><h4 id="切点-pointcut"><a href="#切点-pointcut" class="headerlink" title="切点(pointcut)"></a>切点(pointcut)</h4><h5 id="inConfigurableBean"><a href="#inConfigurableBean" class="headerlink" title="inConfigurableBean"></a>inConfigurableBean</h5><p>在AnnotationBeanConfigurerAspect中定义，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">inConfigurableBean</span><span class="params">()</span> : @<span class="title">this</span><span class="params">(Configurable)</span></span>;</span><br></pre></td></tr></table></figure><p>@this没找到相关说明，结合@以及this的语义，猜测是匹配<strong>带有@Configurable注解(以及作为元注解)的类</strong>。</p><h5 id="beanConstruction"><a href="#beanConstruction" class="headerlink" title="beanConstruction"></a>beanConstruction</h5><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">beanConstruction</span><span class="params">(Object bean)</span> :</span></span><br><span class="line"><span class="function">            <span class="title">initialization</span><span class="params">(ConfigurableObject+.new(..)</span>) &amp;&amp; <span class="title">this</span><span class="params">(bean)</span></span>;</span><br></pre></td></tr></table></figure><p>initialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。</p><h5 id="preConstructionCondition"><a href="#preConstructionCondition" class="headerlink" title="preConstructionCondition"></a>preConstructionCondition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> &amp;&amp; <span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>由两个pointcut与运算而来。</p><h5 id="leastSpecificSuperTypeConstruction"><a href="#leastSpecificSuperTypeConstruction" class="headerlink" title="leastSpecificSuperTypeConstruction"></a>leastSpecificSuperTypeConstruction</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> : <span class="title">initialization</span><span class="params">(ConfigurableObject.new(..)</span>)</span>;</span><br></pre></td></tr></table></figure><h5 id="preConstructionConfiguration"><a href="#preConstructionConfiguration" class="headerlink" title="preConstructionConfiguration"></a>preConstructionConfiguration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">preConstructionConfiguration</span><span class="params">()</span> : <span class="title">preConstructionConfigurationSupport</span><span class="params">(*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionConfigurationSupport</span><span class="params">(Configurable c)</span> : @<span class="title">this</span><span class="params">(c)</span> &amp;&amp; <span class="title">if</span> <span class="params">(c.preConstruction()</span>)</span>;</span><br></pre></td></tr></table></figure><p>preConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。</p><h5 id="postConstructionCondition"><a href="#postConstructionCondition" class="headerlink" title="postConstructionCondition"></a>postConstructionCondition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">postConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> &amp;&amp; !<span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>mostSpecificSubTypeConstruction:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(thisJoinPoint.getSignature()</span>.<span class="title">getDeclaringType</span><span class="params">()</span> </span>== thisJoinPoint.getThis().getClass());</span><br></pre></td></tr></table></figure><p>advise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。</p><h4 id="advise"><a href="#advise" class="headerlink" title="advise"></a>advise</h4><h5 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before(Object bean) :</span><br><span class="line">    beanConstruction(bean) &amp;&amp; preConstructionCondition() &amp;&amp; inConfigurableBean()  &#123;</span><br><span class="line">    configureBean(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行-3"><a href="#运行-3" class="headerlink" title="运行"></a>运行</h2><p>AspectJWeavingEnabler.postProcessBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    enableAspectJWeaving(<span class="keyword">this</span>.loadTimeWeaver, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enableAspectJWeaving:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enableAspectJWeaving</span><span class="params">(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (weaverToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">            weaverToUse = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(beanClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No LoadTimeWeaver available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    weaverToUse.addTransformer(</span><br><span class="line">            <span class="keyword">new</span> AspectJClassBypassingClassFileTransformer(<span class="keyword">new</span> ClassPreProcessorAgentAdapter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h3><p>AspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢?</p><p>当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadTimeWeaver</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，关键在于LoadTimeWeaverAwareProcessor，类图:</p><p><img src="http://tu.duia.online/cdcad948d03952c35e63e11b6e17bc25" alt="LoadTimeWeaverAwareProcessor类图"></p><p>postProcessBeforeInitialization方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> LoadTimeWeaverAware) &#123;</span><br><span class="line">        LoadTimeWeaver ltw = <span class="keyword">this</span>.loadTimeWeaver;</span><br><span class="line">        <span class="keyword">if</span> (ltw == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>,</span><br><span class="line">                <span class="string">"BeanFactory required if no LoadTimeWeaver explicitly specified"</span>);</span><br><span class="line">             <span class="comment">// 去容器找 </span></span><br><span class="line">            ltw = <span class="keyword">this</span>.beanFactory.getBean(</span><br><span class="line">                ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);</span><br><span class="line">        &#125;</span><br><span class="line">        ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。</p><p>BeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点:</p><p>BeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的:</p><p>AbstractApplicationContext.refresh:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure><p>那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的?</p><p>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBeanPostProcessors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BeanPostProcessor&gt; <span class="title">getBeanPostProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanPostProcessors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br></pre></td></tr></table></figure><p>直接将实例添加到BeanFactory中，所以可以得出结论:</p><p><strong>我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加</strong>。</p><h3 id="BeanClassLoaderAware"><a href="#BeanClassLoaderAware" class="headerlink" title="BeanClassLoaderAware"></a>BeanClassLoaderAware</h3><h4 id="入口-3"><a href="#入口-3" class="headerlink" title="入口"></a>入口</h4><p>DefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢?</p><p>AbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setBeanClassLoader"><a href="#setBeanClassLoader" class="headerlink" title="setBeanClassLoader"></a>setBeanClassLoader</h4><p>这个方法很关键，对instrument的获取就是在这里。源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (serverSpecificLoadTimeWeaver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = serverSpecificLoadTimeWeaver;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> ReflectiveLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显分为三部分。</p><h5 id="服务器agent"><a href="#服务器agent" class="headerlink" title="服务器agent"></a>服务器agent</h5><p>Spring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>createServerSpecificLoadTimeWeaver源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> LoadTimeWeaver <span class="title">createServerSpecificLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String name = classLoader.getClass().getName();</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"weblogic"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebLogicLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.glassfish"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GlassFishLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.apache.catalina"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TomcatLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.jboss"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JBossLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"com.ibm"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebSphereLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<strong>对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现</strong>。</p><p>这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。</p><h5 id="Spring-agent"><a href="#Spring-agent" class="headerlink" title="Spring agent"></a>Spring agent</h5><p>这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInstrumentationAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getInstrumentation() != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AGENT_CLASS_PRESENT) &#123;</span><br><span class="line">        <span class="keyword">return</span> InstrumentationAccessor.getInstrumentation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。</p><p>InstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationAccessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstrumentationSavingAgent.getInstrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。</p><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW…)，检测的源码位于ReflectiveLoadTimeWeaver的构造器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(classLoader, <span class="string">"ClassLoader must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    <span class="keyword">this</span>.addTransformerMethod = ClassUtils.getMethodIfAvailable(</span><br><span class="line">            <span class="keyword">this</span>.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addTransformerMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档:</p><p><a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html#enabling-load-time-weaving" target="_blank" rel="noopener">Chapter 5. Load-Time Weaving</a></p><h3 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h3><p>从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。</p><p>AspectJClassBypassingClassFileTransformer.transform:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">    <span class="comment">// aspectj自身的类无需检测(织入)，直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (className.startsWith(<span class="string">"org.aspectj"</span>) || className.startsWith(<span class="string">"org/aspectj"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.transform(loader, className, classBeingRedefined, </span><br><span class="line">        protectionDomain, classfileBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图:</p><p><img src="http://tu.duia.online/8d15860c9c2c11667b615ebe5e94ba36" alt="ClassPreProcessorAgentAdapter类图"></p><p>根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4.</p><h3 id="Aj"><a href="#Aj" class="headerlink" title="Aj"></a>Aj</h3><p>Aj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Aj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。</p><h4 id="WeavingAdaptor初始化"><a href="#WeavingAdaptor初始化" class="headerlink" title="WeavingAdaptor初始化"></a>WeavingAdaptor初始化</h4><p>初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。</p><h5 id="aop-xml"><a href="#aop-xml" class="headerlink" title="aop.xml"></a>aop.xml</h5><h6 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h6><p>aop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的:</p><p>以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.AnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.AnnotationCacheAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.JCacheCacheAspect"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么解析后的结果:</p><p><img src="http://tu.duia.online/dfecbf68cdc94e14e8b13201b85bfde0" alt="aop.xml解析结果"></p><h6 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h6><p>入口方法在ClassLoaderWeavingAdaptor.registerDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">registerDefinitions</span><span class="params">(<span class="keyword">final</span> BcelWeaver weaver, <span class="keyword">final</span> ClassLoader loader, List&lt;Definition&gt; definitions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对应&lt;weaver options="-verbose"&gt;</span></span><br><span class="line">    registerOptions(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;exclude&gt;标签</span></span><br><span class="line">    registerAspectExclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;include&gt;标签</span></span><br><span class="line">    registerAspectInclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">// &lt;aspect&gt;</span></span><br><span class="line">    success = registerAspects(weaver, loader, definitions);</span><br><span class="line">    registerIncludeExclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;dump&gt;标签</span></span><br><span class="line">    registerDump(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//忽略返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Spring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;入口方法在BeanDefinitionParserDelegate.parseCustomElement：&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
      <category term="spring" scheme="https://duia.github.io/categories/spring/"/>
    
      <category term="源码阅读" scheme="https://duia.github.io/categories/spring/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="源码阅读" scheme="https://duia.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="spring" scheme="https://duia.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之建造者模式</title>
    <link href="https://duia.github.io/2016/11/26/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://duia.github.io/2016/11/26/Java设计模式之建造者模式/</id>
    <published>2016-11-26T03:44:00.000Z</published>
    <updated>2019-05-11T15:00:00.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/2019/1/75OZ01__3_S0QJLWTH9N4QR20190216150423993.png" alt="image"></p><a id="more"></a><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>将复杂对象的构造与其表示分开，以便相同的构造过程可以创建不同的表示。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>真实世界的例子</p><blockquote><p>设想一个角色扮演类游戏的角色生成器。电脑为你创造角色时，你可以逐步选择你想选择的角色的职业、性别、发色等细节，角色的生成就成了一个循序渐进的过程，当所有的选择都准备好的时候就完成了。</p></blockquote><p>用简单的话来说</p><blockquote><p>允许您创建不同的对象风格，同时避免构造器的污染；当可能有几种风格的对象时很有用；或者当创建对象时涉及很多步骤。</p></blockquote><p>大概就是这个意思，具体还需要看代码帮助理解意思：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Hero(Profession profession, String name, HairType hairType, HairColor hairColor, Armor armor, Weapon weapon) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所看到的，构造函数参数的数量可能会很快失去控制，并且可能很难理解参数的排列方式。还有如果你想在将来添加更多的选项，参数可以继续增长。这被称为可伸缩构造器的反模式。</p><p><strong>编程示例</strong></p><p>理智的选择是使用Builder模式。首先我们有我们想要创造的<code>Hero.java</code>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class Hero &#123;</span><br><span class="line">  private final Profession profession;</span><br><span class="line">  private final String name;</span><br><span class="line">  private final HairType hairType;</span><br><span class="line">  private final HairColor hairColor;</span><br><span class="line">  private final Armor armor;</span><br><span class="line">  private final Weapon weapon;</span><br><span class="line"></span><br><span class="line">  private Hero(Builder builder) &#123;</span><br><span class="line">    this.profession = builder.profession;</span><br><span class="line">    this.name = builder.name;</span><br><span class="line">    this.hairColor = builder.hairColor;</span><br><span class="line">    this.hairType = builder.hairType;</span><br><span class="line">    this.weapon = builder.weapon;</span><br><span class="line">    this.armor = builder.armor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static class Builder &#123;</span><br><span class="line">    private final Profession profession;</span><br><span class="line">    private final String name;</span><br><span class="line">    private HairType hairType;</span><br><span class="line">    private HairColor hairColor;</span><br><span class="line">    private Armor armor;</span><br><span class="line">    private Weapon weapon;</span><br><span class="line"></span><br><span class="line">    public Builder(Profession profession, String name) &#123;</span><br><span class="line">      this.profession = profession;</span><br><span class="line">      this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder withHairType(HairType hairType) &#123;</span><br><span class="line">      this.hairType = hairType;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder withHairColor(HairColor hairColor) &#123;</span><br><span class="line">      this.hairColor = hairColor;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder withArmor(Armor armor) &#123;</span><br><span class="line">      this.armor = armor;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder withWeapon(Weapon weapon) &#123;</span><br><span class="line">      this.weapon = weapon;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Hero build() &#123;</span><br><span class="line">      return new Hero(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hero mage = new Hero.Builder(Profession.MAGE, &quot;Riobard&quot;)</span><br><span class="line">    .withHairColor(HairColor.BLACK)</span><br><span class="line">    .withWeapon(Weapon.DAGGER)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>这样理解建造者模式比较容易理解，下边列出一般样例代码。</p><h2 id="标准代码实现"><a href="#标准代码实现" class="headerlink" title="标准代码实现"></a>标准代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 所要建造的产品类</span><br><span class="line"> */</span><br><span class="line">class Product &#123;</span><br><span class="line"></span><br><span class="line">    private String paths;</span><br><span class="line">    </span><br><span class="line">    public String getPaths() &#123;</span><br><span class="line">    return paths;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPaths(String paths) &#123;</span><br><span class="line">    this.paths = paths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 抽象建造者，</span><br><span class="line"> * 1、规定了建造的产品（如果有多个产品，可以适当添加抽象产品）</span><br><span class="line"> * 2、规定了建造每个产品所分步骤，不需要具体的实现过程，实现过程由具体的建造者进行实现</span><br><span class="line"> * 3、规定了建造每个产品时的步骤顺序（此步可以在导演类中进行），并建造完后返回对象</span><br><span class="line"> * 每要新建一个类似的产品种类时，均可继承该类，并实现具体的每个步骤即可，无需改动原有的类，实现了代码的可扩展性</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">abstract class Builder &#123;</span><br><span class="line"></span><br><span class="line">    protected abstract void buildPaths();</span><br><span class="line">    </span><br><span class="line">    public abstract Product build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 具体的建造者实现，针对同种产品可以有不通的建造的实现，也可以针对不同的产品分别实现不同的建造者。</span><br><span class="line"> */</span><br><span class="line">class ConcreteBuilder extends Builder &#123;</span><br><span class="line"></span><br><span class="line">    private Product product = new Product();</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void buildPaths() &#123;</span><br><span class="line">        product.setPaths(&quot;设置产品属性&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Product build() &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 导演类，预先持有产品的建造者，为需要不同于默认产品的用户提供不同的组装方式</span><br><span class="line"> * 对建造者的管理,并管理建造步骤</span><br><span class="line"> */</span><br><span class="line">class Director &#123;</span><br><span class="line"></span><br><span class="line">    private Builder builder;</span><br><span class="line">    </span><br><span class="line">    public Director(Builder builder)&#123;</span><br><span class="line">        this.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Product construct()&#123;</span><br><span class="line">        builder.buildPaths();</span><br><span class="line">        return builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">        Builder builder = new ConcreteBuilder();</span><br><span class="line">    </span><br><span class="line">        Director director = new Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上两种建造者模式的实现只是不同的写法，还可以有别的实现方式，我们可以在实际开发中根据具体业务进行选择，添加抽象产品类或者省略抽象建造者等等。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>使用Builder模式时</p><ul><li>创建复杂对象的算法应该独立于组成对象的部分以及它们如何组装</li><li>施工过程必须允许对构建的对象进行不同的表示</li></ul><h2 id="真实世界的例子"><a href="#真实世界的例子" class="headerlink" title="真实世界的例子"></a>真实世界的例子</h2><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener">java.lang.StringBuilder</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener">java.nio.ByteBuffer</a> as well as similar buffers such as FloatBuffer, IntBuffer and so on.</li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="noopener">java.lang.StringBuffer</a></li><li>All implementations of <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html" target="_blank" rel="noopener">java.lang.Appendable</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/2019/1/75OZ01__3_S0QJLWTH9N4QR20190216150423993.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/categories/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring源码阅读-aop</title>
    <link href="https://duia.github.io/2016/11/22/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aop/"/>
    <id>https://duia.github.io/2016/11/22/spring源码阅读-aop/</id>
    <published>2016-11-22T13:30:00.000Z</published>
    <updated>2019-05-18T02:00:00.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>aop部分的解析器由AopNamespaceHandler注册，其init方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="aop-config"><a href="#aop-config" class="headerlink" title="aop:config"></a>aop:config</h1><p>此标签用以配置pointcut, advisor, aspect，实例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* exam.service..*.*(..))"</span> <span class="attr">id</span>=<span class="string">"transaction"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"transaction"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ConfigBeanDefinitionParser.parse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    CompositeComponentDefinition compositeDef =</span><br><span class="line">            <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), </span><br><span class="line">            parserContext.extractSource(element));</span><br><span class="line">    parserContext.pushContainingComponent(compositeDef);</span><br><span class="line">    <span class="comment">// 是否生成代理类</span></span><br><span class="line">    configureAutoProxyCreator(parserContext, element);</span><br><span class="line">    List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">    <span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">        String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">        <span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">            parsePointcut(elt, parserContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">            parseAdvisor(elt, parserContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">            parseAspect(elt, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parserContext.popAndRegisterContainingComponent();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析的过程主要分为以下几个部分。</p><h3 id="proxy-target-class-amp-expose-proxy"><a href="#proxy-target-class-amp-expose-proxy" class="headerlink" title="proxy-target-class &amp; expose-proxy"></a>proxy-target-class &amp; expose-proxy</h3><p>对应着aop:config的两个属性，前者代表是否为被代理这生成CGLIB子类，默认false，只为接口生成代理子类(话说如果不生成子类那么怎么拦截?)。后者代表是否将代理bean暴露给用户，如果暴露，可以通过Spring AopContext类获得，默认不暴露。</p><p>解析的过程无非就是属性的读取，不再详细说明。</p><h3 id="aop-pointcut"><a href="#aop-pointcut" class="headerlink" title="aop:pointcut"></a>aop:pointcut</h3><p>pointcut的解析是一个生成一个BeanDefinition并将其id, expression等属性保存在BeanDefinition中。注意以下几点:</p><ul><li>BeanDefinition的ID来自于id属性，如果没有，那么自动生成。</li><li>BeanDefinition的class是AspectJExpressionPointcut。</li><li>BeanDefinition的scope为prototype。</li></ul><p>AspectJExpressionPointcut类图:</p><p><img src="http://tu.duia.online/aa9dd45ed8036c51c0e9891177a65842" alt="AspectJExpressionPointcut类图"></p><h3 id="aop-advisor"><a href="#aop-advisor" class="headerlink" title="aop:advisor"></a>aop:advisor</h3><p>首先是其所有属性的示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">order</span>=<span class="string">""</span> <span class="attr">advice-ref</span>=<span class="string">"aopAdvice"</span> <span class="attr">pointcut</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>advisor概念是Spring独有的，来自于上古时代，应该是较早时候的aop概念的实现: <a href="http://aopalliance.sourceforge.net/" target="_blank" rel="noopener">AOP Alliance (Java/J2EE AOP standards)</a>。Spring官方的说法: <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-schema-advisors" target="_blank" rel="noopener">aop-schema-advisors</a>。</p><p>其相关的包/类就在spring-aop下:</p><p><img src="http://tu.duia.online/f2702935eca77c3121e6cefeff18428c" alt="aopalliance包"></p><p>advice-ref是必须的属性，<strong>并且这里的advice必须实现org.aopalliance.aop.Advice的子接口</strong>。这些子接口指的什么呢，见Spring官方文档: <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html#aop-api-advice-types" target="_blank" rel="noopener">aop-api-advice-types</a>。比如org.aopalliance.intercept.MethodInterceptor。</p><p>最常见的用途就是结合事务使用:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">propagation</span>=<span class="string">"NOT_SUPPORTED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">propagation</span>=<span class="string">"NOT_SUPPORTED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* exam.service..*.*(..))"</span> <span class="attr">id</span>=<span class="string">"transaction"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"transaction"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析的套路和楼上类似，只不过此处的beanClass是DefaultBeanFactoryPointcutAdvisor，其类图:</p><p><img src="http://tu.duia.online/d46beb78192fd2d1e8207c626e8548cd" alt="DefaultBeanFactoryPointcutAdvisor类图"></p><p>另外注意对于pointcut和pointcut-ref两者处理的区别，对于pointcut属性，Spring会同样创建一个AspectJExpressionPointcut类型的BeanDefinition，对于pointcut-ref会生成一个RuntimeBeanReference对象指向原pointcut的引用。此类的类图:</p><p><img src="http://tu.duia.online/ce3f404b8139851a6fde580de0b7d366" alt="RuntimeBeanReference类图"></p><p>可以看出，这种aop的实现需要实现各种接口，所以不应该再使用此种方式进行aop，除了Spring内部的实现。</p><h3 id="aop-aspect"><a href="#aop-aspect" class="headerlink" title="aop:aspect"></a>aop:aspect</h3><p>配置举例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aopAdvice"</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemoAdvice"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 必须配置，因为被代理的对象必须在Spring容器中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aopDemo"</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemo"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* base.aop.AopDemo.send())"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aopAdvice"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforeSend"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterSend"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析形成的BeanDefinition结构如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">AspectComponentDefinition</span><br><span class="line">    beanRefArray</span><br><span class="line">        RuntimeBeanReference(aop:aspect的ref属性)</span><br><span class="line">    beanDefArray</span><br><span class="line">        // 被注册</span><br><span class="line">        RootBeanDefinition(aop:declare-parents)</span><br><span class="line">            beanClass: DeclareParentsAdvisor</span><br><span class="line">            ConstructorArg</span><br><span class="line">                implement-interface</span><br><span class="line">                types-matching</span><br><span class="line">                default-impl</span><br><span class="line">                delegate-ref</span><br><span class="line">        // 被注册</span><br><span class="line">        RootBeanDefinition(aop:before,aop:after...)</span><br><span class="line">            beanClass: AspectJPointcutAdvisor</span><br><span class="line">            ConstructorArg</span><br><span class="line">                RootBeanDefinition</span><br><span class="line">                    beanClass: 由子标签决定</span><br><span class="line">                    ConstructorArg</span><br><span class="line">                        RootBeanDefinition</span><br><span class="line">                            beanClass: MethodLocatingFactoryBean</span><br><span class="line">                            properties</span><br><span class="line">                                targetBeanName: aspectName</span><br><span class="line">                                methodName: method属性</span><br><span class="line">                        RootBeanDefinition</span><br><span class="line">                            beanClass: SimpleBeanFactoryAwareAspectInstanceFactory</span><br><span class="line">                            properties</span><br><span class="line">                                aspectBeanName: aspectName</span><br><span class="line">                        //还有pointcut定义和引用...</span><br></pre></td></tr></table></figure><p>结构图里面的aspectName来自于aop:aspect的ref属性，此属性是必须配置的，因为Spring要知道aop:before等标签指定的方法是哪个bean/类/对象的方法。</p><h4 id="aop-declare-parents"><a href="#aop-declare-parents" class="headerlink" title="aop:declare-parents"></a>aop:declare-parents</h4><p>对于aop:declare-parents子标签，其决定的是代理子类应该实现哪些接口:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span> <span class="attr">types-matching</span>=<span class="string">""</span> <span class="attr">implement-interface</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>此标签最终被解析成为beanClass为DeclareParentsAdvisor的BeanDefinition，并注册到容器中。其类图:</p><p><img src="http://tu.duia.online/24fea4a4df9ed9d0ee37d040f74c9ba3" alt="DeclareParentsAdvisor类图"></p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>此处的其它指的是aop:before, aop:after等最核心的标签。其最终被解析为beanClass为AspectJPointcutAdvisor的BeanDefinition，类图:</p><p><img src="http://tu.duia.online/2c472bc55be18a052fa62a0817ad25b1" alt="AspectJPointcutAdvisor类图"></p><p>正如上面结构图里所描述的，其构造参数为一个BeanDefintion，此对象的beanClass是不确定的，由aop:before/after中的before和after决定，代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) &#123;</span><br><span class="line">    String elementName = parserContext.getDelegate().getLocalName(adviceElement);</span><br><span class="line">    <span class="keyword">if</span> (BEFORE.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJMethodBeforeAdvice.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AFTER.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJAfterAdvice.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AFTER_RETURNING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJAfterReturningAdvice.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AFTER_THROWING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJAfterThrowingAdvice.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AROUND.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJAroundAdvice.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而此BeanDefintion的构造参数又由以下三个部分组成:</p><h5 id="MethodLocatingFactoryBean"><a href="#MethodLocatingFactoryBean" class="headerlink" title="MethodLocatingFactoryBean"></a>MethodLocatingFactoryBean</h5><p>第一个便是beanClass为此类型的BeanDefinition。其内部有一个methodName属性，存储的便是标签的method属性的值。其类图:</p><p><img src="http://tu.duia.online/bcc109a939fda148b45ecade325b6751" alt="MethodLocatingFactoryBean类图"></p><p>这个东西是干什么用的呢?其实是用于在指定的advice(aop:aspect的ref属性)中得到Method对象。入口在setBeanFactory方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; beanClass = beanFactory.getType(<span class="keyword">this</span>.targetBeanName);</span><br><span class="line">    <span class="keyword">this</span>.method = BeanUtils.resolveSignature(<span class="keyword">this</span>.methodName, beanClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SimpleBeanFactoryAwareAspectInstanceFactory"><a href="#SimpleBeanFactoryAwareAspectInstanceFactory" class="headerlink" title="SimpleBeanFactoryAwareAspectInstanceFactory"></a>SimpleBeanFactoryAwareAspectInstanceFactory</h5><p>其类图:</p><p><img src="http://tu.duia.online/bc9ba6b0874d32a5340718375708075d" alt="SimpleBeanFactoryAwareAspectInstanceFactory类图"></p><p>此类用于在BeanFactory中定位aspect bean，这个bean指的是谁?</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aopAdvice"</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemoAdvice"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>就是它!查找很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAspectInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getBean(<span class="keyword">this</span>.aspectBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从整个aop:aspect标签最终被解析为一个AspectJPointcutAdvisor来看，Spring在实现上仍将其作为Advisor的概念。</p><h2 id="代理子类生成"><a href="#代理子类生成" class="headerlink" title="代理子类生成"></a>代理子类生成</h2><p>关键在于AspectJAwareAdvisorAutoProxyCreator，此对象在ConfigBeanDefinitionParser的configureAutoProxyCreator方法中注册，其类图:</p><p><img src="http://tu.duia.online/cc83663a2f2a69115dfc807e0f41f441" alt="AspectJAwareAdvisorAutoProxyCreator类图"></p><p>那么子类生成的入口在哪里呢?</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>从AspectJAwareAdvisorAutoProxyCreator的类图中可以看出，此类实现了SmartInstantiationAwareBeanPostProcessor接口，所以很容易想到入口应该位于此接口及其父接口(BeanPostProcessor)的相关方法中。实际上确实是这样的。</p><h3 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h3><h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><p>先来回顾一下此方法在Bean创建的过程中的调用时机。</p><p>AbstractAutowireCapableBeanFactory.createBean部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br></pre></td></tr></table></figure><p>可以看出，调用发生在Bean实例的创建之前。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>AbstractAutoProxyCreator.postProcessBeforeInstantiation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanName == <span class="keyword">null</span> || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">            Object[] specificInterceptors = </span><br><span class="line">                getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">            <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分部分对其进行说明。</p><h4 id="应该代理"><a href="#应该代理" class="headerlink" title="应该代理 ?"></a>应该代理 ?</h4><p>Spring首先会对当前的beanClass进行检查(是否应该/可以对其进行代理)。</p><p>不应该代理的类分为两种情况: </p><ul><li>用于实现AOP的Spring基础类，此种情况在isInfrastructureClass方法中完成检测(单词Infrastructure正是基础设施的意思)。</li><li>子类定义的应该跳过的类，默认AbstractAutoProxyCreator的实现直接返回false，即都不应该跳过。</li></ul><h5 id="基础类检测"><a href="#基础类检测" class="headerlink" title="基础类检测"></a>基础类检测</h5><p>AbstractAutoProxyCreator.isInfrastructureClass:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，任何Advice、Pointcut、Advisor、AopInfrastructureBean的子类都被当做Spring实现AOP的基础设施类。</p><h5 id="跳过类检测"><a href="#跳过类检测" class="headerlink" title="跳过类检测"></a>跳过类检测</h5><p>即shouldSkip方法。前面提到了，AbstractAutoProxyCreator的默认实现直接返回fasle，这一特性被子类AspectJAwareAdvisorAutoProxyCreator重写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此方法跳过的是谁呢？</p><p>其实就是我们通过aop:aspect标签配置的切面，即:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aopAdvice"</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemoAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aopAdvice"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>里的aopAdvice。</p><p>从前面的aop:aspect一节中可以知道，Spring对于aop:config的解析其实是把aop:before/after等标签解析成为了AspectJPointcutAdvisor类型的BeanDefinition，而aopAdvice以AbstractAspectJAdvice的类型保存在其中。</p><p>所以可以得出结论: <strong>Spring跳过的是适用于当前bean的Advisor的Advice/Aspect对象</strong>。</p><h6 id="AOP逻辑"><a href="#AOP逻辑" class="headerlink" title="AOP逻辑"></a>AOP逻辑</h6><p><img src="http://tu.duia.online/50038bbaa00dc43322c9e947c86adfae" alt="AOP逻辑图"></p><p>那么Spring又是如何找到适用于当前bean的Advisor的呢?</p><h6 id="Advisor寻找"><a href="#Advisor寻找" class="headerlink" title="Advisor寻找"></a>Advisor寻找</h6><p>关键便是findCandidateAdvisors方法，此方法将逻辑委托给BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] advisorNames = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="comment">// 结果缓存</span></span><br><span class="line">        advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">        <span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 去容器中寻找</span></span><br><span class="line">            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                    <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">                advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，首先是从容器中获取到所有的Advisor示例，然后调用isEligibleBean方法逐一判断Advisor是否适用于当前bean。</p><h6 id="适用性检测"><a href="#适用性检测" class="headerlink" title="适用性检测"></a>适用性检测</h6><p>指的便是isEligibleBean方法。最终调用的是AbstractAdvisorAutoProxyCreator的同名方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEligibleAdvisorBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而AbstractAdvisorAutoProxyCreator的子类AspectJAwareAdvisorAutoProxyCreator并没有覆盖此方法，所以此处会对<strong>容器中所有的Advisor的Advice进行跳过</strong>。</p><h5 id="检测结果缓存"><a href="#检测结果缓存" class="headerlink" title="检测结果缓存"></a>检测结果缓存</h5><p>因为postProcessBeforeInstantiation方法会在每个bean初始化之前被调用，所以没有必要每次都真的进行基础类检测和跳过类检测，Spring使用了advisedBeans作为缓存用以提高性能。</p><h4 id="TargetSource"><a href="#TargetSource" class="headerlink" title="TargetSource"></a>TargetSource</h4><p>从源码中可以看出，对于自定义的TargetSource，Spring会立即执行代理子类的创建。Spring的代理其实是针对TargetSource的，其类图:</p><p><img src="http://tu.duia.online/aa71319a8e2580e09599e197780ff8b9" alt="TargetSource类图"></p><p>关于此接口在此不展开叙述。</p><h3 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h3><p>AbstractAutoProxyCreator.postProcessAfterInitialization:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键便在于wrapIfNecessary方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自定义TargetSource，已经进行过代理子类生成</span></span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，在此方法的开头又进行了基础类以及跳过类的检测，再次不再赘述。</p><h4 id="Advisor寻找-1"><a href="#Advisor寻找-1" class="headerlink" title="Advisor寻找"></a>Advisor寻找</h4><p>即getAdvicesAndAdvisorsForBean方法，这里进行的便是去容器中寻找适用于当前bean的Advisor，最终调用的是</p><p>AbstractAdvisorAutoProxyCreator.findEligibleAdvisors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findCandidateAdvisors前面已经说过了。</p><h5 id="适用性判断"><a href="#适用性判断" class="headerlink" title="适用性判断"></a>适用性判断</h5><p>findAdvisorsThatCanApply最终调用AopUtils.findAdvisorsThatCanApply:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">            <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于canApply方法，从源码中可以看出，对于Advisor的判断分为了IntroductionAdvisor以及非IntroductionAdvisor两种情况。</p><p>这种分开处理导致了<strong>IntroductionAdvisor在Advisor链中总是位于非IntroductionAdvisor前面</strong>。</p><p>canApply(candidate, clazz)其实等价于canApply(candidate, clazz, false):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">        PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line">        <span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It doesn't have a pointcut so we assume it applies.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，对于引入Advisor与其它Advisor是两种不同的判断方式。</p><h6 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h6><p>引入的概念在下面aop:scoped-proxy中有提到。因为引入的目的在于动态地向一个类添加另一种功能(接口)，所以只要判断给定的类是否是要引入到的类即可。</p><h6 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h6><p>AopUtils.canApply:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否Pointcut可以匹配当前类</span></span><br><span class="line">    <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">    <span class="comment">//是否Pointcut可以匹配所有方法</span></span><br><span class="line">    <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">        <span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;</span><br><span class="line">        (ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">    classes.add(targetClass);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    introductionAwareMethodMatcher</span><br><span class="line">                        .matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">                    methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的Pointcut由ClassFilter和MethodMatcher两部分组成，其中前者用以判断给定的类是否在Pointcut的匹配范围内，后者用以在ClassFilter匹配满足的情况下判断给定的方法是否在Pointcut匹配的范围内。</p><p>从源码中可以看出，如果ClassFilter匹配得到满足并且Pointcut并不能匹配此类的任意方法，便会<strong>用反射的方法获取targetClass(被检测类)的全部方法逐一交由Pointcut的MethodMatcher进行检测</strong>。</p><p>关于Pointcut表达式是如何解析及存储的在此不再展开。</p><h5 id="Advisor扩展"><a href="#Advisor扩展" class="headerlink" title="Advisor扩展"></a>Advisor扩展</h5><p>AbstractAdvisorAutoProxyCreator.extendAdvisors允许子类向Advisor链表中添加自己的Advisor。子类AspectJAwareAdvisorAutoProxyCreator重写了此方法，其逻辑是:</p><p>如果Advisor链表中的Advisor含有AspectJ Advice，那么将会把一个ExposeInvocationInterceptor添加到链表的表头，目的在于将MethodInvocation以ThreadLocal的方式暴露给后面所有的Advisor，暂不知道具体的用途。</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>即sortAdvisors方法，用于对实现了Ordered接口的Advisor进行排序。</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>AbstractAutoProxyCreator.createProxy(略去非关键代码):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将interceptor适配为Advisor</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">        proxyFactory.addAdvisor(advisor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JDK动态代理-or-Cglib"><a href="#JDK动态代理-or-Cglib" class="headerlink" title="JDK动态代理 or Cglib"></a>JDK动态代理 or Cglib</h5><p>由DefaultAopProxyFactory.createAopProxy方法决定使用何种方式创建代理子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() ||</span><br><span class="line">            hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很明显，如果指定了(proxy-target-classs设为true)使用Cglib，那么就会使用Cglib的方式，如果没有指定(或为false)，那么先回检测被代理类是否实现了自己的接口，如果实现了，那么就采用JDK动态代理的方式。</p><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>JdkDynamicAopProxy.getProxy:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到可以用来进行代理的接口</span></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//用来代理的接口中是否定义了equals或者是hashCode方法?</span></span><br><span class="line">    <span class="comment">//结果保存在内部equalsDefined和hashCodeDefined两个成员变量中</span></span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，关键的InvocationHandler参数其实就是JdkDynamicAopProxy自身。</p><p>其invoke方法较长，源码就不贴了，下面进行分部分说明。</p><h6 id="equals-amp-hashCode"><a href="#equals-amp-hashCode" class="headerlink" title="equals &amp; hashCode"></a>equals &amp; hashCode</h6><p>如果被代理类实现了equals或者是hashCode方法，那么生成的代理子类的equals、hashCode方法实际上执行的是JdkDynamicAopProxy相应方法的逻辑。</p><p>invoke方法部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">    <span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">    <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h6><p>对于切点方法，比如前面aop:aspect示例配置中的beforeSend</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforeSend"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Spring会创建一个MethodInvocation对象对所有相关的Advisor进行链式调用。invoke相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">Object retVal = invocation.proceed();</span><br></pre></td></tr></table></figure><h5 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h5><p>同样是对于Advisor的链式调用，不再详细展开。</p><h1 id="aop-scoped-proxy"><a href="#aop-scoped-proxy" class="headerlink" title="aop:scoped-proxy"></a>aop:scoped-proxy</h1><p>此配置一般是这样使用:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于ref属性，<strong>只会在userManager初始化时注入一次</strong>。这会造成什么问题呢?以session的Scope为例，因为只会注入一次，所以，<strong>userManager引用的始终是同一个userPreferences对象，即使现在可能已经过时了</strong>。此配置便可以使userManager引用的其实是一个对代理的引用，所以可以始终获取到最新的userPreferences。</p><p>其作用和注解@ScopedProxy相同。</p><p>其解析由ScopedProxyBeanDefinitionDecorator完成，类图:</p><p><img src="http://tu.duia.online/56e52ee952be40f52d2246ca88b2fa5d" alt="ScopedProxyBeanDefinitionDecorator类图"></p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h3><p>从类图可以看出，ScopedProxyBeanDefinitionDecorator和之前的解析器都不同，它的调用入口不同以往:</p><p>DefaultBeanDefinitionDocumentReader.processBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 装饰</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinitionParserDelegate.decorateIfRequired:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateIfRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">    String namespaceUri = getNamespaceURI(node);</span><br><span class="line">    <span class="keyword">if</span> (!isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">        NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver()</span><br><span class="line">            .resolve(namespaceUri);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler.</span><br><span class="line">                decorate(node, originalDef, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originalDef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一目了然。</p><p>这么做(装饰)的原因就是此标签是用在bean内部的，从decorate的方法签名可以看出，第二个便是父(bean)BeanDefinition，所以叫做装饰。</p><h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorate</span><span class="params">(Node node, BeanDefinitionHolder definition, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> proxyTargetClass = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element ele = (Element) node;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(PROXY_TARGET_CLASS)) &#123;</span><br><span class="line">            proxyTargetClass = Boolean.valueOf(ele.getAttribute(PROXY_TARGET_CLASS));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanDefinitionHolder holder =</span><br><span class="line">            ScopedProxyUtils.</span><br><span class="line">            createScopedProxy(definition, parserContext.getRegistry(), proxyTargetClass);</span><br><span class="line">    String targetBeanName = ScopedProxyUtils.getTargetBeanName(definition.getBeanName());</span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">    parserContext.getReaderContext().fireComponentRegistered(</span><br><span class="line">            <span class="keyword">new</span> BeanComponentDefinition(definition.getBeanDefinition(), targetBeanName));</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心便是createScopedProxy方法，其源码较长，但是这个套路之前见识过了，就是一个偷天换日: 创建一个新的BeanDefinition对象，beanName为被代理的bean的名字，被代理的bean名字为scopedTarget.原名字。被代理的bean扔将被注册到容器中。</p><p>新的BeanDefintion的beanClass为ScopedProxyFactoryBean，其类图:</p><p><img src="http://tu.duia.online/b45775a439cb813d40a715cf69746a25" alt="ScopedProxyFactoryBean类图"></p><h2 id="代理生成"><a href="#代理生成" class="headerlink" title="代理生成"></a>代理生成</h2><p>入口便是setBeanFactory方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    ConfigurableBeanFactory cbf = (ConfigurableBeanFactory) beanFactory;</span><br><span class="line">    <span class="keyword">this</span>.scopedTargetSource.setBeanFactory(beanFactory);</span><br><span class="line">    ProxyFactory pf = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    pf.copyFrom(<span class="keyword">this</span>);</span><br><span class="line">    pf.setTargetSource(<span class="keyword">this</span>.scopedTargetSource);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; beanType = beanFactory.getType(<span class="keyword">this</span>.targetBeanName);</span><br><span class="line">    <span class="keyword">if</span> (!isProxyTargetClass() || beanType.isInterface() || </span><br><span class="line">        Modifier.isPrivate(beanType.getModifiers())) &#123;</span><br><span class="line">         <span class="comment">// JDK动态代理可用的接口</span></span><br><span class="line">        pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add an introduction that implements only the methods on ScopedObject.</span></span><br><span class="line">    ScopedObject scopedObject = <span class="keyword">new</span> DefaultScopedObject</span><br><span class="line">        (cbf, <span class="keyword">this</span>.scopedTargetSource.getTargetBeanName());</span><br><span class="line">    pf.addAdvice(<span class="keyword">new</span> DelegatingIntroductionInterceptor(scopedObject));</span><br><span class="line">    <span class="comment">// Add the AopInfrastructureBean marker to indicate that the scoped proxy</span></span><br><span class="line">    <span class="comment">// itself is not subject to auto-proxying! Only its target bean is.</span></span><br><span class="line">    pf.addInterface(AopInfrastructureBean.class);</span><br><span class="line">    <span class="keyword">this</span>.proxy = pf.getProxy(cbf.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个套路上面也见过了。</p><h3 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h3><p>核心的拦截逻辑是通过DelegatingIntroductionInterceptor来完成的，其类图:</p><p><img src="http://tu.duia.online/1e9ca3328386e419c42e122fe3399e69" alt="DelegatingIntroductionInterceptor类图"></p><p>AdvisedSupport.addAdvice方法将其转化为Advisor:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(<span class="keyword">int</span> pos, Advice advice)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> IntroductionInfo) &#123;</span><br><span class="line">        <span class="comment">// We don't need an IntroductionAdvisor for this kind of introduction:</span></span><br><span class="line">        <span class="comment">// It's fully self-describing.</span></span><br><span class="line">        addAdvisor(pos, <span class="keyword">new</span> DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> DynamicIntroductionAdvice) &#123;</span><br><span class="line">        <span class="comment">// We need an IntroductionAdvisor for this kind of introduction.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addAdvisor(pos, <span class="keyword">new</span> DefaultPointcutAdvisor(advice));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，DelegatingIntroductionInterceptor被包装为DefaultIntroductionAdvisor对象。</p><p>DelegatingIntroductionInterceptor到底是个什么东西呢?这其实就引出了Spring的Introduction(引入)概念。</p><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>通常意义上的Spring AOP一般是在方法层面上进行逻辑的改变，而引入指的是在不修改类源码的情况下，<strong>直接为一个类添加新的功能</strong>。下面是一个引入使用的例子:</p><p><a href="http://blog.csdn.net/lzghxjt/article/details/51974336" target="_blank" rel="noopener">SpringAOP中的IntroductionInterceptor</a></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="自定义Scope"><a href="#自定义Scope" class="headerlink" title="自定义Scope"></a>自定义Scope</h3><p>为了便于测试，我们定义一个生存周期仅仅在于一次调用的Scope，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get被调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="string">"skywalker-"</span> + (index++), index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//忽略其它方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其注册到容器中，有两种方法:</p><ul><li><p>在代码中: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getBeanFactory().registerScope(<span class="string">"one"</span>, <span class="keyword">new</span> OneScope());</span><br></pre></td></tr></table></figure></li><li><p>配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scopes"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.scope.OneScope"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>此时就可以使用我们自己的Scope了:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span> <span class="attr">id</span>=<span class="string">"simpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"student"</span> <span class="attr">ref</span>=<span class="string">"student"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span> <span class="attr">scope</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>执行以下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleBean simpleBean = context.getBean(SimpleBean.class);</span><br><span class="line">System.out.println(simpleBean.getStudent().getName());</span><br><span class="line">System.out.println(simpleBean.getStudent().getName());</span><br></pre></td></tr></table></figure><p>可以看到以下输出:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get被调用</span><br><span class="line">skywalker-0</span><br><span class="line">get被调用</span><br><span class="line">skywalker-1</span><br></pre></td></tr></table></figure><p>可以得出结论: <strong>当调用被代理的bean的方法时才会触发Scoped的语义，只是获得其对象(getStudent)没有效果</strong>。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h3><p>从根本上来说在于AbstractBeanFactory.doGetBean，部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope非prototype和Singleton</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    String scopeName = mbd.getScope();</span><br><span class="line">    <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">    Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scopes是BeanFactory内部的一个 LinkedHashMap&lt;String, Scope&gt;类型的对象。scope.get实际上调用的就是我们的OneSocpe的get方法，没有用到ObjectFactory。</p><p>所以，<strong>每调用一次getBean，就会导致一个新的Sudent被创建并返回</strong>。</p><h3 id="代理子类"><a href="#代理子类" class="headerlink" title="代理子类"></a>代理子类</h3><p>还有一个关键的问题，从上面可以知道SimpleBean内部的student引用其实是一个CGLIB代理子类的对象，那么当调用这个代理对象的相应方法(比如getName)时，是怎样导致Student重新创建(或是getBean被调用)的?</p><h3 id="CallbackFilter-amp-Callback"><a href="#CallbackFilter-amp-Callback" class="headerlink" title="CallbackFilter &amp; Callback"></a>CallbackFilter &amp; Callback</h3><p>必须首先理解下CGLIB的这两个概念。</p><h4 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h4><p><strong>Callback是Cglib所有自定义逻辑(增强)的共同接口</strong>。</p><p>其简略类图:</p><p><img src="http://tu.duia.online/aba8498ca2ccde009ea2d28cc1c1be3b" alt="Callback类图"></p><h4 id="CallbackFilter"><a href="#CallbackFilter" class="headerlink" title="CallbackFilter"></a>CallbackFilter</h4><p><strong>在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</strong></p><p>jdk并不支持这么搞，只支持设置一个InvocationHandler处理(拦截)所有的方法。其类图:</p><p><img src="http://tu.duia.online/9dbeb323f5b71d09dbe6e164227f1a5d" alt="CallbackFilter类图"></p><p>Cglib的Enhancer可以指定一个Callback数组，而accept方法的返回值是一个int值，其实就是Callback数组的下标，这样便达到了指定回调逻辑的目的。</p><p>参考:</p><p><a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener">CGLIB介绍与原理</a></p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>一般的方法使用的是DynamicAdvisedInterceptor作为回调逻辑，其intercept关键源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> </span>&#123;</span><br><span class="line">    Object target = getTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>target就是被代理对象。</p><p>getTarget:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getTarget</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.advised.getTargetSource().getTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TargetSource前面说过了，默认是SimpleBeanTargetSource:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(getTargetBeanName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，真相大白。</p><h1 id="aop-aspectj-autoproxy"><a href="#aop-aspectj-autoproxy" class="headerlink" title="aop:aspectj-autoproxy"></a>aop:aspectj-autoproxy</h1><p>此标签用以开启对于@AspectJ注解风格AOP的支持。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="proxy-target-class"><a href="#proxy-target-class" class="headerlink" title="proxy-target-class"></a>proxy-target-class</h3><p>你懂的。</p><h3 id="expose-proxy"><a href="#expose-proxy" class="headerlink" title="expose-proxy"></a>expose-proxy</h3><p>是否应该把代理对象暴露给AopContext，默认false。</p><h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(void base.aop.AopDemo.send(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSend</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"beforeSend()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send之前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="被代理类"><a href="#被代理类" class="headerlink" title="被代理类"></a>被代理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopDemo</span> <span class="keyword">implements</span> <span class="title">AopDemoInter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send from aopdemo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"receive from aopdemo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"inter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemo"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.aop.annotation.AspectDemo"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>因为AopDemo实现了AopDemoInter接口，但做实验的send方法又不在此接口里定义，所以只能用cglib的方式代理。</p><p>可以看出，<strong>即使标注了@Aspect注解，仍然需要将切面自己配置到Spring容器中。</strong></p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>AspectJAutoProxyBeanDefinitionParser.parse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    AopNamespaceUtils.</span><br><span class="line">        registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">    extendBeanDefinition(element, parserContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册最终在AopConfigUtils.registerOrEscalateApcAsRequired方法中完成，创建器实际上是一个AnnotationAwareAspectJAutoProxyCreator类的对象，此类是前面AspectJAwareAdvisorAutoProxyCreator的子类。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>既然是AspectJAwareAdvisorAutoProxyCreator的子类，那么其代理子类的创建等核心逻辑自然是一样的。这里所需要关注的地方自然是所不一样的地方: 即是如何体现其注解的特性的。</p><p>前面说过，AspectJAwareAdvisorAutoProxyCreator通过findCandidateAdvisors方法来找到适用于bean的Advisor，所以注解的特性也是通过重写此方法来体现。</p><p>AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="comment">//这里</span></span><br><span class="line">    advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buildAspectJAdvisors方法所做的便是<strong>从容器中得到所有的bean，逐一判断是不是一个Aspect</strong>。那么判断Aspect的依据是什么?</p><p>AbstractAspectJAdvisorFactory.isAspect:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAspect</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于其它的实现细节不再探究。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Spring对于AspectJ风格AOP的支持停留在外表(注解)上面，内部的实现仍然是自己的东西。</p><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="AOP切面的坑"><a href="#AOP切面的坑" class="headerlink" title="AOP切面的坑"></a>AOP切面的坑</h2><ol><li>定义在private方法上的切面不会被执行，这个很容易理解，毕竟子类不能覆盖父类的私有方法。</li><li>同一个代理子类内部的方法相互调用不会再次执行切面。</li></ol><p>这里以Cglib为例对第二点进行说明，cglib的相关核心组件可以参考前面CallbackFilter &amp; Callback部分。对于配置了一个切面的典型场景，Spring内部的执行流程可总结如下图:</p><p><img src="http://tu.duia.online/4cae312cd6aa1b8ef1fc308c5f10fd94" alt="Cglib调用流程"></p><p>核心便是对目标方法的调用上，这里由CglibMethodInvocation的invokeJoinpoint实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publicMethod) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.methodProxy.invoke(<span class="keyword">this</span>.target, <span class="keyword">this</span>.arguments);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是非public方法，那么Spring将使用反射的方法对其进行调用，因为反射将其可访问性设为true。MethodProxy是Cglib对方法代理的抽象，这里的关键是<strong>方法调用的对象(目标)是我们的原生类对象，而不是Cglib代理子类的对象，这就从根本上决定了对同类方法的调用不会再次经过切面</strong>。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>前面aop:aspectj-autoproxy-属性-expose-proxy一节提到了，Spring允许我们将代理子类暴露出来，可以进行如下配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"simpleMethodInterceptor"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* aop.SimpleAopBean.*(..))"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们需要在一个被代理方法中调用同类的方法时(此方法也需要经过切面)，可以这样调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testB执行"</span>);</span><br><span class="line">    ((SimpleAopBean) AopContext.currentProxy()).testC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实是一个ThreadLocal，当Cglib代理子类创建调用链之间便会将代理类设置到其中，DynamicAdvisedInterceptor.intercept相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">    <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">    oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">    setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;aop部分的解析器由AopNamespaceHandler注册，其init方法:&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="spring" scheme="https://duia.github.io/categories/spring/"/>
    
      <category term="源码阅读" scheme="https://duia.github.io/categories/spring/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="源码阅读" scheme="https://duia.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="spring" scheme="https://duia.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码阅读-基础</title>
    <link href="https://duia.github.io/2016/11/16/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%9F%BA%E7%A1%80/"/>
    <id>https://duia.github.io/2016/11/16/spring源码阅读-基础/</id>
    <published>2016-11-16T14:10:00.000Z</published>
    <updated>2019-05-11T15:00:00.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>本部分从最基本的Spring开始。配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">    SimpleBean bean = context.getBean(SimpleBean.class);</span><br><span class="line">    bean.send();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>SimpleBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am send method from SimpleBean!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><p>整个继承体系如下:</p><p><img src="/upload/2019/1/ResourceLoader20190216152855827.jpg" alt="ResourceLoader继承体系"></p><p>ResourceLoader代表了<strong>加载资源的一种方式，正是策略模式的实现</strong>。</p><p>构造器源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext          parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//null</span></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="comment">//默认true</span></span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getResourcePatternResolver:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathMatchingResourcePatternResolver支持Ant风格的路径解析。</p><h3 id="设置配置文件路径"><a href="#设置配置文件路径" class="headerlink" title="设置配置文件路径"></a>设置配置文件路径</h3><p>即AbstractRefreshableConfigApplicationContext.setConfigLocations:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String... locations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolvePath:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: <code>new ClassPathXmlApplicationContext(&quot;classpath:config.xml&quot;);</code>那么classpath:就是需要被解析的。</p><p>getEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Environment接口"><a href="#Environment接口" class="headerlink" title="Environment接口"></a>Environment接口</h4><p>继承体系:</p><p><img src="/upload/2019/1/Environment20190216153011886.jpg" alt="Environment继承体系"></p><p>Environmen接口<strong>代表了当前应用所处的环境。</strong>从此接口的方法可以看出，其主要和profile、Property相关。</p><h5 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h5><p>Spring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。<strong>Spring容器管理的所有bean都是和一个profile绑定在一起的。</strong>使用了Profile的配置文件示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"develop"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:jdbc-develop.properties"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:jdbc-production.properties"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"test"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:jdbc-test.properties"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在启动代码中可以用如下代码设置活跃(当前使用的)Profile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getEnvironment().setActiveProfiles(<span class="string">"dev"</span>);</span><br></pre></td></tr></table></figure><p>当然使用的方式还有很多(比如注解)，参考:</p><p><a href="http://radiumxie.iteye.com/blog/1851919" target="_blank" rel="noopener">spring3.1 profile 配置不同的环境</a></p><p><a href="http://www.mkyong.com/spring/spring-profiles-example/" target="_blank" rel="noopener">Spring Profiles example</a></p><h5 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h5><p>这里的Property指的是程序运行时的一些参数，引用注释:</p><blockquote><p>properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on.</p></blockquote><h4 id="Environment构造器"><a href="#Environment构造器" class="headerlink" title="Environment构造器"></a>Environment构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MutablePropertySources propertySources = <span class="keyword">new</span> MutablePropertySources(<span class="keyword">this</span>.logger);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    customizePropertySources(<span class="keyword">this</span>.propertySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PropertySources接口"><a href="#PropertySources接口" class="headerlink" title="PropertySources接口"></a>PropertySources接口</h5><p>继承体系:</p><p><img src="/upload/2019/1/PropertySources20190216153122626.jpg" alt="PropertySources继承体系"></p><p>此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。</p><p>StandardEnvironment.customizePropertySources:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** System environment property source name: &#123;<span class="doctag">@value</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = <span class="string">"systemEnvironment"</span>;</span><br><span class="line"><span class="comment">/** JVM system properties property source name: &#123;<span class="doctag">@value</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = <span class="string">"systemProperties"</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>&#123;</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> MapPropertySource</span><br><span class="line">        (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> SystemEnvironmentPropertySource</span><br><span class="line">        (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PropertySource接口"><a href="#PropertySource接口" class="headerlink" title="PropertySource接口"></a>PropertySource接口</h5><p>PropertySource接口代表了键值对的Property来源。继承体系：</p><p><img src="/upload/2019/1/PropertySource20190216153201730.jpg" alt="PropertySource继承体系"></p><p>AbstractEnvironment.getSystemProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map) System.getProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map) <span class="keyword">new</span> ReadOnlySystemAttributesMap() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> String <span class="title">getSystemAttribute</span><span class="params">(String attributeName)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(attributeName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(format(<span class="string">"Caught AccessControlException when accessing system "</span> +</span><br><span class="line">                                <span class="string">"property [%s]; its value will be returned [null]. Reason: %s"</span>,</span><br><span class="line">                                attributeName, ex.getMessage()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。</p><p>getSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。</p><h4 id="路径Placeholder处理"><a href="#路径Placeholder处理" class="headerlink" title="路径Placeholder处理"></a>路径Placeholder处理</h4><p>AbstractEnvironment.resolveRequiredPlaceholders:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="comment">//text即配置文件路径，比如classpath:config.xml</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertyResolver.resolveRequiredPlaceholders(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>propertyResolver是一个PropertySourcesPropertyResolver对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConfigurablePropertyResolver propertyResolver =</span><br><span class="line">            <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources);</span><br></pre></td></tr></table></figure><h5 id="PropertyResolver接口"><a href="#PropertyResolver接口" class="headerlink" title="PropertyResolver接口"></a>PropertyResolver接口</h5><p>PropertyResolver继承体系(排除Environment分支):</p><p><img src="/upload/2019/1/PropertyResolver20190216153244555.jpg" alt="PropertyResolver继承体系"></p><p>此接口正是用来解析PropertyResource。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>AbstractPropertyResolver.resolveRequiredPlaceholders:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.strictHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.strictHelper = createPlaceholderHelper(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doResolvePlaceholders(text, <span class="keyword">this</span>.strictHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PropertyPlaceholderHelper <span class="title">createPlaceholderHelper</span><span class="params">(<span class="keyword">boolean</span> ignoreUnresolvablePlaceholders)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//三个参数分别是$&#123;, &#125;, :</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="keyword">this</span>.placeholderPrefix, <span class="keyword">this</span>.placeholderSuffix,</span><br><span class="line">        <span class="keyword">this</span>.valueSeparator, ignoreUnresolvablePlaceholders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doResolvePlaceholders：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doResolvePlaceholders</span><span class="params">(String text, PropertyPlaceholderHelper helper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//PlaceholderResolver接口依然是策略模式的体现</span></span><br><span class="line">    <span class="keyword">return</span> helper.replacePlaceholders(text, <span class="keyword">new</span> PropertyPlaceholderHelper.PlaceholderResolver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPropertyAsRawString(placeholderName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"spring"</span>, <span class="string">"classpath"</span>);</span><br><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"$&#123;spring&#125;:config.xml"</span>);</span><br><span class="line">SimpleBean bean = context.getBean(SimpleBean.class);</span><br></pre></td></tr></table></figure><p>这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getPropertyAsRawString</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProperty(key, String.class, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">            Object value = propertySource.getProperty(key);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。</p><p>注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。</p><h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2><p>Spring bean解析就在此方法，所以单独提出来。</p><p>AbstractApplicationContext.refresh:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">    <span class="comment">//空实现</span></span><br><span class="line">    initPropertySources();</span><br><span class="line">    <span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line">    <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性校验"><a href="#属性校验" class="headerlink" title="属性校验"></a>属性校验</h4><p>AbstractEnvironment.validateRequiredProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> <span class="keyword">throws</span> MissingRequiredPropertiesException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.propertyResolver.validateRequiredProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPropertyResolver.validateRequiredProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MissingRequiredPropertiesException ex = <span class="keyword">new</span> MissingRequiredPropertiesException();</span><br><span class="line">    <span class="keyword">for</span> (String key : <span class="keyword">this</span>.requiredProperties) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getProperty(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ex.addMissingRequiredProperty(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ex.getMissingRequiredProperties().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>requiredProperties是通过setRequiredProperties方法设置的，保存在一个list里面，默认是空的，也就是不需要校验任何属性。</p><h3 id="BeanFactory创建"><a href="#BeanFactory创建" class="headerlink" title="BeanFactory创建"></a>BeanFactory创建</h3><p>由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//如果已经存在，那么销毁之前的</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建了一个DefaultListableBeanFactory对象</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h4><p>此接口实际上就是Bean容器，其继承体系:</p><p><img src="/upload/2019/1/BeanFactory20190216153345382.jpg" alt="BeanFactory继承体系"></p><h4 id="BeanFactory定制"><a href="#BeanFactory定制" class="headerlink" title="BeanFactory定制"></a>BeanFactory定制</h4><p>AbstractRefreshableApplicationContext.customizeBeanFactory方法用于给子类提供一个自由配置的机会，默认实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//默认false，不允许覆盖</span></span><br><span class="line">        beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//默认false，不允许循环引用</span></span><br><span class="line">        beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean加载"><a href="#Bean加载" class="headerlink" title="Bean加载"></a>Bean加载</h4><p>AbstractXmlApplicationContext.loadBeanDefinitions，这个便是核心的bean加载了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    <span class="comment">//默认空实现</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EntityResolver"><a href="#EntityResolver" class="headerlink" title="EntityResolver"></a>EntityResolver</h5><p>此处只说明用到的部分继承体系:</p><p><img src="/upload/2019/1/EntityResolver20190216153445595.jpg" alt="EntityResolver继承体系"></p><p>EntityResolver接口在org.xml.sax中定义。DelegatingEntityResolver用于schema和dtd的解析。</p><h5 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h5><p>继承体系:</p><p><img src="/upload/2019/1/BeanDefinitionReader20190216153522690.jpg" alt="BeanDefinitionReader继承体系"></p><h5 id="路径解析-Ant"><a href="#路径解析-Ant" class="headerlink" title="路径解析(Ant)"></a>路径解析(Ant)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="comment">//here</span></span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractBeanDefinitionReader.loadBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        counter += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个参数为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="comment">//参见ResourceLoader类图，ClassPathXmlApplicationContext实现了此接口</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getResource的实现在AbstractApplicationContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//构造器中初始化，PathMatchingResourcePatternResolver对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathMatchingResourcePatternResolver是ResourceLoader继承体系的一部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">    <span class="comment">//classpath:</span></span><br><span class="line">    <span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">        <span class="comment">// a class path resource (multiple resources for same name possible)</span></span><br><span class="line">        <span class="comment">//matcher是一个AntPathMatcher对象</span></span><br><span class="line">        <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern</span><br><span class="line">            .substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">            <span class="comment">// a class path resource pattern</span></span><br><span class="line">            <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// all class path resources with the given name</span></span><br><span class="line">            <span class="keyword">return</span> findAllClassPathResources(locationPattern</span><br><span class="line">                .substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Only look for a pattern after a prefix here</span></span><br><span class="line">        <span class="comment">// (to not get fooled by a pattern symbol in a strange prefix).</span></span><br><span class="line">        <span class="keyword">int</span> prefixEnd = locationPattern.indexOf(<span class="string">":"</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">            <span class="comment">// a file pattern</span></span><br><span class="line">            <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a single resource with the given name</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isPattern:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPattern</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (path.indexOf(<span class="string">'*'</span>) != -<span class="number">1</span> || path.indexOf(<span class="string">'?'</span>) != -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出配置文件路径是支持ant风格的，也就是可以这么写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"con*.xml"</span>);</span><br></pre></td></tr></table></figure><p>具体怎么解析ant风格的就不写了。</p><h5 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h5><p>入口方法在AbstractBeanDefinitionReader的217行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载</span></span><br><span class="line">Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br></pre></td></tr></table></figure><p>最终逐个调用XmlBeanDefinitionReader的loadBeanDefinitions方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Resource是代表一种资源的接口，其类图:</p><p><img src="/upload/2019/1/Resource20190216153615404.jpg" alt="Resource类图"></p><p>EncodedResource扮演的其实是一个装饰器的模式，为InputStreamSource添加了字符编码(虽然默认为null)。这样为我们自定义xml配置文件的编码方式提供了机会。</p><p>之后关键的源码只有两行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">    InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">    <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputSource是org.xml.sax的类。</p><p>doLoadBeanDefinitions：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span> </span>&#123;</span><br><span class="line">    Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doLoadDocument:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">        getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>documentLoader是一个DefaultDocumentLoader对象，此类是DocumentLoader接口的唯一实现。getEntityResolver方法返回ResourceEntityResolver，上面说过了。errorHandler是一个SimpleSaxErrorHandler对象。</p><p>校验模型其实就是确定xml文件使用xsd方式还是dtd方式来校验，忘了的话左转度娘。Spring会通过读取xml文件的方式判断应该采用哪种。</p><p>NamespaceAware默认false，因为默认配置了校验为true。</p><p>DefaultDocumentLoader.loadDocument:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">    ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里就是老套路了，可以看出，Spring还是使用了dom的方式解析，即一次全部load到内存</span></span><br><span class="line">    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">    <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createDocumentBuilderFactory比较有意思:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance()</span></span>;</span><br><span class="line">    factory.setNamespaceAware(namespaceAware);</span><br><span class="line">    <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">        <span class="comment">//此方法设为true仅对dtd有效，xsd(schema)无效</span></span><br><span class="line">        factory.setValidating(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">            <span class="comment">// Enforce namespace aware for XSD...</span></span><br><span class="line">             <span class="comment">//开启xsd(schema)支持</span></span><br><span class="line">            factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">             <span class="comment">//这个也是Java支持Schema的套路，可以问度娘</span></span><br><span class="line">            factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Bean解析"><a href="#Bean解析" class="headerlink" title="Bean解析"></a>Bean解析</h5><p>XmlBeanDefinitionReader.registerBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBeanDefinitionDocumentReader:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast</span><br><span class="line">      <span class="comment">//反射</span></span><br><span class="line">      (BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>documentReaderClass默认是DefaultBeanDefinitionDocumentReader，这其实也是策略模式，通过setter方法可以更换其实现。</p><p>注意cast方法，代替了强转。</p><p>createReaderContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">        <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>problemReporter是一个FailFastProblemReporter对象。</p><p>eventListener是EmptyReaderEventListener对象，此类里的方法都是空实现。</p><p>sourceExtractor是NullSourceExtractor对象，直接返回空，也是空实现。</p><p>getNamespaceHandlerResolver默认返回DefaultNamespaceHandlerResolver对象，用来获取xsd对应的处理器。</p><p>XmlReaderContext的作用感觉就是这一堆参数的容器，糅合到一起传给DocumentReader，并美其名为Context。可以看出，Spring中到处都是策略模式，大量操作被抽象成接口。</p><p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doRegisterBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    <span class="comment">//默认的命名空间即</span></span><br><span class="line">    <span class="comment">//http://www.springframework.org/schema/beans</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">//检查profile属性</span></span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            <span class="comment">//profile属性可以以,分割</span></span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    postProcessXml(root);</span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delegate的作用在于处理beans标签的嵌套，其实Spring配置文件是可以写成这样的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"java.lang.Object"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>xml(schema)的命名空间其实类似于java的报名，命名空间采用URL，比如Spring的是这样:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>xmlns属性就是xml规范定义的用来设置命名空间的。这样设置了之后其实里面的bean元素全名就相当于<code>http://www.springframework.org/schema/beans:bean</code>，可以有效的防止命名冲突。命名空间可以通过规范定义的org.w3c.dom.Node.getNamespaceURI方法获得。</p><p>注意一下profile的检查, AbstractEnvironment.acceptsProfiles:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptsProfiles</span><span class="params">(String... profiles)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(profiles, <span class="string">"Must specify at least one profile"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String profile : profiles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(profile) &amp;&amp; profile.charAt(<span class="number">0</span>) == <span class="string">'!'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isProfileActive(profile.substring(<span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isProfileActive(profile)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理很简单，注意从源码可以看出，<strong>profile属性支持!取反</strong>。</p><p>preProcessXml方法是个空实现，供子类去覆盖，<strong>目的在于给子类一个把我们自定义的标签转为Spring标准标签的机会</strong>, 想的真周到。</p><p>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，对于非默认命名空间的元素交由delegate处理。</p><h4 id="默认命名空间解析"><a href="#默认命名空间解析" class="headerlink" title="默认命名空间解析"></a>默认命名空间解析</h4><p>即import, alias, bean, 嵌套的beans四种元素。parseDefaultElement:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//"import"</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// recurse</span></span><br><span class="line">        doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>写法示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"CTIContext.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"customerContext.xml"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>importBeanDefinitionResource套路和之前的配置文件加载完全一样，不过注意被import进来的文件是先于当前文件 被解析的。</p><h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><p>加入有一个bean名为componentA-dataSource，但是另一个组件想以componentB-dataSource的名字使用，就可以这样定义:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"componentA-dataSource"</span> <span class="attr">alias</span>=<span class="string">"componentB-dataSource"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>processAliasRegistration核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">    getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">    getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面的源码可以发现，registry其实就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口。registerAlias方法的实现在SimpleAliasRegistry:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">    Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</span><br><span class="line">    Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</span><br><span class="line">    <span class="comment">//名字和别名一样</span></span><br><span class="line">    <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">        <span class="comment">//ConcurrentHashMap</span></span><br><span class="line">        <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">        <span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">                <span class="comment">// An existing alias - no need to re-register</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException</span><br><span class="line">                    (<span class="string">"Cannot register alias '"</span> + alias + <span class="string">"' for name '"</span> +</span><br><span class="line">                    name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        checkForAliasCircle(name, alias);</span><br><span class="line">        <span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以别名关系的保存使用Map完成，key为别名，value为本来的名字。</p><h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><p>bean节点是Spring最最常见的节点了。</p><p>DefaultBeanDefinitionDocumentReader.processBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition</span><br><span class="line">                (bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="id-amp-name处理"><a href="#id-amp-name处理" class="headerlink" title="id &amp; name处理"></a>id &amp; name处理</h6><p>最终调用BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)，源码较长，分部分说明。</p><p>首先获取到id和name属性，<strong>name属性支持配置多个，以逗号分隔，如果没有指定id，那么将以第一个name属性值代替。id必须是唯一的，name属性其实是alias的角色，可以和其它的bean重复，如果name也没有配置，那么其实什么也没做</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    <span class="comment">//按,分隔</span></span><br><span class="line">    String[] nameArr = StringUtils.tokenizeToStringArray</span><br><span class="line">        (nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">    aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line">String beanName = id;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//name的第一个值作为id</span></span><br><span class="line">    beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//校验id是否已重复，如果重复直接抛异常</span></span><br><span class="line">    <span class="comment">//校验是通过内部一个HashSet完成的，出现过的id都会保存进此Set</span></span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="beanName生成"><a href="#beanName生成" class="headerlink" title="beanName生成"></a>beanName生成</h6><p>如果name和id属性都没有指定，那么Spring会自己生成一个, BeanDefinitionParserDelegate.parseBeanDefinitionElement:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">aliases.add(beanClassName);</span><br></pre></td></tr></table></figure><p>可见，Spring同时会把类名作为其别名。</p><p>最终调用的是BeanDefinitionReaderUtils.generateBeanName:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateBeanName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinition definition, BeanDefinitionRegistry registry, <span class="keyword">boolean</span> isInnerBean)</span> </span>&#123;</span><br><span class="line">    String generatedBeanName = definition.getBeanClassName();</span><br><span class="line">    <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (definition.getParentName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            generatedBeanName = definition.getParentName() + <span class="string">"$child"</span>;</span><br><span class="line">             <span class="comment">//工厂方法产生的bean</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (definition.getFactoryBeanName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            generatedBeanName = definition.getFactoryBeanName() + <span class="string">"$created"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String id = generatedBeanName;</span><br><span class="line">    <span class="keyword">if</span> (isInnerBean) &#123;</span><br><span class="line">        <span class="comment">// Inner bean: generate identity hashcode suffix.</span></span><br><span class="line">        id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + </span><br><span class="line">            ObjectUtils.getIdentityHexString(definition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Top-level bean: use plain class name.</span></span><br><span class="line">        <span class="comment">// Increase counter until the id is unique.</span></span><br><span class="line">        <span class="keyword">int</span> counter = -<span class="number">1</span>;</span><br><span class="line">         <span class="comment">//用类名#自增的数字命名</span></span><br><span class="line">        <span class="keyword">while</span> (counter == -<span class="number">1</span> || registry.containsBeanDefinition(id)) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">            id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="bean解析"><a href="#bean解析" class="headerlink" title="bean解析"></a>bean解析</h6><p>还是分部分说明(parseBeanDefinitionElement)。</p><p>首先获取到bean的class属性和parent属性，配置了parent之后，当前bean会继承父bean的属性。之后根据class和parent创建BeanDefinition对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">    className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line">String parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">    parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br></pre></td></tr></table></figure><p>BeanDefinition的创建在BeanDefinitionReaderUtils.createBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String parentName, String className, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">    bd.setParentName(parentName);</span><br><span class="line">    <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bd.setBeanClassName(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后是解析bean的其它属性，其实就是读取其配置，调用相应的setter方法保存在BeanDefinition中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br></pre></td></tr></table></figure><p>之后解析bean的decription子元素:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">name</span>=<span class="string">"one, two"</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SimpleBean<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就仅仅是个描述。</p><p>然后是meta子元素的解析，meta元素在xml配置文件里是这样的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">name</span>=<span class="string">"one, two"</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注释上说，这样可以将任意的元数据附到对应的bean definition上。解析过程源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMetaElements</span><span class="params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> </span>&#123;</span><br><span class="line">    NodeList nl = ele.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">            Element metaElement = (Element) node;</span><br><span class="line">            String key = metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">            String value = metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">             <span class="comment">//就是一个key, value的载体，无他</span></span><br><span class="line">            BeanMetadataAttribute attribute = <span class="keyword">new</span> BeanMetadataAttribute(key, value);</span><br><span class="line">             <span class="comment">//sourceExtractor默认是NullSourceExtractor，返回的是空</span></span><br><span class="line">            attribute.setSource(extractSource(metaElement));</span><br><span class="line">            attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractBeanDefinition继承自BeanMetadataAttributeAccessor类，底层使用了一个LinkedHashMap保存metadata。这个metadata具体是做什么暂时还不知道。</p><p>lookup-method解析：</p><p>此标签的作用在于当一个bean的某个方法被设置为lookup-method后，<strong>每次调用此方法时，都会返回一个新的指定bean的对象</strong>。用法示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"apple"</span> <span class="attr">class</span>=<span class="string">"cn.com.willchen.test.di.Apple"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--水果盘--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"fruitPlate"</span> <span class="attr">class</span>=<span class="string">"cn.com.willchen.test.di.FruitPlate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getFruit"</span> <span class="attr">bean</span>=<span class="string">"apple"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据保存在Set中，对应的类是MethodOverrides。可以参考:</p><p><a href="http://www.cnblogs.com/ViviChan/p/4981619.html" target="_blank" rel="noopener">Spring - lookup-method方式实现依赖注入</a></p><p>replace-mothod解析:</p><p>此标签用于替换bean里面的特定的方法实现，替换者必须实现Spring的MethodReplacer接口，有点像aop的意思。</p><p>配置文件示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"replacer"</span> <span class="attr">class</span>=<span class="string">"springroad.deomo.chap4.MethodReplace"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"springroad.deomo.chap4.LookupMethodBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">replacer</span>=<span class="string">"replacer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span> <span class="attr">match</span>=<span class="string">"String"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>arg-type的作用是指定替换方法的参数类型，因为接口的定义参数都是Object的。参考: <a href="http://blog.csdn.net/lee576/article/details/8725548" target="_blank" rel="noopener">SPRING.NET 1.3.2 学习20–方法注入之替换方法注入</a></p><p>解析之后将数据放在ReplaceOverride对象中，里面有一个LinkedList<string>专门用于保存arg-type。</string></p><p>构造参数(constructor-arg)解析:</p><p>作用一目了然，使用示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>Cat<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>type一般不需要指定，除了泛型集合那种。除此之外，constructor-arg还支持name, index, ref等属性，可以具体的指定参数的位置等。构造参数解析后保存在BeanDefinition内部一个ConstructorArgumentValues对象中。如果设置了index属性，那么以Map&lt;Integer, ValueHolder&gt;的形式保存，反之，以List<valueholder>的形式保存。</valueholder></p><p>property解析:</p><p>非常常用的标签，用以为bean的属性赋值，支持value和ref两种形式，示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>value和ref属性不能同时出现，如果是ref，那么将其值保存在不可变的RuntimeBeanReference对象中，其实现了BeanReference接口，此接口只有一个getBeanName方法。如果是value，那么将其值保存在TypedStringValue对象中。最终将对象保存在BeanDefinition内部一个MutablePropertyValues对象中(内部以ArrayList实现)。</p><p>qualifier解析:</p><p>配置示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"12"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"org.springframework.beans.factory.annotation.Qualifier"</span> <span class="attr">value</span>=<span class="string">"student"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"seaswalker"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">"student_2"</span>&gt;</span><span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>SimpleBean部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">private</span> Student student;</span><br></pre></td></tr></table></figure><p>此标签和@Qualifier, @Autowired两个注解一起使用才有作用。@Autowired注解采用按类型查找的方式进行注入，如果找到多个需要类型的bean便会报错，有了@Qualifier标签就可以再按照此注解指定的名称查找。两者结合相当于实现了按类型+名称注入。type属性可以不指定，因为默认就是那个。qualifier标签可以有attribute子元素，比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"org.springframework.beans.factory.annotation.Qualifier"</span> <span class="attr">value</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br></pre></td></tr></table></figure><p>貌似是用来在qualifier也区分不开的时候使用。attribute键值对保存在BeanMetadataAttribute对象中。整个qualifier保存在AutowireCandidateQualifier对象中。</p><h6 id="Bean装饰"><a href="#Bean装饰" class="headerlink" title="Bean装饰"></a>Bean装饰</h6><p>这部分是针对其它schema的属性以及子节点，比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.Student"</span> <span class="attr">primary</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-override</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没见过这种用法，留个坑。</p><h6 id="Bean注册"><a href="#Bean注册" class="headerlink" title="Bean注册"></a>Bean注册</h6><p>BeanDefinitionReaderUtils.registerBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registry其实就是DefaultListableBeanFactory对象，registerBeanDefinition方法主要就干了这么两件事:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是Map，另一个是List，一目了然。registerAlias方法的实现在其父类SimpleAliasRegistry，就是把键值对放在了一个ConcurrentHashMap里。</p><p>ComponentRegistered事件触发:</p><p>默认是个空实现，前面说过了。</p><h6 id="BeanDefiniton数据结构"><a href="#BeanDefiniton数据结构" class="headerlink" title="BeanDefiniton数据结构"></a>BeanDefiniton数据结构</h6><p>BeanDefiniton数据结构如下图:</p><p><img src="/uploads/spring/images/BeanDefinition.jpg" alt="BeanDefinition数据结构"></p><h5 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h5><p>beans元素的嵌套直接递归调用DefaultBeanDefinitionDocumentReader.parseBeanDefinitions。</p><h4 id="其它命名空间解析"><a href="#其它命名空间解析" class="headerlink" title="其它命名空间解析"></a>其它命名空间解析</h4><p>入口在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions-&gt;BeanDefinitionParserDelegate.parseCustomElement(第二个参数为空):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">    String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">    NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamespaceHandlerResolver由XmlBeanDefinitionReader初始化，是一个DefaultNamespaceHandlerResolver对象，也是NamespaceHandlerResolver接口的唯一实现。</p><p>其resolve方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">    Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">        <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String className = (String) handlerOrClassName;</span><br><span class="line">        Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line">        NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">        namespaceHandler.init();</span><br><span class="line">        handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">        <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易看出，Spring其实使用了一个Map了保存其映射关系，key就是命名空间的uri，value是<strong>NamespaceHandler对象或是Class完整名，如果发现是类名，那么用反射的方法进行初始化，如果是NamespaceHandler对象，那么直接返回</strong>。</p><p>NamespaceHandler映射关系来自于各个Spring jar包下的META-INF/spring.handlers文件，以spring-context包为例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></table></figure><h5 id="NamespaceHandler继承体系"><a href="#NamespaceHandler继承体系" class="headerlink" title="NamespaceHandler继承体系"></a>NamespaceHandler继承体系</h5><p><img src="/upload/2019/1/NamespaceHandler20190216153833238.jpg" alt="NamespaceHandler继承体系"></p><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>resolve中调用了其init方法，此方法用以向NamespaceHandler对象注册BeanDefinitionParser对象。<strong>此接口用以解析顶层(beans下)的非默认命名空间元素，比如<code>&lt;context:annotation-config /&gt;</code></strong>。</p><p>所以这样逻辑就很容易理解了: <strong>每种子标签的解析仍是策略模式的体现，init负责向父类NamespaceHandlerSupport注册不同的策略，由父类的NamespaceHandlerSupport.parse方法根据具体的子标签调用相应的策略完成解析的过程</strong>。</p><p>此部分较为重要，所以重新开始大纲。</p><h5 id="BeanFactory数据结构"><a href="#BeanFactory数据结构" class="headerlink" title="BeanFactory数据结构"></a>BeanFactory数据结构</h5><p>BeanDefinition在BeanFactory中的主要数据结构如下图:</p><p><img src="/upload/2019/1/Beanfactory_structure20190216153904330.jpg" alt="Beanfactory数据结构"></p><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><p>此方法负责对BeanFactory进行一些特征的设置工作，”特征”包含这么几个方面:</p><h4 id="BeanExpressionResolver"><a href="#BeanExpressionResolver" class="headerlink" title="BeanExpressionResolver"></a>BeanExpressionResolver</h4><p>此接口只有一个实现: StandardBeanExpressionResolver。接口只含有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">evaluate</span><span class="params">(String value, BeanExpressionContext evalContext)</span></span></span><br></pre></td></tr></table></figure><p>prepareBeanFactory将一个此对象放入BeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span>  StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br></pre></td></tr></table></figure><p>StandardBeanExpressionResolver对象内部有一个关键的成员: SpelExpressionParser,其整个类图:</p><p><img src="/upload/2019/1/ExpressionParser20190216153944300.jpg" alt="ExpressionParser继承体系"></p><p>这便是Spring3.0开始出现的Spel表达式的解释器。</p><h4 id="PropertyEditorRegistrar"><a href="#PropertyEditorRegistrar" class="headerlink" title="PropertyEditorRegistrar"></a>PropertyEditorRegistrar</h4><p>此接口用于向Spring注册java.beans.PropertyEditor，只有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerCustomEditors(PropertyEditorRegistry registry)</span><br></pre></td></tr></table></figure><p>实现也只有一个: ResourceEditorRegistrar。</p><p>在编写xml配置时，我们设置的值都是字符串形式，所以在使用时肯定需要转为我们需要的类型，PropertyEditor接口正是定义了这么个东西。</p><p>prepareBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br></pre></td></tr></table></figure><p>BeanFactory也暴露了registerCustomEditors方法用以添加自定义的转换器，所以这个地方是组合模式的体现。</p><p>我们有两种方式可以添加自定义PropertyEditor:</p><ul><li><p>通过<code>context.getBeanFactory().registerCustomEditor</code></p></li><li><p>通过Spring配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customEditors"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"base.Cat"</span> <span class="attr">value</span>=<span class="string">"base.CatEditor"</span> /&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考: <a href="http://blog.csdn.net/zhoudaxia/article/details/36247883" target="_blank" rel="noopener">深入理解JavaBean(2)：属性编辑器PropertyEditor</a></p><h4 id="环境注入"><a href="#环境注入" class="headerlink" title="环境注入"></a>环境注入</h4><p>在Spring中我们自己的bean可以通过实现EnvironmentAware等一系列Aware接口获取到Spring内部的一些对象。prepareBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>ApplicationContextAwareProcessor核心的invokeAwareInterfaces方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">            ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="依赖解析忽略"><a href="#依赖解析忽略" class="headerlink" title="依赖解析忽略"></a>依赖解析忽略</h4><p>此部分设置哪些接口在进行依赖注入的时候应该被忽略:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br></pre></td></tr></table></figure><h4 id="bean伪装"><a href="#bean伪装" class="headerlink" title="bean伪装"></a>bean伪装</h4><p>有些对象并不在BeanFactory中，但是我们依然想让它们可以被装配，这就需要伪装一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>伪装关系保存在一个<code>Map&lt;Class&lt;?&gt;, Object&gt;</code>里。</p><h4 id="LoadTimeWeaver"><a href="#LoadTimeWeaver" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h4><p>如果配置了此bean，那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个东西具体是干什么的在后面context:load-time-weaver中说明。</p><h4 id="注册环境"><a href="#注册环境" class="headerlink" title="注册环境"></a>注册环境</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().</span><br><span class="line">        getSystemEnvironment());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>containsLocalBean特殊之处在于不会去父BeanFactory寻找。</p><h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>此方法允许子类在所有的bean尚未初始化之前注册BeanPostProcessor。空实现且没有子类覆盖。</p><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>BeanFactoryPostProcessor接口允许我们在bean正是初始化之前改变其值。此接口只有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span>;</span><br></pre></td></tr></table></figure><p>有两种方式可以向Spring添加此对象:</p><ul><li><p>通过代码的方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.addBeanFactoryPostProcessor</span><br></pre></td></tr></table></figure></li><li><p>通过xml配置的方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBeanFactoryPostProcessor"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>注意此时尚未进行bean的初始化工作，初始化是在后面的finishBeanFactoryInitialization进行的，所以在BeanFactoryPostProcessor对象中获取bean会导致提前初始化。</p><p>此方法的关键源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory,</span><br><span class="line">        getBeanFactoryPostProcessors());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBeanFactoryPostProcessors获取的就是AbstractApplicationContext的成员beanFactoryPostProcessors(ArrayList)，但是很有意思，<strong>只有通过context.addBeanFactoryPostProcessor这种方式添加的才会出现在这个List里，所以对于xml配置方式，此List其实没有任何元素。玄机就在PostProcessorRegistrationDelegate里</strong>。</p><p>核心思想就是使用BeanFactory的getBeanNamesForType方法获取相应的BeanDefinition的name数组，之后逐一调用getBean方法获取到bean(初始化)，getBean方法后面再说。</p><p>注意此处有一个优先级的概念，如果你的BeanFactoryPostProcessor同时实现了Ordered或者是PriorityOrdered接口，那么会被首先执行。</p><h3 id="BeanPostProcessor注册"><a href="#BeanPostProcessor注册" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h3><p>此部分实质上是在BeanDefinitions中寻找BeanPostProcessor，之后调用BeanFactory.addBeanPostProcessor方法保存在一个List中，注意添加时仍然有优先级的概念，优先级高的在前面。</p><h3 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h3><p>此接口用以支持Spring国际化。继承体系如下:</p><p><img src="/upload/2019/1/MessageSource2019021615404914.jpg" alt="MessageSource继承体系"></p><p>AbstractApplicationContext的initMessageSource()方法就是在BeanFactory中查找MessageSource的bean，如果配置了此bean，那么调用getBean方法完成其初始化并将其保存在AbstractApplicationContext内部messageSource成员变量中，用以处理ApplicationContext的getMessage调用，因为从继承体系上来看，ApplicationContext是MessageSource的子类，此处是委托模式的体现。如果没有配置此bean，那么初始化一个DelegatingMessageSource对象，此类是一个空实现，同样用以处理getMessage调用请求。</p><p>参考: <a href="http://stamen.iteye.com/blog/1541732" target="_blank" rel="noopener">学习Spring必学的Java基础知识(8)—-国际化信息</a></p><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>此接口代表了Spring的事件驱动(监听器)模式。一个事件驱动包含三部分:</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>java的所有事件对象一般都是java.util.EventObject的子类，Spring的整个继承体系如下:</p><p><img src="/upload/2019/1/EventObject20190216154539941.jpg" alt="EventObject继承体系"></p><h4 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h4><h5 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h5><p><img src="/upload/2019/1/ApplicationEventPublisher20190216154621676.jpg" alt="ApplicationEventPublisher继承体系"></p><p>一目了然。</p><h5 id="ApplicationEventMulticaster"><a href="#ApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster"></a>ApplicationEventMulticaster</h5><p>ApplicationEventPublisher实际上正是将请求委托给ApplicationEventMulticaster来实现的。其继承体系:</p><p><img src="/upload/2019/1/ApplicationEventMulticaster201902161546589.jpg" alt="ApplicationEventMulticaster继承体系"></p><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>所有的监听器是jdk EventListener的子类，这是一个mark接口。继承体系:</p><p><img src="/upload/2019/1/EventListener20190216154742511.jpg" alt="EventListener继承体系"></p><p>可以看出SmartApplicationListener和GenericApplicationListener是高度相似的，都提供了事件类型检测和顺序机制，而后者是从Spring4.2加入的，Spring官方文档推荐使用后者代替前者。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>前面说过ApplicationEventPublisher是通过委托给ApplicationEventMulticaster实现的，所以refresh方法中完成的是对ApplicationEventMulticaster的初始化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br></pre></td></tr></table></figure><p>initApplicationEventMulticaster则首先在BeanFactory中寻找ApplicationEventMulticaster的bean，如果找到，那么调用getBean方法将其初始化，如果找不到那么使用SimpleApplicationEventMulticaster。</p><h4 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h4><p>AbstractApplicationContext.publishEvent核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleApplicationEventMulticaster.multicastEvent:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        Executor executor = getTaskExecutor();</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    invokeListener(listener, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="监听器获取"><a href="#监听器获取" class="headerlink" title="监听器获取"></a>监听器获取</h5><p>获取当然还是通过beanFactory的getBean来完成的，值得注意的是Spring在此处使用了缓存(ConcurrentHashMap)来加速查找的过程。</p><h5 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h5><p>可以看出，如果executor不为空，那么监听器的执行实际上是异步的。那么如何配置同步/异步呢?</p><h6 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"multicasterExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.event.SimpleApplicationEventMulticaster"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"taskExecutor"</span> <span class="attr">ref</span>=<span class="string">"multicasterExecutor"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>task schema是Spring从3.0开始加入的，使我们可以不再依赖于Quartz实现定时任务，源码在org.springframework.core.task包下，使用需要引入schema：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task"</span><br><span class="line">xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd"</span><br></pre></td></tr></table></figure><p>可以参考: <a href="http://gong1208.iteye.com/blog/1773177" target="_blank" rel="noopener">Spring定时任务的几种实现</a></p><h6 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h6><p>开启注解支持:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启@AspectJ AOP代理 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 任务调度器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 任务执行器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"executor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--开启注解调度支持 @Async @Scheduled--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"executor"</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在代码中使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailRegisterListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">RegisterEvent</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(<span class="keyword">final</span> RegisterEvent event)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"注册成功，发送确认邮件给："</span> + ((User)event.getSource()).getUsername());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考: <a href="http://jinnianshilongnian.iteye.com/blog/1902886" target="_blank" rel="noopener">详解Spring事件驱动模型</a></p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>这又是一个模版方法，允许子类在进行bean初始化之前进行一些定制操作。默认空实现。</p><h3 id="ApplicationListener注册"><a href="#ApplicationListener注册" class="headerlink" title="ApplicationListener注册"></a>ApplicationListener注册</h3><p>registerListeners方法干的，没什么好说的。</p><h3 id="singleton初始化"><a href="#singleton初始化" class="headerlink" title="singleton初始化"></a>singleton初始化</h3><p>finishBeanFactoryInitialization：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType</span><br><span class="line">        (LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分部分说明。</p><h4 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h4><p>此接口用于类型之间的转换，在Spring里其实就是把配置文件中的String转为其它类型，从3.0开始出现，目的和jdk的PropertyEditor接口是一样的，参考ConfigurableBeanFactory.setConversionService注释:</p><blockquote><blockquote><p>Specify a Spring 3.0 ConversionService to use for converting<br>property values, as an alternative to JavaBeans PropertyEditors.<br>@since 3.0</p></blockquote></blockquote><h4 id="StringValueResolver"><a href="#StringValueResolver" class="headerlink" title="StringValueResolver"></a>StringValueResolver</h4><p>用于解析注解的值。接口只定义了一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h4><p>实现了此接口的bean可以得到LoadTimeWeaver，此处仅仅初始化。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>DefaultListableBeanFactory.preInstantiateSingletons:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX </span><br><span class="line">                    + beanName);</span><br><span class="line">                <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                    isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                            ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = </span><br><span class="line">                (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先进行Singleton的初始化，其中如果bean是FactoryBean类型(注意，只定义了factory-method属性的普通bean并不是FactoryBean)，并且还是SmartFactoryBean类型，那么需要判断是否需要eagerInit(isEagerInit是此接口定义的方法)。</p><h1 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h1><p>这里便是bean初始化的核心逻辑。源码比较复杂，分开说。以getBean(String name)为例。AbstractBeanFactory.getBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数表示bean的Class类型，第三个表示创建bean需要的参数，最后一个表示不需要进行类型检查。</p><h2 id="beanName转化"><a href="#beanName转化" class="headerlink" title="beanName转化"></a>beanName转化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br></pre></td></tr></table></figure><p>这里是将FactoryBean的前缀去掉以及将别名转为真实的名字。</p><h2 id="手动注册bean检测"><a href="#手动注册bean检测" class="headerlink" title="手动注册bean检测"></a>手动注册bean检测</h2><p>前面注册环境一节说过，Spring其实手动注册了一些单例bean。这一步就是检测是不是这些bean。如果是，那么再检测是不是工厂bean，如果是返回其工厂方法返回的实例，如果不是返回bean本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查父容器"><a href="#检查父容器" class="headerlink" title="检查父容器"></a>检查父容器</h2><p>如果父容器存在并且存在此bean定义，那么交由其父容器初始化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">    <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">    <span class="comment">//此方法其实是做了前面beanName转化的逆操作，因为父容器同样会进行转化操作</span></span><br><span class="line">    String nameToLookup = originalBeanName(name);</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖初始化"><a href="#依赖初始化" class="headerlink" title="依赖初始化"></a>依赖初始化</h2><p>bean可以由depends-on属性配置依赖的bean。Spring会首先初始化依赖的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">         <span class="comment">//检测是否存在循环依赖</span></span><br><span class="line">        <span class="keyword">if</span> (isDependent(beanName, dependsOnBean)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dependsOnBean + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">        getBean(dependsOnBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerDependentBean进行了依赖关系的注册，这么做的原因是Spring在即进行bean销毁的时候会首先销毁被依赖的bean。依赖关系的保存是通过一个ConcurrentHashMap&lt;String, Set<string>&gt;完成的，key是bean的真实名字。</string></p><h2 id="Singleton初始化"><a href="#Singleton初始化" class="headerlink" title="Singleton初始化"></a>Singleton初始化</h2><p>虽然这里大纲是Singleton初始化，但是getBean方法本身是包括所有scope的初始化，在这里一次说明了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getSingleton方法"><a href="#getSingleton方法" class="headerlink" title="getSingleton方法"></a>getSingleton方法</h3><h4 id="是否存在"><a href="#是否存在" class="headerlink" title="是否存在"></a>是否存在</h4><p>首先会检测是否已经存在，如果存在，直接返回:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的单例bean都保存在这样的数据结构中: <code>ConcurrentHashMap&lt;String, Object&gt;</code>。</p><h4 id="bean创建"><a href="#bean创建" class="headerlink" title="bean创建"></a>bean创建</h4><p>源码位于AbstractAutowireCapableBeanFactory.createBean，主要分为几个部分:</p><h5 id="lookup-method检测"><a href="#lookup-method检测" class="headerlink" title="lookup-method检测"></a>lookup-method检测</h5><p>此部分用于检测lookup-method标签配置的方法是否存在:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br></pre></td></tr></table></figure><p>prepareMethodOverrides:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">    <span class="comment">// Check that lookup methods exists.</span></span><br><span class="line">    MethodOverrides methodOverrides = getMethodOverrides();</span><br><span class="line">    <span class="keyword">if</span> (!methodOverrides.isEmpty()) &#123;</span><br><span class="line">        Set&lt;MethodOverride&gt; overrides = methodOverrides.getOverrides();</span><br><span class="line">        <span class="keyword">synchronized</span> (overrides) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MethodOverride mo : overrides) &#123;</span><br><span class="line">                prepareMethodOverride(mo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepareMethodOverride:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareMethodOverride</span><span class="params">(MethodOverride mo)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(</span><br><span class="line">                <span class="string">"Invalid method override: no method with name '"</span> + mo.getMethodName() +</span><br><span class="line">                <span class="string">"' on class ["</span> + getBeanClassName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Mark override as not overloaded, to avoid the overhead of arg type checking.</span></span><br><span class="line">        mo.setOverloaded(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="InstantiationAwareBeanPostProcessor触发"><a href="#InstantiationAwareBeanPostProcessor触发" class="headerlink" title="InstantiationAwareBeanPostProcessor触发"></a>InstantiationAwareBeanPostProcessor触发</h5><p>在这里触发的是其postProcessBeforeInitialization和postProcessAfterInstantiation方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br></pre></td></tr></table></figure><p>继续:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，<strong>如果InstantiationAwareBeanPostProcessor返回的不是空，那么将不会继续执行剩下的Spring初始化流程，此接口用于初始化自定义的bean，主要是在Spring内部使用</strong>。</p><h5 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h5><p>同样分为几部分。</p><h6 id="创建-createBeanInstance"><a href="#创建-createBeanInstance" class="headerlink" title="创建(createBeanInstance)"></a>创建(createBeanInstance)</h6><p>关键代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBeanInstance的创建过程又分为以下几种情况:</p><ul><li><p>工厂bean:</p><p>调用instantiateUsingFactoryMethod方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, RootBeanDefinition mbd, Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，此处的工厂bean指的是配置了factory-bean/factory-method属性的bean，不是实现了FacrotyBean接口的bean。如果没有配置factory-bean属性，那么factory-method指向的方法必须是静态的。此方法主要做了这么几件事:</p><ul><li><p>初始化一个BeanWrapperImpl对象。</p></li><li><p>根据设置的参数列表使用反射的方法寻找相应的方法对象。</p></li><li><p>InstantiationStrategy:</p><p>bean的初始化在此处又抽成了策略模式，类图:</p><p><img src="/uploads/spring/images/InstantiationStrategy.jpg" alt="InstantiationStrategy类图"></p><p>instantiateUsingFactoryMethod部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beanInstance = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">    mbd, beanName, <span class="keyword">this</span>.beanFactory, factoryBean, factoryMethodToUse, argsToUse);</span><br></pre></td></tr></table></figure><p>getInstantiationStrategy返回的是CglibSubclassingInstantiationStrategy对象。此处instantiate实现也很简单，就是调用工厂方法的Method对象反射调用其invoke即可得到对象，SimpleInstantiationStrategy.</p><p>instantiate核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object factoryBean, <span class="keyword">final</span> Method factoryMethod, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factoryMethod.invoke(factoryBean, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>构造器自动装配</p><p>createBeanInstance部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Need to determine the constructor...</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">  mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">    <span class="comment">//配置了&lt;constructor-arg&gt;子元素</span></span><br><span class="line">  mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">  <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>determineConstructorsFromBeanPostProcessors源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">  <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">              SmartInstantiationAwareBeanPostProcessor ibp = </span><br><span class="line">                  (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">              Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">              <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> ctors;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见是由SmartInstantiationAwareBeanPostProcessor决定的，默认是没有配置这种东西的。</p><p>之后就是判断bean的自动装配模式，可以通过如下方式配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span> <span class="attr">primary</span>=<span class="string">"true"</span> <span class="attr">autowire</span>=<span class="string">"default"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>autowire共有以下几种选项:</p><ul><li>no: 默认的，不进行自动装配。在这种情况下，只能通过ref方式引用其它bean。</li><li>byName: 根据bean里面属性的名字在BeanFactory中进行查找并装配。</li><li>byType: 按类型。</li><li>constructor: 以byType的方式查找bean的构造参数列表。</li><li>default: 由父bean决定。</li></ul><p>参考: <a href="http://www.cnblogs.com/ViviChan/p/4981539.html" target="_blank" rel="noopener">Spring - bean的autowire属性(自动装配)</a></p><p>autowireConstructor调用的是ConstructorResolver.autowireConstructor，此方法主要做了两件事:</p><ul><li><p>得到合适的构造器对象。</p></li><li><p>根据构造器参数的类型去BeanFactory查找相应的bean:</p><p>入口方法在ConstructorResolver.resolveAutowiredArgument:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveAutowiredArgument</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        MethodParameter param, String beanName, Set&lt;String&gt; autowiredBeanNames, </span></span></span><br><span class="line"><span class="function"><span class="params">        TypeConverter typeConverter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.resolveDependency(</span><br><span class="line">            <span class="keyword">new</span> DependencyDescriptor(param, <span class="keyword">true</span>), beanName, </span><br><span class="line">            autowiredBeanNames, typeConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终调用的还是CglibSubclassingInstantiationStrategy.instantiate方法，关键源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">           <span class="comment">//反射调用</span></span><br><span class="line">      <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果配置了lookup-method标签，<strong>得到的实际上是用Cglib生成的目标类的代理子类</strong>。</p><p>CglibSubclassingInstantiationStrategy.instantiateWithMethodInjection:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Must generate CGLIB subclass...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CglibSubclassCreator(bd, owner).instantiate(ctor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认构造器</p><p>一行代码，很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br></pre></td></tr></table></figure></li></ul><h6 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h6><p>触发源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">        mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口也是Spring内部使用的，不管它了。</p><h6 id="属性解析"><a href="#属性解析" class="headerlink" title="属性解析"></a>属性解析</h6><p>入口方法: AbstractAutowireCapableBeanFactory.populateBean，它的作用是: 根据autowire类型进行autowire by name，by type 或者是直接进行设置，简略后的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有&lt;property&gt;的值</span></span><br><span class="line">    PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设值</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autowireByName源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回所有引用(ref="XXX")的bean名称</span></span><br><span class="line">    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">             <span class="comment">//从BeanFactory获取</span></span><br><span class="line">            Object bean = getBean(propertyName);</span><br><span class="line">            pvs.add(propertyName, bean);</span><br><span class="line">            registerDependentBean(propertyName, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autowireByType也是同样的套路，所以可以得出结论: <strong>autowireByName和autowireByType方法只是先获取到引用的bean，真正的设值是在applyPropertyValues中进行的。</strong></p><h6 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h6><p>Spring判断一个属性可不可以被设置(存不存在)是通过java bean的内省操作来完成的，也就是说，属性可以被设置的条件是<strong>此属性拥有public的setter方法，并且注入时的属性名应该是setter的名字</strong>。</p><h6 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h6><p>此处的初始化指的是bean已经构造完成，执行诸如调用其init方法的操作。相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initializeBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的操作步骤一目了然。</p><ul><li><p>Aware方法触发:</p><p>我们的bean有可能实现了一些XXXAware接口，此处就是负责调用它们:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">          ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">          ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">          ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BeanPostProcessor触发，没什么好说的</p></li><li><p>调用init方法:</p><p>在XML配置中，bean可以有一个init-method属性来指定初始化时调用的方法。从原理来说，其实就是一个反射调用。不过注意这里有一个InitializingBean的概念。</p><p>此接口只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>如果我们的bean实现了此接口，那么此方法会首先被调用。此接口的意义在于: 当此bean的所有属性都被设置(注入)后，给bean一个利用现有属性重新组织或是检查属性的机会。感觉和init方法有些冲突，不过此接口在Spring被广泛使用。</p></li></ul><h3 id="getObjectForBeanInstance"><a href="#getObjectForBeanInstance" class="headerlink" title="getObjectForBeanInstance"></a>getObjectForBeanInstance</h3><p>位于AbstractBeanFactory，此方法的目的在于如果bean是FactoryBean，那么返回其工厂方法创建的bean，而不是自身。</p><h2 id="Prototype初始化"><a href="#Prototype初始化" class="headerlink" title="Prototype初始化"></a>Prototype初始化</h2><p>AbstractBeanFactory.doGetBean相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">    <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">    Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="beforePrototypeCreation"><a href="#beforePrototypeCreation" class="headerlink" title="beforePrototypeCreation"></a>beforePrototypeCreation</h3><p>此方法用于确保在同一时刻只能有一个此bean在初始化。</p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>和单例的是一样的，不在赘述。</p><h3 id="afterPrototypeCreation"><a href="#afterPrototypeCreation" class="headerlink" title="afterPrototypeCreation"></a>afterPrototypeCreation</h3><p>和beforePrototypeCreation对应的，你懂的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看出，初始化其实和单例是一样的，只不过单例多了一个是否已经存在的检查。</p><h2 id="其它Scope初始化"><a href="#其它Scope初始化" class="headerlink" title="其它Scope初始化"></a>其它Scope初始化</h2><p>其它就指的是request、session。此部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    String scopeName = mbd.getScope();</span><br><span class="line">    <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">    <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scopes是一个LinkedHashMap&lt;String, Scope&gt;，可以调用 ConfigurableBeanFactory定义的registerScope方法注册其值。</p><p>Scope接口继承体系:</p><p><img src="/upload/2019/1/Scope20190216155031766.jpg" alt="Scope继承体系"></p><p>根据socpe.get的注释，此方法如果找到了叫做beanName的bean，那么返回，如果没有，将调用ObjectFactory创建之。Scope的实现参考类图。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h1&gt;&lt;p&gt;本部分从最基本的Spring开始。配置文件:&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;base.SimpleBean&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;启动代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ClassPathXmlApplicationContext context = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span class=&quot;string&quot;&gt;&quot;config.xml&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SimpleBean bean = context.getBean(SimpleBean.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bean.send();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    context.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="spring" scheme="https://duia.github.io/categories/JAVA/spring/"/>
    
      <category term="源码阅读" scheme="https://duia.github.io/categories/JAVA/spring/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="源码阅读" scheme="https://duia.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="spring" scheme="https://duia.github.io/tags/spring/"/>
    
  </entry>
  
</feed>
