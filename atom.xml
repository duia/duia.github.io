<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://duia.github.io/"/>
  <updated>2019-05-23T12:00:00.006Z</updated>
  <id>https://duia.github.io/</id>
  
  <author>
    <name>W鹏程</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流</title>
    <link href="https://duia.github.io/2019/05/16/Sentinel%20+%20Zookeeper%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%20+%20Springboot%E5%AE%A2%E6%88%B7%E7%AB%AF%20+%20%E9%9B%86%E7%BE%A4%E9%99%90%E6%B5%81/"/>
    <id>https://duia.github.io/2019/05/16/Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流/</id>
    <published>2019-05-16T11:45:00.000Z</published>
    <updated>2019-05-23T12:00:00.006Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/9434884/43697219-3cb4ef3a-9975-11e8-9a9c-73f4f537442d.png" alt="Sentinel Logo"></p><h1 id="Sentinel-分布式系统的流量防卫兵"><a href="#Sentinel-分布式系统的流量防卫兵" class="headerlink" title="Sentinel: 分布式系统的流量防卫兵"></a>Sentinel: 分布式系统的流量防卫兵</h1><h2 id="Sentinel-是什么？"><a href="#Sentinel-是什么？" class="headerlink" title="Sentinel 是什么？"></a>Sentinel 是什么？</h2><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>快速上手可以参照官网给出的<a href="https://github.com/alibaba/Sentinel/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">新手指南</a>进行尝试了解。</p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5" target="_blank" rel="noopener">详细介绍</a></p><p>本文主要对实际开发中遇到的问题，以及官网推荐的使用方式进行整合的过程遇到的问题进行整理。</p><h2 id="Sentinel-Zookeeper动态数据源-Springboot客户端-集群限流"><a href="#Sentinel-Zookeeper动态数据源-Springboot客户端-集群限流" class="headerlink" title="Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流"></a>Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流</h2><p>控制台可以使用官方给提供的jar，springboot项目最快的集成过程可以参考<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/wiki/Sentinel" target="_blank" rel="noopener">Spring Cloud Alibaba Sentinel</a>，也可以看我如下整理的代码进行快速集成使用。</p><h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><p>下载官方提供的Sentinel 控制台jar，参考<a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0" target="_blank" rel="noopener">Sentinel 控制台</a>进行启动，其实就是普通的springboot项目，可以指定自己的启动参数，自行启动，不再赘诉。</p><p>首次启动登陆，左边的菜单和右边的内容为空，别急，因为我们还没有接入客户端。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在要接入Sentinel的springboot项目的pom.xml添加如下代码，放到适合的位置。<code>spring-cloud-starter-alibaba-sentinel</code>包含了所有官网提供能的关于sentinel的组件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springboot 1.x 用0.1.2.RELEASE  springboot 2.x 用0.2.2.RELEASE--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>application.properties中添加一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.sentinel.transport.dashboard=localhost:8080</span><br></pre></td></tr></table></figure></p><p>集成完成。</p><p>启动我们项目进行访问。返回Sentinel 控制台即可看到如下界面。</p><p><img src="https://github.com/alibaba/Sentinel/wiki/image/resourceTree.png" alt="簇点链路"></p><p>每个url都是我们刚才访问过的路径，对于Sentinel称之为资源，即我们可以对该资源进行限流等的操作。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>Sentinel定义资源分为5种，具体可以查看<a href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">定义资源</a>，我们可以根据业务的需要进行资源的选择。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>Sentinel<a href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E8%A7%84%E5%88%99%E7%9A%84%E7%A7%8D%E7%B1%BB" target="_blank" rel="noopener">规则的种类</a>如下图，有5种规则供我们使用。</p><p><img src="https://user-images.githubusercontent.com/9434884/48189045-2ae58400-e37a-11e8-84aa-2e2c0dd042e2.png" alt="规则管理"></p><p>以上是最基本的配置，如果不做任何修改，Dashboard的推送规则方式是通过 API 将规则推送至客户端并直接更新到内存中：</p><p><img src="https://camo.githubusercontent.com/96b07d598c9eee5a513801cecc68f266fbe58d14/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f34373638382f313533363636303239363237332d34663434306262612d356239652d343230352d393430322d6662363038336236363931322e706e67" alt></p><p>此模式为原始模式，<strong>缺点</strong>是每次重启客户端后所有的规则将丢失。Sentinel还提供了Pull 模式、Push 模式。详细可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel" target="_blank" rel="noopener">在生产环境中使用 Sentinel</a>。</p><p>官方给的建议：<strong>生产环境下一般采用 push 模式的数据源</strong>。要使用<a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel#Push%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">push 模式</a>就需要对官方给提供的控制台进行改造，以及对客户端进行相应的配置。</p><p><img src="https://user-images.githubusercontent.com/9434884/45406233-645e8380-b698-11e8-8199-0c917403238f.png" alt></p><h2 id="控制台改造"><a href="#控制台改造" class="headerlink" title="控制台改造"></a>控制台改造</h2><p>官方给的说明有点混乱，整合过程中遇了不少问题，所幸是一步步走出来了。以下就将整理过程整理出来。</p><p><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel源码</a>，要改造控制台，源码是必不可少的，下载源码。其实要改造的就是加入Zookeeper动态数据源，源码中已经有了代码，可以拿来直接使用（也提供了apollo、nacos数据源的支持），位置在<code>sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/rule</code>下，将<code>zookeeper</code>包从test拖到main包下，修改<code>FlowControllerV2.java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"flowRuleZookeeperProvider"</span>)</span><br><span class="line"><span class="keyword">private</span> DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"flowRuleZookeeperPublisher"</span>)</span><br><span class="line"><span class="keyword">private</span> DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;</span><br></pre></td></tr></table></figure></p><p>这部分是<code>sentinel-dashboard</code>隐藏的代码及功能，应该是处于开发阶段，估计后期会有更好的集成方式。</p><p>启动sentinel-dashboard项目，点击菜单<strong>流控规则</strong>，可以看到访问路径如：<code>&lt;localhost:port&gt;/#/dashboard/flow/xxxxx</code>，需要手动添加“v2”为<code>&lt;localhost:port&gt;/#/dashboard/v2/flow/xxxxx</code>，一个隐藏的界面，此处添加的流控规则会被保存到我们配置好的zookeeper中。</p><p>或者找到<code>sidebar.html</code>将如下代码放开：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"dashboard.flow(&#123;app: entry.app&#125;)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-filter"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>  流控规则 V2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>控制台会多一菜单。</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>客户端集成相对容易一点，<code>application.properties</code>中添加如下代码即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.sentinel.datasource.ds3.zk.server-addr=localhost:2181</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.group-id=SENTINEL_GROUP</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.data-id=xxxxxx</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.rule-type=flow</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.data-type=json</span><br></pre></td></tr></table></figure></p><p>官方给的例子点<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/sentinel-example/sentinel-core-example/readme-zh.md" target="_blank" rel="noopener">Sentinel Example</a>。</p><p>在整合过程中废了点时间，因为官方给的说明有点混乱，是给控制台的代码还是给客户端的代码没有明确的说明，还有如上代码中的group-id、data-id等也没有明确的说明，一不注意配置不对，流控规则就不会生效。</p><p><code>InitFunc</code>接口，可以用作<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95#%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%BA%90" target="_blank" rel="noopener">注册数据源</a>，在尝试过程中发现这段代码配置到客户端是起作用的，即相当于上边客户端集成的在<code>application.properties</code>中添加的那段代码作用一样。具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; ruleSource = <span class="keyword">new</span> ZookeeperDataSource&lt;&gt;(remoteAddress, groupId,</span><br><span class="line">flowDataId, source -&gt; JSON.parseObject(source, <span class="keyword">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));</span><br><span class="line">FlowRuleManager.register2Property(ruleSource.getProperty());</span><br></pre></td></tr></table></figure></p><p>其中groupId、flowDataId注意，需要与控制台改造中设计到的zookeeper的path一致，否则规则不生效。</p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7" target="_blank" rel="noopener">集群流控</a>，控制台已经集成了该功能，我们拿来可以直接用，省去了调用API的麻烦，但该功能是需要客户端的支持。</p><p>Sentinel 集群限流服务端有两种启动方式：独立模式（Alone）；嵌入模式（Embedded）。调试集群限流看代码的过程中发现了<a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-cluster/sentinel-demo-cluster-embedded" target="_blank" rel="noopener">嵌入模式Demo</a>，此处是给springboot客户端集成的demo示例，将entity包、init包、DemoConstants类、META-INF文件夹及它们里边的类和文件，复制到咱们的springboot项目对应位置，自行配置集群，通过jmeter压测接口，会发现集群限流起作用了。</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>1、在控制台的日志里面显示setRules:success，但设置限流规则为什么不显示（不起作用）</p><pre><code>查看fastjson 版本，移除我们引入的jar，使用sentinel中的版本。</code></pre><p>2、convert error：客户端报错有这样的关键字，可以在Sentinel控制台的源码中找到<code>FlowRuleEntity.java</code>，将以下属性添加注解<code>@JSONField(serialize = false)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> String app;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> String ip;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Date gmtCreate;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Date gmtModified;</span><br></pre></td></tr></table></figure></p><p>3、集群限流不准确，项目添加以下启动参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dcsp.sentinel.log.use.pid=true</span><br></pre></td></tr></table></figure></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Sentinel官方源码中其实已经包含了所有需要到的代码，就是没有比较系统直白的使用demo，可能也是还在开发阶段吧，期待官方的完善。</p><p>个人感觉目前源码中缺失的功能，亦或是我没有发现的功能，除了集群限流规则能做到持久化数据库，其它规则没有提供，包括集群应用的配置信息也没有持久化。所幸的是如果不配置客户端集群功能，即人为设置token server失败，如果Token Server不可用，各应用自动退化到单机限流。</p><p>官方提供了各种接口供我们使用，可以根据自己的需要，自行设置。还有更多功能等待挖掘，有什么更好的使用方式可以联系我，一起研究。</p><p>相关链接：<br><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel源码</a></p><p><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba" target="_blank" rel="noopener">Sentinel 与 Spring Boot / Spring Cloud 的整合</a></p><p><a href="https://github.com/all4you/sentinel-tutorial" target="_blank" rel="noopener">Sentinel 教程，包括原理分析，源码阅读，实战分享</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/9434884/43697219-3cb4ef3a-9975-11e8-9a9c-73f4f537442d.png&quot; alt=&quot;Sentinel Logo&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="spring boot" scheme="https://duia.github.io/categories/JAVA/spring-boot/"/>
    
    
      <category term="Sentinel" scheme="https://duia.github.io/tags/Sentinel/"/>
    
      <category term="限流" scheme="https://duia.github.io/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Nginx Linux详细安装部署教程及配置SSL</title>
    <link href="https://duia.github.io/2019/03/21/Nginx%20Linux%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B%E5%8F%8A%E9%85%8D%E7%BD%AESSL/"/>
    <id>https://duia.github.io/2019/03/21/Nginx Linux详细安装部署教程及配置SSL/</id>
    <published>2019-03-21T03:48:00.000Z</published>
    <updated>2019-05-23T12:00:00.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Nginx简介"><a href="#一、Nginx简介" class="headerlink" title="一、Nginx简介"></a>一、Nginx简介</h2><p>Nginx是一个web服务器也可以用来做负载均衡及反向代理使用，目前使用最多的就是负载均衡，具体简介我就不介绍了百度一下有很多，下面直接进入安装步骤</p><h2 id="二、Nginx安装"><a href="#二、Nginx安装" class="headerlink" title="二、Nginx安装"></a>二、Nginx安装</h2><h3 id="1、下载Nginx及相关组件"><a href="#1、下载Nginx及相关组件" class="headerlink" title="1、下载Nginx及相关组件"></a>1、下载Nginx及相关组件</h3><p>Linux系统是Centos 6.5 64位，我直接切换到root用户下安装</p><p>进入用户目录下载程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# cd /usr/local/src/</span><br></pre></td></tr></table></figure><p>下载相关组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# wget http://nginx.org/download/nginx-1.10.2.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# wget http://www.openssl.org/source/openssl-fips-2.0.10.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>安装c++编译环境，如已安装可略过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# yum install gcc-c++</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>期间会有确认提示输入y回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is this ok [y/N]:y</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><h3 id="2、安装Nginx及相关组件"><a href="#2、安装Nginx及相关组件" class="headerlink" title="2、安装Nginx及相关组件"></a>2、安装Nginx及相关组件</h3><p>openssl安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf openssl-fips-2.0.10.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd openssl-fips-2.0.10</span><br><span class="line">[root@localhost openssl-fips-2.0.10]# ./config &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>pcre安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf pcre-8.40.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd pcre-8.40</span><br><span class="line">[root@localhost pcre-8.40]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>zlib安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf zlib-1.2.11.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd zlib-1.2.11</span><br><span class="line">[root@localhost zlib-1.2.11]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><p>nginx安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf nginx-1.10.2.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd nginx-1.10.2</span><br><span class="line">[root@localhost nginx-1.10.2]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure><h3 id="3、启动Nginx"><a href="#3、启动Nginx" class="headerlink" title="3、启动Nginx"></a>3、启动Nginx</h3><p>先找一下nginx安装到什么位置上了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# whereis nginx</span><br><span class="line">nginx: /usr/local/nginx</span><br></pre></td></tr></table></figure><p>进入nginx目录并启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# cd /usr/local/nginx</span><br><span class="line">[root@localhost nginx]# sbin/nginx</span><br><span class="line">sbin/nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>报错了，按照下面方式解决</p><ol><li>用whereis libpcre.so.1命令找到libpcre.so.1在哪里</li><li>用ln -s /usr/local/lib/libpcre.so.1 /lib64命令做个软连接就可以了</li><li>用sbin/nginx启动Nginx</li><li>用ps -aux | grep nginx查看状态</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# whereis libpcre.so.1</span><br><span class="line">[root@localhost nginx]# ln -s /usr/local/lib/libpcre.so.1 /lib64</span><br><span class="line">[root@localhost nginx]# sbin/nginx</span><br><span class="line">[root@localhost nginx]# ps -aux | grep nginx</span><br></pre></td></tr></table></figure><p>进入Linux系统的图形界面，打开浏览器输入localhost会看到下图，说明nginx启动成功<br><img src="https://www.duia.online/upload/2019/2/90-46173693220190320183342795.png" alt="image"></p><p><strong>nginx的基本操作</strong></p><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>停止/重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -s stop(quit、reload)</span><br></pre></td></tr></table></figure><p>命令帮助</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -h</span><br></pre></td></tr></table></figure><p>验证配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="4、简单配置Nginx"><a href="#4、简单配置Nginx" class="headerlink" title="4、简单配置Nginx"></a>4、简单配置Nginx</h3><p>打开nginx配置文件位于nginx目录下的conf文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# vim conf/nginx.conf</span><br></pre></td></tr></table></figure><p>简单介绍一下vim的语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">默认vim打开后是不能录入的，需要按键才能操作，具体如下：</span><br><span class="line">开启编辑：按“i”或者“Insert”键</span><br><span class="line">退出编辑：“Esc”键</span><br><span class="line">退出vim：“:q”</span><br><span class="line">保存vim：“:w”</span><br><span class="line">保存退出vim：“:wq”</span><br><span class="line">不保存退出vim：“:q!”</span><br></pre></td></tr></table></figure><p>“#”代表注释，最重要的是server{}块这部分就代表每一个web站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream testserver&#123;</span><br><span class="line">    server localhost:81;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.domain.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         proxy_pass http://testserver;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加如上代码，监听80端口，将域名访问<code>www.domain.com</code>的访问指到<code>localhost:81</code>，保存退出并且重启nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# ./sbin/nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="5-配置本地域名多服务"><a href="#5-配置本地域名多服务" class="headerlink" title="5.配置本地域名多服务"></a>5.配置本地域名多服务</h3><p>扩展upstream{}、server{}即可实现二级域名访问同一服务器的多服务项目。</p><h3 id="6-开启HTTPS、Nginx-证书部署"><a href="#6-开启HTTPS、Nginx-证书部署" class="headerlink" title="6.开启HTTPS、Nginx 证书部署"></a>6.开启HTTPS、Nginx 证书部署</h3><h4 id="获取证书略"><a href="#获取证书略" class="headerlink" title="获取证书略"></a>获取证书略</h4><h4 id="证书安装"><a href="#证书安装" class="headerlink" title="证书安装"></a>证书安装</h4><p>将域名 <a href="http://www.domain.com" target="_blank" rel="noopener">www.domain.com</a> 的证书文件 <code>1_www.domain.com_bundle.crt</code> 、私钥文件 <code>2_www.domain.com.key</code> 保存到同一个目录，例如 <code>/usr/local/nginx/conf</code> 目录下。<br>修改 Nginx 根目录下 <code>conf/nginx.conf</code> 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate 1_www.domain.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key 2_www.domain.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://testserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，请先执行命令 <code>sbin/nginx –t</code> 测试 Nginx 配置是否有误。若无报错，重启 Nginx 之后，即可使用 <code>https://www.domain.com</code> 来访问。</p><p>相关参数说明如下：</p><table><thead><tr><th>配置文件参数</th><th>说明</th></tr></thead><tbody><tr><td>listen 443</td><td>SSL 访问端口号为 443</td></tr><tr><td>ssl on</td><td>启用 SSL 功能</td></tr><tr><td>ssl_certificate</td><td>证书文件</td></tr><tr><td>ssl_certificate_key</td><td>私钥文件</td></tr><tr><td>ssl_protocols</td><td>使用的协议</td></tr><tr><td>ssl_ciphers</td><td>配置加密套件，写法遵循 openssl 标准</td></tr></tbody></table><p>如果配置完成后出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx:[emerg]unknown directive &quot;ssl&quot;</span><br></pre></td></tr></table></figure><p>因为我们配置这个SSL证书需要引用到nginx的中SSL这模块，然而我们一开始编译的Nginx的时候并没有把SSL模块一起编译进去，所以导致这个错误的出现。</p><h4 id="错误解决步骤"><a href="#错误解决步骤" class="headerlink" title="错误解决步骤"></a>错误解决步骤</h4><p>既然在安装的时候没有编译ssl，难道把nginx卸载重新安装一次？不不不，我们只需要在原有的基础上添加ssl模块就行了。</p><p>我们先来到当初下载nginx的包压缩的解压目录，解压目录应该在<code>/usr/loacl/src/</code>，绝大多数应该都是在这个目录下的，已经是一种规范了。</p><p>来到解压目录下后，按顺序执行一下命令：</p><p>命令1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# ./configure --with-http_ssl_module  //重新添加这个ssl模块</span><br></pre></td></tr></table></figure></p><p>注意如果没有出现错误，则直接看命令2即可 </p><p>执行以上一条命令出现这个错误<code>./configure：错误：SSL模块需要OpenSSL库。</code>，原因是因为缺少了OpenSSL，那我们再来安装一个即可执行：<code>yum -y install openssl openssl-devel</code></p><p>等待OpenSSL的安装完成后，再执行<code>./configure</code> ，最后在执行<code>命令1</code> 即可。</p><p>命令2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# make</span><br></pre></td></tr></table></figure></p><p>不要执行make install，因为make是用来编译的，而make install是安装，不然你整个nginx会重新覆盖的。</p><p>命令3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak // 先将原来的nginx备份想删除也可以</span><br><span class="line"></span><br><span class="line">[root@localhost nginx]# cp objs/nginx /usr/local/nginx/sbin/nginx // objs 目录中是编译后产生的文件</span><br></pre></td></tr></table></figure><p>再次<code>sbin/nginx –t</code>即可看见成功。</p><h4 id="使用全站加密，HTTP-自动跳转-HTTPS（可选）"><a href="#使用全站加密，HTTP-自动跳转-HTTPS（可选）" class="headerlink" title="使用全站加密，HTTP 自动跳转 HTTPS（可选）"></a>使用全站加密，HTTP 自动跳转 HTTPS（可选）</h4><p>对于用户不知道网站可以进行 HTTPS 访问的情况下，让服务器自动把 HTTP 的请求重定向到 HTTPS。</p><p>在服务器这边的话配置的话，可以在页面里加 js 脚本，也可以在后端程序里写重定向，当然也可以在 web 服务器来实现跳转。Nginx 是支持 rewrite 的（只要在编译的时候没有去掉 pcre）</p><p>在 HTTP 的 server 里增加 <code>rewrite ^(.*) https://$host$1 permanent;</code><br>这样就可以实现 80 进来的请求，重定向为 HTTPS 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.duia.online;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         proxy_pass http://haloserver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rewrite ^(.*) https://$host$1 permanent;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Nginx简介&quot;&gt;&lt;a href=&quot;#一、Nginx简介&quot; class=&quot;headerlink&quot; title=&quot;一、Nginx简介&quot;&gt;&lt;/a&gt;一、Nginx简介&lt;/h2&gt;&lt;p&gt;Nginx是一个web服务器也可以用来做负载均衡及反向代理使用，目前使用最多的就是负
      
    
    </summary>
    
      <category term="服务器" scheme="https://duia.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="nginx" scheme="https://duia.github.io/tags/nginx/"/>
    
      <category term="https" scheme="https://duia.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>ueditor+公式插件</title>
    <link href="https://duia.github.io/2019/02/22/ueditor+%E5%85%AC%E5%BC%8F%E6%8F%92%E4%BB%B6/"/>
    <id>https://duia.github.io/2019/02/22/ueditor+公式插件/</id>
    <published>2019-02-22T11:07:00.000Z</published>
    <updated>2019-05-23T12:00:00.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ueditor-公式插件"><a href="#ueditor-公式插件" class="headerlink" title="ueditor+公式插件"></a>ueditor+公式插件</h2><p>本文主要说一说ueditor和公式插件KityFormula在使用过程中遇到的问题。</p><p>ueditor和项目的集成可以自行百度，KityFormula 可以看这里<a href="https://ueditor.baidu.com/website/kityformula.html" target="_blank" rel="noopener">KityFormula</a>，也相对简单，没啥问题。下边进入主题：</p><h3 id="生成公式图片"><a href="#生成公式图片" class="headerlink" title="生成公式图片"></a>生成公式图片</h3><p>默认生成<code>data:image/jpeg;base64</code>图片代码，找到kityFormulaDialog.html文件，有一段如下代码，加入一行代码即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dialog.onok = function()&#123;</span><br><span class="line">       kfe.execCommand(&apos;get.image.data&apos;, function(data)&#123;</span><br><span class="line">           var latex = kfe.execCommand(&apos;get.source&apos;);</span><br><span class="line">           editor.execCommand(&apos;inserthtml&apos;, &apos;&lt;img class=&quot;kfformula&quot; src=&quot;&apos;+ data.img +&apos;&quot; data-latex=&quot;&apos; + latex + &apos;&quot; /&gt;&apos;);</span><br><span class="line">           editor.getKfContent(function(html)&#123;&#125;);//新增代码</span><br><span class="line">           dialog.close();</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>editor.getKfContent()方法是KityFormula提供的生成图片的功能，生成图片需要后台代码的支持。这部分功能正式ueditor提供的涂鸦图片生成的功能。</p><h3 id="公式图片背景透明"><a href="#公式图片背景透明" class="headerlink" title="公式图片背景透明"></a>公式图片背景透明</h3><p>Ueditor生成的图片默认JPG格式，经过尝试发现只需要将生成的图片格式修改为PNG图片即可。做如下修改：<br>FileType.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final String JPG = &quot;JPG&quot;;</span><br><span class="line">public static final String PNG = &quot;PNG&quot;;</span><br><span class="line"></span><br><span class="line">private static final Map&lt;String, String&gt; types = new HashMap&lt;String, String&gt;()&#123;&#123;</span><br><span class="line"></span><br><span class="line">put( FileType.JPG, &quot;.jpg&quot; );</span><br><span class="line">put( FileType.PNG, &quot;.png&quot; );</span><br><span class="line"></span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">//......</span><br></pre></td></tr></table></figure></p><p>Base64Uploader.java文件中”JPG”改为”PNG”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String suffix = FileType.getSuffix(&quot;JPG&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="生成图片后富文本中图片标签加宽高"><a href="#生成图片后富文本中图片标签加宽高" class="headerlink" title="生成图片后富文本中图片标签加宽高"></a>生成图片后富文本中图片标签加宽高</h3><p>getKfContent.js文件设置item属性的地方加以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var width=&apos;&apos;;</span><br><span class="line">var height=&apos;&apos;;</span><br><span class="line">// 创建对象</span><br><span class="line">var img = new Image();</span><br><span class="line">// 设置图片的src</span><br><span class="line">img.src = url;</span><br><span class="line">//console.log(&quot;link:&quot;+link);</span><br><span class="line">img.onload = function()&#123;</span><br><span class="line">    width=img.width;</span><br><span class="line">    height=img.height;</span><br><span class="line">    item.setAttribute(&apos;width&apos;,width);</span><br><span class="line">    item.setAttribute(&apos;height&apos;,height);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="新增限制条件"><a href="#新增限制条件" class="headerlink" title="新增限制条件"></a>新增限制条件</h3><p>AppInfo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int WIDTH_MAX_SIZE = 9;</span><br><span class="line"></span><br><span class="line">// &quot;文件大小超出限制&quot;</span><br><span class="line">put( AppInfo.WIDTH_MAX_SIZE, &quot;图片宽度超出限制&quot; );</span><br></pre></td></tr></table></figure></p><p>StorageManager.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedImage sourceImg = ImageIO.read(new FileInputStream(tmpFile));</span><br><span class="line">if (sourceImg.getWidth() &gt; 400) &#123;</span><br><span class="line">tmpFile.delete();</span><br><span class="line">return new BaseState(false, AppInfo.WIDTH_MAX_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ueditor-公式插件&quot;&gt;&lt;a href=&quot;#ueditor-公式插件&quot; class=&quot;headerlink&quot; title=&quot;ueditor+公式插件&quot;&gt;&lt;/a&gt;ueditor+公式插件&lt;/h2&gt;&lt;p&gt;本文主要说一说ueditor和公式插件KityFormula
      
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="js" scheme="https://duia.github.io/categories/JAVA/js/"/>
    
    
      <category term="ueditor" scheme="https://duia.github.io/tags/ueditor/"/>
    
  </entry>
  
  <entry>
    <title>springboot+mongo分库分表通用策略</title>
    <link href="https://duia.github.io/2019/02/17/springboot+mongo%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E9%80%9A%E7%94%A8%E7%AD%96%E7%95%A5/"/>
    <id>https://duia.github.io/2019/02/17/springboot+mongo分库分表通用策略/</id>
    <published>2019-02-17T11:30:00.000Z</published>
    <updated>2019-05-23T12:00:00.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景和基本思路"><a href="#背景和基本思路" class="headerlink" title="背景和基本思路"></a>背景和基本思路</h2><p>题库项目开发过程中，选用mongodb作为用户数据储存的数据库，在前期开发过程中，也做了简单的分表策略——按照业务场景分表，即某一科目的考试练习所产生的数据，会进入一个collection，在涉及到mongodb操作的时候，通过以下方法获取操作的集合名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCollectionName</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.collectionName+<span class="string">"_"</span>+skuId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">find</span><span class="params">(Query query, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.find(query, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Query query, Update update, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.update(query, update, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">insert</span><span class="params">(T entity, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.insert(entity, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">save</span><span class="params">(T entity, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.save(entity, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其它方法略</span></span><br></pre></td></tr></table></figure><p>经过一段时间的运行后发现，分表数据产生的严重的倾斜，分析后，于是修改了分表策略，不能按照科目业务分表，于是修改为对用户id进行取余的方式来进行分表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCollectionName</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.collectionName+<span class="string">"_"</span>+skuId % <span class="keyword">this</span>.shardingCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上便是mongodb分表的基本思想，对于mongodb分表这个概念，有点争议，有些人说mongodb自带分片基因，可以通过相应的配置实现mongodb的分片，所以无需分表，在这里暂不考虑分表的必要性，总的来说，当mongodb单个集合数据上亿，在项目实践中感觉还是可以通过分表功能得到很大的缓解。</p><h2 id="通用模块"><a href="#通用模块" class="headerlink" title="通用模块"></a>通用模块</h2><p>废话不多说，先上代码。百度云盘<a href="https://pan.baidu.com/s/12RoXqnbWmDMJphvi8v__Cg" target="_blank" rel="noopener">下载</a> 提取码: <code>phf8</code></p><p>一个相对独立的模块，如果你的项目使用的是springboot的话，直接复制进去就可以使用了，大可不必过多的描述，但其中也有几点比较特殊的地方，所以还是列出来做些说明：</p><h3 id="1、MongoConfig"><a href="#1、MongoConfig" class="headerlink" title="1、MongoConfig"></a>1、MongoConfig</h3><p>由于我们项目是springboot框架，这里就优先说一下这个配置项，搭配springboot的application.properties文件很容易就可以实现mongodb的配置，并且支持多mongo数据源配置，为分库做准备。</p><p>application.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#mongodb://[username:password@]host1[:port1][,host2[:port2],¡­[,hostN[:portN]]][/[database][?options]]</span><br><span class="line"># mongdb1</span><br><span class="line">spring.data.mongodb.one.uri=mongodb://127.0.0.1:27017/wpc</span><br><span class="line"># mongdb2</span><br><span class="line">spring.data.mongodb.two.uri=mongodb://112.126.91.194:27017/tiku_dev</span><br></pre></td></tr></table></figure></p><p>MongoConfig.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自动注入第一个 mongondb</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.mongodb.one.uri&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String MONGO_URI;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自动注入第二个 mongondb</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.mongodb.two.uri&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String MONGO_URI2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure></p><h3 id="2、dao"><a href="#2、dao" class="headerlink" title="2、dao"></a>2、dao</h3><p>dao包下有两个子包：multimongo和shardcollection，分别是分库和分表的基础类，根据实际需要进行继承即可。</p><p>其中分库策略需要借助<code>MultiMongo.java</code>类来选择具体的策略，以及索要使用的mongo库，根据指定注入的对象名来指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MultiMongo</span>(strategy = DefaultDecisionHandler.DEFAULT, specify = <span class="string">"mongoMain"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Title&gt; <span class="title">findTitles</span><span class="params">(Integer status)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>分表策略需要借助<code>ShardingKey.java</code>类，注解在具体操作类的分表依据的字段上来使用，指定分表个数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ShardingKey</span>(shardingColumn = <span class="string">"userId"</span>, value = <span class="string">"userId"</span>, shardingCount = <span class="number">128</span>)</span><br><span class="line">   <span class="keyword">private</span> Long userId;</span><br></pre></td></tr></table></figure><h3 id="3、DBDecisionDaoAop-java"><a href="#3、DBDecisionDaoAop-java" class="headerlink" title="3、DBDecisionDaoAop.java"></a>3、DBDecisionDaoAop.java</h3><p>分库策略的AOP，需要修改<code>doAround</code>方法的注解，进入加有<code>@MultiMongo</code>注解的dao层具体方法前，动态切换指定mongo库。</p><h3 id="4、handler"><a href="#4、handler" class="headerlink" title="4、handler"></a>4、handler</h3><p>定义具体的分库信息，默认提供了<code>DefaultDecisionHandler</code>分库策略，即根据指定库名来获取mongo库。也可以参照<code>DateDecisionHandler</code>来扩展我们所需要的分库策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景和基本思路&quot;&gt;&lt;a href=&quot;#背景和基本思路&quot; class=&quot;headerlink&quot; title=&quot;背景和基本思路&quot;&gt;&lt;/a&gt;背景和基本思路&lt;/h2&gt;&lt;p&gt;题库项目开发过程中，选用mongodb作为用户数据储存的数据库，在前期开发过程中，也做了简单的分表策
      
    
    </summary>
    
      <category term="spring boot" scheme="https://duia.github.io/categories/spring-boot/"/>
    
      <category term="mongodb" scheme="https://duia.github.io/categories/spring-boot/mongodb/"/>
    
      <category term="数据库" scheme="https://duia.github.io/categories/spring-boot/mongodb/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MongoDB" scheme="https://duia.github.io/tags/MongoDB/"/>
    
      <category term="springboot" scheme="https://duia.github.io/tags/springboot/"/>
    
      <category term="分表" scheme="https://duia.github.io/tags/%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>EJS学习总结</title>
    <link href="https://duia.github.io/2017/07/28/EJS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://duia.github.io/2017/07/28/EJS学习总结/</id>
    <published>2017-07-28T13:50:00.000Z</published>
    <updated>2019-05-19T00:00:00.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是EJS"><a href="#一、什么是EJS" class="headerlink" title="一、什么是EJS"></a>一、什么是EJS</h3><p>EJS是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。</p><h3 id="二、为什么要使用EJS"><a href="#二、为什么要使用EJS" class="headerlink" title="二、为什么要使用EJS"></a>二、为什么要使用EJS</h3><p>与最初的JavaScript相比较，一些不太了解你的代码的人可以更容易地通过EJS模板代码看得懂你的代码。 让我们放松一下，一起来享受下令人激动的干净简洁的感觉。</p><p>总之可以让代码更加干净整洁，让人易懂。</p><a id="more"></a><p>可以看如下的例子：</p><p>这是用javascript实现的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">"&lt;h1&gt;"</span>+data.title+<span class="string">"&lt;/h1&gt;"</span></span><br><span class="line">html += <span class="string">"&lt;ul&gt;"</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;data.supplies.length; i++) &#123;</span><br><span class="line">    html += <span class="string">"&lt;li&gt;&lt;a href='supplies/"</span>+data.supplies[i]+<span class="string">"'&gt;"</span></span><br><span class="line">    html += data.supplies[i]+<span class="string">"&lt;/a&gt;&lt;/li&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line">html += <span class="string">"&lt;/ul&gt;"</span></span><br></pre></td></tr></table></figure></p><p>最终要实现的效果如下：</p><p><img src="/upload/2019/1/ejs120190216143859415.png" alt="image"></p><p>但是上面的代码看起来很乱，虽然实现了功能，但是不容易让人弄懂。不仅代码丑陋，而且你的HTML结构完全在JavaScript代码中丢失。</p><p>下面学习EJS同样实现上面的功效，它的工作原理如下：</p><p><img src="/upload/2019/1/ejs220190216143859306.png" alt="image"></p><p>使用EJS来找回你的明确、维护性良好的HTML代码结构。</p><p>注:data是json对象，不能使json字符串。</p><p>在HTML中引入EJS,以使javascript能够使用它，引入EJS的语句如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/ejs.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>创建一个EJS模板,命名为<code>cleaning.ejs</code>文件，内容如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">%=title</span> %&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &lt;% for(var i=0; i&lt;supplies.length; i++) &#123; %&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'supplies/&lt;%=supplies[i] %&gt;'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">%=</span> <span class="attr">supplies</span>[<span class="attr">i</span>] %&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我的HTML文档如下，引入EJS,并更加我们的提供EJS模板创建EJS对象，然后调用EJS对象成员函数解析JSON对象到模板中。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/ejs.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">myfunction</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> data=<span class="string">'&#123;"title":"cleaning","supplies":["mop","broom","duster"]&#125;'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> html = <span class="keyword">new</span> EJS(&#123;<span class="attr">url</span>: <span class="string">'/js/tmpl/cleaning.ejs'</span>&#125;).render(<span class="built_in">JSON</span>.parse(data));</span></span><br><span class="line"><span class="javascript">    <span class="comment">//JSON.parse(data) 把JSON字符串解析为原生的javascript值。</span></span></span><br><span class="line"><span class="undefined">    alert(html);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>).innerHTML=html;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"myfunction()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>从上面这个例子我们可以看到EJS模板的基本用法。</p><h3 id="三、下面介绍下EJS的语法和功能："><a href="#三、下面介绍下EJS的语法和功能：" class="headerlink" title="三、下面介绍下EJS的语法和功能："></a>三、下面介绍下EJS的语法和功能：</h3><ol><li>缓存功能，能够缓存已经解析好的html模版</li><li><p><code>&lt;% code %&gt;</code>用于执行其中javascript代码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% alert(&apos;hello world&apos;) %&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;%= code %&gt;</code>会对code进行html转义；</p><ul><li><code>&lt;h1&gt;&lt;%=title %&gt;&lt;/h1&gt;</code>                    注：会把title里面存的值给显示出来在h1中。</li><li><code>&lt;p&gt;&lt;%= &#39;hello world&#39; %&gt;&lt;/p&gt;</code>             注：会把hello world显示在h1中。</li><li><code>&lt;h1&gt;&lt;%= &#39;&lt;b&gt;hello world&lt;/b&gt;&#39; %&gt;&lt;/h1&gt;</code>    注：会把hello world变粗，然后显示在h1中。</li></ul></li><li><code>&lt;%- code %&gt;</code>将不会进行转义<br>这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。<ul><li><code>&lt;h1&gt;&lt;%-title %&gt;asd&lt;/h1&gt;</code>          最后显示asd，及显示原网页</li><li><code>&lt;p&gt;&lt;%# &#39;hello world&#39; %&gt;asd&lt;/p&gt;</code>   最后显示asd，及显示原网页</li></ul></li><li><p>支持自定义标签<br> ejs 里，默认的闭合标记是 <code>&lt;%  .. %&gt;</code>，我们也可以定义自己的标签。例如：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">"view options"</span>,&#123;</span><br><span class="line">   <span class="string">"open"</span>:<span class="string">"&#123;&#123;"</span>,</span><br><span class="line">   <span class="string">"close"</span>:<span class="string">"&#125;&#125;"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>提供一些辅助函数，用于模版中使用</p><ol><li>first，返回数组的第一个元素；</li><li>last，返回数组的最后一个元素；</li><li>capitalize，返回首字母大写的字符串；</li><li>downcase，返回字符串的小写；</li><li>upcase，返回字符串的大写；</li><li>sort，排序（Object.create(obj).sort()？）；</li><li>sort_by:’prop’，按照指定的prop属性进行升序排序；</li><li>size，返回长度，即length属性，不一定非是数组才行；</li><li>plus:n，加上n，将转化为Number进行运算；</li><li>minus:n，减去n，将转化为Number进行运算；</li><li>times:n，乘以n，将转化为Number进行运算；</li><li>divided_by:n，除以n，将转化为Number进行运算；</li><li>join:’val’，将数组用’val’最为分隔符，进行合并成一个字符串；</li><li>truncate:n，截取前n个字符，超过长度时，将返回一个副本</li><li>truncate_words:n，取得字符串中的前n个word，word以空格进行分割；</li><li>replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串；</li><li>prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面；</li><li>append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面；</li><li>map:’prop’，返回对象数组中属性为prop的值组成的数组；</li><li>reverse，翻转数组或字符串；</li><li>get:’prop’，取得属性为’prop’的值；</li><li>json，转化为json格式字符串</li></ol></li><li>利用<code>&lt;%- include filename %&gt;</code>加载其他页面模版<h3 id="四、使用创建好的EJS模板"><a href="#四、使用创建好的EJS模板" class="headerlink" title="四、使用创建好的EJS模板"></a>四、使用创建好的EJS模板</h3></li></ol><p>基于我们之前写的模拟生成一个EJS对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> EJS(&#123;<span class="attr">url</span>: <span class="string">'/js/tmpl/cleaning.ejs'</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>对象有下面两个成员函数</p><ul><li><code>ejs.compile(str, options)</code> 将返回内部解析好的Function函数</li><li><p><code>ejs.render(str, options)</code> 返回经过解析的字符串，ejs的render函数有两个参数 第一个是字符串，第二个是可选的对象，和其他javascript模版一样需要渲染的数据也是包含在option对象中的。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ejs.render(str,option);  <span class="comment">// 渲染字符串 str 一般是通过nodejs文件系统的readfile方法读取</span></span><br><span class="line">ejs.render(str,&#123;</span><br><span class="line">    data : user_data  <span class="comment">// 需要渲染的数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  其中options的一些参数为：</p><ol><li>cache：是否缓存解析后的模版，需要filename作为key；</li><li>filename：模版文件名；</li><li>scope：complile后的Function执行所在的上下文环境；</li><li>debug：标识是否是debeg状态，debug为true则会输出生成的Function内容；</li><li>compileDebug：标识是否是编译debug，为true则会生成解析过程中的跟踪信息，用于调试；</li><li>client，标识是否用于浏览器客户端运行，为true则返回解析后的可以单独运行的Function函数；</li><li>open，代码开头标记，默认为’&lt;%’；</li><li>close，代码结束标记，默认为’%&gt;’；</li><li><p>其他的一些用于解析模版时提供的变量。</p><p>在express中使用时，options参数将由response.render进行传入，其中包含了一些express中的设置，以及用户提供的变量值。</p></li></ol></li></ul><h3 id="五、最后总结一下EJS的应用场所"><a href="#五、最后总结一下EJS的应用场所" class="headerlink" title="五、最后总结一下EJS的应用场所"></a>五、最后总结一下EJS的应用场所</h3><ul><li><p>用JavaScript创建HTML字符串</p><p>  正如我们在新手教程中所讨论的，在JavaScript中拼字符串的缺点是可维护性不好。当你在JavaScript中将这些字符串拼到一起时，很难看出你正在写的HTML是什么-–|一个你页面展现的结构。而使用模板可以让你通过代码的空行和缩进来清楚地展现出你的HTML。</p></li><li><p>基于WebService的AJAX网站开发</p><p>  EJS可以接收WebService异步传送过来的JSON格式的数据，将这种数据直接传入你的模板里，然后将结果插入到你的页面中。你所需要做的只是通过以下代码:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> EJS(&#123;<span class="attr">url</span>: <span class="string">'comments.ejs'</span>&#125;).update(<span class="string">'element_id'</span>, <span class="string">'/comments.json'</span>);</span><br></pre></td></tr></table></figure></li><li><p>程序换肤功能</p><p>  如果你想给用户自制页面显示的功能，EJS提供了非常适合的机制。EJS的模板只在浏览器里执行，因此对你的服务器没有任何安全风险。你可以允许你的用户上传EJS模板以及其关联的样式表，从而实现定制你的网站页面的功能。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、什么是EJS&quot;&gt;&lt;a href=&quot;#一、什么是EJS&quot; class=&quot;headerlink&quot; title=&quot;一、什么是EJS&quot;&gt;&lt;/a&gt;一、什么是EJS&lt;/h3&gt;&lt;p&gt;EJS是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。&lt;/p&gt;
&lt;h3 id=&quot;二、为什么要使用EJS&quot;&gt;&lt;a href=&quot;#二、为什么要使用EJS&quot; class=&quot;headerlink&quot; title=&quot;二、为什么要使用EJS&quot;&gt;&lt;/a&gt;二、为什么要使用EJS&lt;/h3&gt;&lt;p&gt;与最初的JavaScript相比较，一些不太了解你的代码的人可以更容易地通过EJS模板代码看得懂你的代码。 让我们放松一下，一起来享受下令人激动的干净简洁的感觉。&lt;/p&gt;
&lt;p&gt;总之可以让代码更加干净整洁，让人易懂。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://duia.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://duia.github.io/tags/js/"/>
    
      <category term="ejs" scheme="https://duia.github.io/tags/ejs/"/>
    
      <category term="html" scheme="https://duia.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的增删改查</title>
    <link href="https://duia.github.io/2017/04/11/MongoDB%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>https://duia.github.io/2017/04/11/MongoDB的增删改查/</id>
    <published>2017-04-11T13:37:00.000Z</published>
    <updated>2019-05-20T05:00:00.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB-查询所有数据库"><a href="#MongoDB-查询所有数据库" class="headerlink" title="MongoDB 查询所有数据库"></a>MongoDB 查询所有数据库</h3><blockquote><p>show dbs;</p></blockquote><h3 id="MongoDB-切换-创建数据库"><a href="#MongoDB-切换-创建数据库" class="headerlink" title="MongoDB 切换/创建数据库"></a>MongoDB 切换/创建数据库</h3><blockquote><p>use DATABASE_NAME;</p></blockquote><p>如果数据库不存在，则创建数据库，否则切换到指定数据库。</p><h3 id="MongoDB-删除数据库"><a href="#MongoDB-删除数据库" class="headerlink" title="MongoDB 删除数据库"></a>MongoDB 删除数据库</h3><blockquote><p>db.dropDatabase()</p></blockquote><p>删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。<br><a id="more"></a></p><h3 id="MongoDB-插入文档"><a href="#MongoDB-插入文档" class="headerlink" title="MongoDB 插入文档"></a>MongoDB 插入文档</h3><p>文档的数据结构和JSON基本一样。</p><p>所有存储在集合中的数据都是BSON格式。</p><p>BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。</p><h4 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h4><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：</p><blockquote><p>db.COLLECTION_NAME.insert(document)</p></blockquote><p>插入文档你也可以使用 db.col.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。</p><h3 id="MongoDB-更新文档"><a href="#MongoDB-更新文档" class="headerlink" title="MongoDB 更新文档"></a>MongoDB 更新文档</h3><p>MongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。</p><h4 id="update-方法"><a href="#update-方法" class="headerlink" title="update() 方法"></a>update() 方法</h4><p>update() 方法用于更新已存在的文档。语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>query : update的查询条件，类似sql update查询内where后面的。</li><li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li><li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew，true为插入，默认是false，不插入。</li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li><li>writeConcern :可选，抛出异常的级别。</li></ul><h4 id="save-方法"><a href="#save-方法" class="headerlink" title="save() 方法"></a>save() 方法</h4><p>save() 方法通过传入的文档来替换已有文档。语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.save(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>document : 文档数据。</li><li>writeConcern :可选，抛出异常的级别。</li></ul><h3 id="MongoDB-删除文档"><a href="#MongoDB-删除文档" class="headerlink" title="MongoDB 删除文档"></a>MongoDB 删除文档</h3><p>MongoDB remove()函数是用来移除集合中的数据。</p><p>MongoDB数据更新可以使用update()函数。在执行remove()函数前先执行find()命令来判断执行的条件是否正确，这是一个比较好的习惯。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;justOne&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>如果你的 MongoDB 是 2.6 版本以后的，语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>query :（可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除一个文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul><h3 id="MongoDB-查询文档"><a href="#MongoDB-查询文档" class="headerlink" title="MongoDB 查询文档"></a>MongoDB 查询文档</h3><p>MongoDB 查询文档使用 find() 方法。</p><p>find() 方法以非结构化的方式来显示所有文档。</p><blockquote><p>db.COLLECTION_NAME.find(query, projection)</p></blockquote><ul><li>query ：可选，使用查询操作符指定查询条件</li><li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li></ul><p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p><blockquote><p>db.COLLECTION_NAME.find().pretty()</p></blockquote><p>pretty() 方法以格式化的方式来显示所有文档。</p><p>除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。</p><h4 id="MongoDB-与-RDBMS-Where-语句比较"><a href="#MongoDB-与-RDBMS-Where-语句比较" class="headerlink" title="MongoDB 与 RDBMS Where 语句比较"></a>MongoDB 与 RDBMS Where 语句比较</h4><p>如果你熟悉常规的 SQL 数据，通过下表可以更好的理解 MongoDB 的条件语句查询：</p><table><thead><tr><th>操作</th><th>格式</th><th>范例</th><th>RDBMS中的类似语句</th></tr></thead><tbody><tr><td>等于</td><td>{<key>:<value>}</value></key></td><td>db.col.find({“by”:”菜鸟教程”}).pretty()</td><td>where by = ‘菜鸟教程’</td></tr><tr><td>小于</td><td>{<key>:{$lt:<value>}}</value></key></td><td>db.col.find({“likes”:{$lt:50}}).pretty()</td><td>where likes &lt; 50</td></tr><tr><td>小于或等于</td><td>{<key>:{$lte:<value>}}</value></key></td><td>db.col.find({“likes”:{$lte:50}}).pretty()</td><td>where likes &lt;= 50</td></tr><tr><td>大于</td><td>{<key>:{$gt:<value>}}</value></key></td><td>db.col.find({“likes”:{$gt:50}}).pretty()</td><td>where likes &gt; 50</td></tr><tr><td>大于或等于</td><td>{<key>:{$gte:<value>}}</value></key></td><td>db.col.find({“likes”:{$gte:50}}).pretty()</td><td>where likes &gt;= 50</td></tr><tr><td>不等于</td><td>{<key>:{$ne:<value>}}</value></key></td><td>db.col.find({“likes”:{$ne:50}}).pretty()</td><td>where likes != 50</td></tr></tbody></table><h4 id="MongoDB-AND-条件"><a href="#MongoDB-AND-条件" class="headerlink" title="MongoDB AND 条件"></a>MongoDB AND 条件</h4><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开。</p><p>语法格式如下：</p><blockquote><p>db.COLLECTION_NAME.find({key1:value1, key2:value2}).pretty()</p></blockquote><h4 id="MongoDB-OR-条件"><a href="#MongoDB-OR-条件" class="headerlink" title="MongoDB OR 条件"></a>MongoDB OR 条件</h4><p>MongoDB OR 条件语句使用了关键字 $or,语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">     &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure></p><h3 id="MongoDB-Limit与Skip方法"><a href="#MongoDB-Limit与Skip方法" class="headerlink" title="MongoDB Limit与Skip方法"></a>MongoDB Limit与Skip方法</h3><h4 id="MongoDB-Limit-方法"><a href="#MongoDB-Limit-方法" class="headerlink" title="MongoDB Limit() 方法"></a>MongoDB Limit() 方法</h4><p>如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</p><blockquote><p>db.COLLECTION_NAME.find().limit(NUMBER)</p></blockquote><p>注：如果你们没有指定limit()方法中的参数则显示集合中的所有数据。</p><h4 id="MongoDB-Skip-方法"><a href="#MongoDB-Skip-方法" class="headerlink" title="MongoDB Skip() 方法"></a>MongoDB Skip() 方法</h4><p>我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。</p><blockquote><p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</p></blockquote><p>注:skip()方法默认参数为 0 。</p><h3 id="MongoDB-排序"><a href="#MongoDB-排序" class="headerlink" title="MongoDB 排序"></a>MongoDB 排序</h3><p>在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。</p><blockquote><p>db.COLLECTION_NAME.find().sort({KEY:1})</p></blockquote><h3 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB 聚合"></a>MongoDB 聚合</h3><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p><h4 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h4><p>MongoDB中聚合的方法使用aggregate()。</p><blockquote><p>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</p></blockquote><h4 id="聚合的表达式"><a href="#聚合的表达式" class="headerlink" title="聚合的表达式"></a>聚合的表达式</h4><table><thead><tr><th>表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>$sum</td><td>计算总和。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td></tr><tr><td>$avg</td><td>计算平均值</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td></tr><tr><td>$min</td><td>获取集合中所有文档对应值得最小值。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td></tr><tr><td>$max</td><td>获取集合中所有文档对应值得最大值。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td></tr><tr><td>$push</td><td>在结果文档中插入值到一个数组中。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td></tr><tr><td>$addToSet</td><td>在结果文档中插入值到一个数组中，但不创建副本。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td></tr><tr><td>$first</td><td>根据资源文档的排序获取第一个文档数据。</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td></tr><tr><td>$last</td><td>根据资源文档的排序获取最后一个文档数据</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td></tr></tbody></table><h4 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h4><p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。</p><p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p><p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p><p>这里我们介绍一下聚合框架中常用的几个操作：</p><ul><li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</li><li>$limit：用来限制MongoDB聚合管道返回的文档数。</li><li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li>$group：将集合中的文档分组，可用于统计结果。</li><li>$sort：将输入文档排序后输出。</li><li>$geoNear：输出接近某一地理位置的有序文档。</li></ul><h3 id="spring-data-mongodb提供的丰富的api"><a href="#spring-data-mongodb提供的丰富的api" class="headerlink" title="spring-data-mongodb提供的丰富的api"></a>spring-data-mongodb提供的丰富的api</h3><p>在实际开发中，我们可以利用spring为我们提供的相关的操作mongodb的api进行数据的增删改查会方便很多，以下摘录就是实际开发中出现率最高的一批类及方法：</p><p>Criteria.java：组合查询条件，类似于我们sql中拼接where语句。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = Criteria.where(<span class="string">"..."</span>).is(...).and(<span class="string">"..."</span>).is(...);</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>Criteria</th><th>Mongodb</th><th>说明</th></tr></thead><tbody><tr><td>Criteria and (String key)</td><td>$and</td><td>并且</td></tr><tr><td>Criteria andOperator (Criteria…​ criteria)</td><td>$and</td><td>并且</td></tr><tr><td>Criteria orOperator (Criteria…​ criteria)</td><td>$or</td><td>或者</td></tr><tr><td>Criteria gt (Object o)</td><td>$gt</td><td>大于</td></tr><tr><td>Criteria gte (Object o)</td><td>$gte</td><td>大于等于</td></tr><tr><td>Criteria in (Object…​ o)</td><td>$in</td><td>包含</td></tr><tr><td>Criteria is (Object o)</td><td>$is</td><td>等于</td></tr><tr><td>Criteria lt (Object o)</td><td>$lt</td><td>小于</td></tr><tr><td>Criteria lte (Object o)</td><td>$lte</td><td>小等于</td></tr><tr><td>Criteria nin (Object…​ o)</td><td>$nin</td><td>不包含</td></tr></tbody></table><p>Query.java：类似于sql中将where语句和order by等组合起来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Query query = <span class="keyword">new</span> Query();</span><br><span class="line">query.addCriteria(criteria);</span><br><span class="line">query.with(<span class="keyword">new</span> Sort(<span class="keyword">new</span> Sort.Order(Sort.Direction.DESC, <span class="string">"age"</span>)));</span><br><span class="line">query.skip(<span class="number">5</span>).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p>AggregationOperation、Aggregation：聚合函数，类似于sql中count、sum等的函数</p><p>提供了类似于mongod管道操作功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AggregationOperation match = Aggregation.match(criteria);</span><br><span class="line">AggregationOperation sort = Aggregation.sort(Direction.DESC,<span class="string">"beginTime"</span>);</span><br><span class="line">AggregationOperation group = Aggregation.group(<span class="string">"$..."</span>).first().as(<span class="string">"..."</span>).avg()...</span><br><span class="line">Aggregation aggregation = Aggregation.newAggregation(match, sort, group);</span><br></pre></td></tr></table></figure></p><p>BasicDBObject.java 继承 BasicBSONObject 的一个 BSONObject 对象，类似于JSON对象。</p><p>MongoTemplate.java：spring的封装的api类，提供了各种对mongodb的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save();</span><br><span class="line">insert();</span><br><span class="line">upsert();</span><br><span class="line">find();</span><br><span class="line">findOne();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MongoDB-查询所有数据库&quot;&gt;&lt;a href=&quot;#MongoDB-查询所有数据库&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 查询所有数据库&quot;&gt;&lt;/a&gt;MongoDB 查询所有数据库&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;show dbs;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;MongoDB-切换-创建数据库&quot;&gt;&lt;a href=&quot;#MongoDB-切换-创建数据库&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 切换/创建数据库&quot;&gt;&lt;/a&gt;MongoDB 切换/创建数据库&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;use DATABASE_NAME;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果数据库不存在，则创建数据库，否则切换到指定数据库。&lt;/p&gt;
&lt;h3 id=&quot;MongoDB-删除数据库&quot;&gt;&lt;a href=&quot;#MongoDB-删除数据库&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 删除数据库&quot;&gt;&lt;/a&gt;MongoDB 删除数据库&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;db.dropDatabase()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="mongodb" scheme="https://duia.github.io/categories/JAVA/mongodb/"/>
    
      <category term="数据库" scheme="https://duia.github.io/categories/JAVA/mongodb/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://duia.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MongoDB" scheme="https://duia.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>CKEDITOR拖拽及单例化实现</title>
    <link href="https://duia.github.io/2017/03/30/CKEDITOR%E6%8B%96%E6%8B%BD%E5%8F%8A%E5%8D%95%E4%BE%8B%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    <id>https://duia.github.io/2017/03/30/CKEDITOR拖拽及单例化实现/</id>
    <published>2017-03-30T14:31:00.000Z</published>
    <updated>2019-05-21T23:00:00.003Z</updated>
    
    <content type="html"><![CDATA[<p><style type="text/css"><br>.sortClass { line-height: 34px; rgin-bottom: 5px; }<br>.editor{ border: 1px solid #ccc; padding: 5px; display: inline-block; width: 80%; }<br></style></p><div class="parentClass"><p></p></div><p></p><button type="button" class="btn btn-default add">新增一行</button><script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.min.js"></script><script src="//cdn.bootcss.com/ckeditor/4.0.1/ckeditor.js"></script><script type="text/javascript">(function(){    var myCkeditor;    $('.parentClass').sortable({        cancel:'.editor',        update: function (event, ui) {            ui.item.find('div[contenteditable=true]').blur();            if (myCkeditor) {                CKEDITOR.remove(myCkeditor);                $('#cke_'+myCkeditor.element.$.id).remove();                myCkeditor = undefined;            }            for (var editor in CKEDITOR.instances) {                $('#cke_'+editor).remove();                CKEDITOR.remove(CKEDITOR.instances[editor]);            }        }    });    $('.add').on('click', function(event) {        event.preventDefault();        var i = new Date().getTime();        $('.parentClass').append(htmlTemp(i));        // CKEDITOR.inline('editor'+i);    });    var htmlTemp = function(i){        var str = [];        str.push('<div class="sortClass">');        str.push('<span>选项 </span><div id="editor'+i+'" class="editor" contenteditable="true" placeholder="选项">'+i+'</div>');        str.push('</div>');        return str.join('');    }    var indexs = [0, 1, 2, 3, 4];    setTimeout(function(){        $.each(indexs, function(index, val) {            $('.parentClass').append(htmlTemp(index));        });        // CKEDITOR.inlineAll();    }, 1000);    $('.parentClass').off('blur', 'div[contenteditable=true]');    $('.parentClass').delegate('div[contenteditable=true]', 'blur', function(event){        event = event || window.event;        var $target = $(event.target);        $target.text()==''?$target.html(''):null;    });    $('.parentClass').off('focus', 'div[contenteditable=true]');    $('.parentClass').delegate('div[contenteditable=true]', 'focus', function(event){        event = event || window.event;        if (!myCkeditor) {//未实例化            myCkeditor = CKEDITOR.inline(event.target);        } else {            // console.log(myCkeditor.element.$.id);            // console.log(event.target.id);            if (myCkeditor.element.$.id === event.target.id) {            } else {//已实例化，但不是该文本框的实例                //清除并重新实例化                CKEDITOR.remove(myCkeditor);                $('#cke_'+myCkeditor.element.$.id).remove();                myCkeditor = CKEDITOR.inline(event.target);            }        }    });})();</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;br&gt;.sortClass { line-height: 34px; rgin-bottom: 5px; }&lt;br&gt;.editor{ border: 1px solid #ccc; padding: 5px; display:
      
    
    </summary>
    
      <category term="js" scheme="https://duia.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://duia.github.io/tags/js/"/>
    
      <category term="ckeditor" scheme="https://duia.github.io/tags/ckeditor/"/>
    
  </entry>
  
  <entry>
    <title>Java利用WebSocket实现长连接</title>
    <link href="https://duia.github.io/2017/02/26/Java%E5%88%A9%E7%94%A8WebSocket%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    <id>https://duia.github.io/2017/02/26/Java利用WebSocket实现长连接/</id>
    <published>2017-02-26T10:30:00.000Z</published>
    <updated>2019-05-11T15:00:00.083Z</updated>
    
    <content type="html"><![CDATA[<p>在java web开发中，考虑性能时其中有一点：尽可能的减少http请求数。这样除了能加快页面加载速度，更大的好处就是为服务器节省资源，降低服务器压力。但是有时候会遇到一些需求，例如需要实时的从服务器获取一些数据信息，我们最快的想到的办法就是写个定时器，不停的向服务器发送请求，来获取最新数据。这样恰恰与我们上边说的相违背。</p><p>以前的自己也是这样处理的，这种方式被称为“轮询”。可以想象到，当很多人同时打开网页时，轮询全部开启，服务器同一时间收到的请求会很大，后来慢慢的接触到了websocket，为解决这种问题带来了便利，总结学习一下，以供大家共同学习。<br><a id="more"></a><br>其实网上现在搜索一下也会有很多了案例，大部分都是通过三个类来实现的：一个拦截器——供用户建立握手链接，一个消息处理器——分发信息使用，还有一个关于websocket的配置类——配置websocket。</p><p>其实还有更简单的配置方法，spring-websocket为我们提供了很便利的使用方法，只通过一个websocket的配置类即可完成对websocket的支持，先上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wpc.web.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.config.MessageBrokerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.StompEndpointRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.wpc.web"</span>)<span class="comment">//这个路径为下边要配置的controller的包</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">"/socket"</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.enableSimpleBroker(<span class="string">"/topic"</span>);</span><br><span class="line">    registry.setApplicationDestinationPrefixes(<span class="string">"/app"</span>);</span><br><span class="line">    registry.setUserDestinationPrefix(<span class="string">"/user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>相关说明：</p></blockquote><blockquote><p>registerStompEndpoints(StompEndpointRegistry registry)<br>这个方法的作用是添加一个服务端点，来接收客户端的连接。</p></blockquote><blockquote><p>registry.addEndpoint(“/socket”)<br>表示添加了一个<code>/socket</code>端点，客户端就可以通过这个端点来进行连接。</p></blockquote><blockquote><p>withSockJS()的作用是开启SockJS支持</p></blockquote><blockquote><p>configureMessageBroker(MessageBrokerRegistry config)<br>这个方法的作用是定义消息代理，通俗一点讲就是设置消息连接请求的各种规范信息。</p></blockquote><blockquote><p>registry.enableSimpleBroker(“/topic”)<br>表示客户端订阅地址的前缀信息，也就是客户端接收服务端消息的地址的前缀信息（比较绕，看完整个例子，大概就能明白了）</p></blockquote><blockquote><p>registry.setApplicationDestinationPrefixes(“/app”)<br>指服务端接收地址的前缀，意思就是说客户端给服务端发消息的地址的前缀<br>上面两个方法定义的信息其实是相反的，一个定义了客户端接收的地址前缀，一个定义了客户端发送地址的前缀</p></blockquote><blockquote><p>registry.setUserDestinationPrefix(“/user”)<br>用于针对某个客户端接收地址的前缀，也就是说服务端如果需要有针对性的给客户端推送消息时，除了enableSimpleBroker中配置的前缀，需要额外的添加的前缀（更绕，下边举例说明）</p></blockquote><p>这里有比较绕一点的地方就是方法<code>configureMessageBroker</code>里边配置的几个路径，下边我会详细的举例说明的，在这之前需要配置一个controller，代码如下，这个controller其实就是咱们在spring-mvc中经常使用的控制器，唯一不同的是多了几个注解，这是spring为我们提供的，先看代码，后边说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wpc.web.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.MessageMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.SendTo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.annotation.SendToUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Principal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/socket"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/change-notice"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"/topic/notice"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/user-change-notice"</span>)</span><br><span class="line"><span class="meta">@SendToUser</span>(<span class="string">"/topic/notice"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">greeting2</span><span class="params">(String value, Principal principal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value + principal.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上述的基本配置信息，我们就可以编写基本功能了。这里先简单说明两个知识点：</p><blockquote><p>MessageMapping<br>Spring对于WebSocket封装的特别简单，提供了一个@MessageMapping注解，功能类似@RequestMapping，它是存在于Controller中的，定义一个消息的基本请求，功能也跟@RequestMapping类似，包括支持通配符的url定义等等</p></blockquote><blockquote><p>@SendTo、@SendToUser<br>定义了消息的目的地，会将方法返回的字符串定向发送到指定路径上。@SendTo是发送给所有客户端，@SendToUser是发送到指定客户端，具体发送指定客户端是通过session来区分的，所以使用该功能必须进行登陆，来产生session。</p></blockquote><p>以上所有配置就算是完成了，有几个比较绕一点的地方现在具体说明一下，就按上边的配置路径来直接说明：</p><ul><li>服务端向所有客户端发送信息的路径为<code>/topic/notice</code></li><li>服务端向指定客户端发送消息的路径为<code>/user/topic/notice</code></li><li>客户端向服务端发送信息的路径为<code>/app/change-notice</code>和<code>/app/user-change-notice</code></li></ul><p>topic、user、app全为websocket配置类中配置的前缀路径。为了简化说明，我上边在同一个方法上同时配置了@MessageMapping和@SendTo，也很容易理解——客户端发送到服务端来的消息直接再向所有的客户端发送出去。</p><p>如果单纯的要从服务端产生消息向客户端发送，spring也为我们提供了一个类——<code>SimpMessagingTemplate</code>，<code>SimpMessagingTemplate</code>是Spring-WebSocket内置的一个消息发送工具，可以将消息发送到指定的客户端。具体使用方法大家看看api。</p><p>前端代码</p><p>这里利用了<code>sockjs.js</code>和<code>stomp.js</code>。</p><p>其中SockJS 是一个浏览器上运行的 JavaScript 库，如果浏览器不支持 WebSocket，该库可以模拟对 WebSocket 的支持，实现浏览器和 Web 服务器之间低延迟、全双工、跨域的通讯通道。</p><p>Stomp 提供了客户端和代理之间进行广泛消息传输的框架。Stomp 是一个非常简单而且易用的通讯协议实现，尽管代理端的编写可能非常复杂，但是编写一个 Stomp 客户端却是很简单的事情，另外你可以使用 Telnet 来与你的 Stomp 代理进行交互。</p><p>以下是代码，很简单了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stompClient = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 开启socket连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(<span class="string">'/socket'</span>);        </span><br><span class="line">    stompClient = Stomp.over(socket);        </span><br><span class="line">    stompClient.connect(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">frame</span>) </span>&#123;            </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'notice socket connected!'</span>);</span><br><span class="line">        stompClient.subscribe(<span class="string">'/topic/notice'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//对所有信息监听</span></span><br><span class="line">        &#125;);</span><br><span class="line">        stompClient.subscribe(<span class="string">'/user/topic/notice'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//对针对性信息监听</span></span><br><span class="line">        &#125;);       </span><br><span class="line">    &#125;);    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 断开socket连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disconnect</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (stompClient != <span class="literal">null</span>) &#123;            </span><br><span class="line">        stompClient.disconnect();        </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Disconnected"</span>);    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 向‘/app/change-notice’服务端发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendName</span>(<span class="params"></span>) </span>&#123;        </span><br><span class="line">    stompClient.send(<span class="string">"/app/change-notice"</span>, &#123;&#125;, <span class="string">"......"</span>);    </span><br><span class="line">&#125;    </span><br><span class="line">connect();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java web开发中，考虑性能时其中有一点：尽可能的减少http请求数。这样除了能加快页面加载速度，更大的好处就是为服务器节省资源，降低服务器压力。但是有时候会遇到一些需求，例如需要实时的从服务器获取一些数据信息，我们最快的想到的办法就是写个定时器，不停的向服务器发送请求，来获取最新数据。这样恰恰与我们上边说的相违背。&lt;/p&gt;
&lt;p&gt;以前的自己也是这样处理的，这种方式被称为“轮询”。可以想象到，当很多人同时打开网页时，轮询全部开启，服务器同一时间收到的请求会很大，后来慢慢的接触到了websocket，为解决这种问题带来了便利，总结学习一下，以供大家共同学习。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="websocket" scheme="https://duia.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>jquery.validate自定义验证和返回多种结果</title>
    <link href="https://duia.github.io/2016/12/17/jquery.validate%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E5%92%8C%E8%BF%94%E5%9B%9E%E5%A4%9A%E7%A7%8D%E7%BB%93%E6%9E%9C/"/>
    <id>https://duia.github.io/2016/12/17/jquery.validate自定义验证和返回多种结果/</id>
    <published>2016-12-17T13:08:00.000Z</published>
    <updated>2019-05-20T02:00:00.003Z</updated>
    
    <content type="html"><![CDATA[<p>在使用jquery validate做表单验证时遇到如下需求：</p><p>验证需要请求服务器，且验证结果有多种情况，要根据不同验证结果提示不同信息。</p><p>很显然利用<code>remote</code>是无法满足需求的，所以只能通过自定义验证方法来进行验证，现总结如下：<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jQuery.validator.addMethod(<span class="string">"checkUser"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'...'</span>,<span class="comment">//请求路径</span></span><br><span class="line">        <span class="keyword">async</span>:<span class="literal">false</span>,<span class="comment">//要指定不能异步,必须等待后台服务校验完成再执行后续代码</span></span><br><span class="line">        type: <span class="string">"post"</span>,</span><br><span class="line">        dataType:<span class="string">"json"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            str: $.trim(value)</span><br><span class="line">        &#125;,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;<span class="comment">//返回数据data里包含了验证结果true或false以及提示信息</span></span><br><span class="line">            <span class="keyword">if</span>(data.result)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//动态修改自定义验证的提示信息</span></span><br><span class="line">                jQuery.validator.modifyMessages(<span class="string">"checkUser"</span>,data.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>服务器代码略，根据上边注解应该大概了解是什么样子了…</p><p>以下提供了一些常用的自定义验证，留档备用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符最小长度验证（一个中文字符长度为2）</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"stringMinLength"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> length = value.length;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.charCodeAt(i) &gt; <span class="number">127</span>) &#123;</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (length &gt;= param);</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"长度不能小于&#123;0&#125;!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符最大长度验证（一个中文字符长度为2）</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"stringMaxLength"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> length = value.length;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.charCodeAt(i) &gt; <span class="number">127</span>) &#123;</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (length &lt;= param);</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"长度不能大于&#123;0&#125;!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"stringCheck"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || <span class="regexp">/^[\u0391-\uFFE5\w]+$/</span>.test(value);</span><br><span class="line">    &#125;, <span class="string">"只能包括中文字、英文字母、数字和下划线"</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中文字两个字节       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"byteRangeLength"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> length = value.length;       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; value.length; i++)&#123;       </span><br><span class="line">            <span class="keyword">if</span>(value.charCodeAt(i) &gt; <span class="number">127</span>)&#123;       </span><br><span class="line">                length++;       </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || ( length &gt;= param[<span class="number">0</span>] &amp;&amp; length &lt;= param[<span class="number">1</span>] );       </span><br><span class="line">    &#125;, <span class="string">"请确保输入的值在3-15个字节之间(一个中文字算2个字节)"</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符验证</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"string"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || <span class="regexp">/^[\u0391-\uFFE5\w]+$/</span>.test(value);</span><br><span class="line">    &#125;, <span class="string">"不允许包含特殊符号!"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须以特定字符串开头验证</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"begin"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> begin = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^"</span> + param);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (begin.test(value));</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"必须以 &#123;0&#125; 开头!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证两次输入值是否不相同</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"notEqualTo"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value != $(param).val();</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"两次输入不能相同!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证值不允许与特定值等于</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"notEqual"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value != param;</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"输入值不允许为&#123;0&#125;!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证值必须大于特定值(不能等于)</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"gt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt; param;</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"输入值必须大于&#123;0&#125;!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证值小数位数不能超过两位</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"decimal"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> decimal = <span class="regexp">/^-?\d+(\.\d&#123;1,2&#125;)?$/</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (decimal.test(value));</span><br><span class="line">    &#125;, $.validator.format(<span class="string">"小数位数不能超过两位!"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字母数字</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"alnum"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || <span class="regexp">/^[a-zA-Z0-9]+$/</span>.test(value);</span><br><span class="line">    &#125;, <span class="string">"只能包括英文字母和数字"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 汉字</span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"chcharacter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tel = <span class="regexp">/^[\u4e00-\u9fa5]+$/</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (tel.test(value));</span><br><span class="line">    &#125;, <span class="string">"请输入汉字"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 身份证号码验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isIdCardNo"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || <span class="regexp">/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/</span>.test(value)||<span class="regexp">/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d&#123;4&#125;)|\d&#123;3&#125;[A-Z])$/</span>.test(value);</span><br><span class="line">    &#125;, <span class="string">"请正确输入您的身份证号码"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手机号码验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isMobile"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;       </span><br><span class="line">        <span class="keyword">var</span> length = value.length;   </span><br><span class="line">        <span class="keyword">var</span> mobile = <span class="regexp">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/</span>;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (length == <span class="number">11</span> &amp;&amp; mobile.test(value));</span><br><span class="line">    &#125;, <span class="string">"请正确填写您的手机号码"</span>);       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 电话号码验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isTel"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;       </span><br><span class="line">        <span class="keyword">var</span> tel = <span class="regexp">/^\d&#123;3,4&#125;-?\d&#123;7,9&#125;$/</span>;    <span class="comment">//电话号码格式010-12345678   </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (tel.test(value));       </span><br><span class="line">    &#125;, <span class="string">"请正确填写您的电话号码"</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 联系电话(手机/电话皆可)验证   </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isPhone"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value,element</span>) </span>&#123;   </span><br><span class="line">        <span class="keyword">var</span> length = value.length;   </span><br><span class="line">        <span class="keyword">var</span> mobile = <span class="regexp">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/</span>;   </span><br><span class="line">        <span class="keyword">var</span> tel = <span class="regexp">/^\d&#123;3,4&#125;-?\d&#123;7,9&#125;$/</span>;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (tel.test(value) || mobile.test(value));</span><br><span class="line">    &#125;, <span class="string">"请正确填写您的联系电话"</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 邮政编码验证       </span></span><br><span class="line">    jQuery.validator.addMethod(<span class="string">"isZipCode"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;       </span><br><span class="line">        <span class="keyword">var</span> tel = <span class="regexp">/^[0-9]&#123;6&#125;$/</span>;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.optional(element) || (tel.test(value));       </span><br><span class="line">    &#125;, <span class="string">"请正确填写您的邮政编码"</span>);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用jquery validate做表单验证时遇到如下需求：&lt;/p&gt;
&lt;p&gt;验证需要请求服务器，且验证结果有多种情况，要根据不同验证结果提示不同信息。&lt;/p&gt;
&lt;p&gt;很显然利用&lt;code&gt;remote&lt;/code&gt;是无法满足需求的，所以只能通过自定义验证方法来进行验证，现总结如下：&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="https://duia.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://duia.github.io/tags/js/"/>
    
      <category term="jquery" scheme="https://duia.github.io/tags/jquery/"/>
    
      <category term="dataTables" scheme="https://duia.github.io/tags/dataTables/"/>
    
  </entry>
  
  <entry>
    <title>spring源码阅读-context</title>
    <link href="https://duia.github.io/2016/11/27/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-context/"/>
    <id>https://duia.github.io/2016/11/27/spring源码阅读-context/</id>
    <published>2016-11-27T03:25:00.000Z</published>
    <updated>2019-05-19T15:00:00.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>入口方法在BeanDefinitionParserDelegate.parseCustomElement：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br></pre></td></tr></table></figure><p>parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parserContext.getReaderContext().fatal(</span><br><span class="line">            <span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>localName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。</p><h1 id="annotation-config"><a href="#annotation-config" class="headerlink" title="annotation-config"></a>annotation-config</h1><p>AnnotationConfigBeanDefinitionParser.parse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回null</span></span><br><span class="line">    Object source = parserContext.extractSource(element);</span><br><span class="line">    <span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">            AnnotationConfigUtils.</span><br><span class="line">                registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line">    <span class="comment">// Register component for the surrounding &lt;context:annotation-config&gt; element.</span></span><br><span class="line">    CompositeComponentDefinition compDefinition = </span><br><span class="line">        <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">    parserContext.pushContainingComponent(compDefinition);</span><br><span class="line">    <span class="comment">// Nest the concrete beans in the surrounding component.</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Finally register the composite component.</span></span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">    parserContext.popAndRegisterContainingComponent();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanPostProcessor注册"><a href="#BeanPostProcessor注册" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h2><p>AnnotationConfigUtils.registerAnnotationConfigProcessors源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数其实就是DefaultListableBeanFactory,第二个参数为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将registery强转为DefaultListableBeanFactory类型</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> </span><br><span class="line">            ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AnnotationAwareOrderComparator"><a href="#AnnotationAwareOrderComparator" class="headerlink" title="AnnotationAwareOrderComparator"></a>AnnotationAwareOrderComparator</h3><p>其继承体系如下:</p><p><img src="http://tu.duia.online/d3cd551dfbc11e93d7b3ef464e4b29ef" alt="Comparator继承体系"></p><p>其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考:</p><p><a href="http://www.tuicool.com/articles/VnqUv2" target="_blank" rel="noopener">Spring 4.2新特性-使用@Order调整配置类加载顺序</a></p><h3 id="ContextAnnotationAutowireCandidateResolver"><a href="#ContextAnnotationAutowireCandidateResolver" class="headerlink" title="ContextAnnotationAutowireCandidateResolver"></a>ContextAnnotationAutowireCandidateResolver</h3><p>此类用以决定一个bean是否可以当作一个依赖的候选者。其类图:</p><p><img src="http://tu.duia.online/9fec1500854a988e570244930dec7b6a" alt="ContextAnnotationAutowireCandidateResolver类图"></p><h3 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>此类用于处理标注了@Configuration注解的类。类图:</p><p><img src="http://tu.duia.online/e5b049a9c5420a98b778b409fa51066a" alt="ConfigurationClassPostProcessor类图"></p><h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>此类便用于对标注了@Autowire等注解的bean或是方法进行注入。</p><p><img src="http://tu.duia.online/7612add63fe6f0307267d9902d31ec0b" alt="AutowiredAnnotationBeanPostProcessor类图"></p><h3 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。</p><h3 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsr250Present =</span><br><span class="line">    ClassUtils.isPresent(<span class="string">"javax.annotation.Resource"</span>, AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure><p>此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图:</p><p><img src="http://tu.duia.online/fa4df4ce90fb570855653c7e8f4bf767" alt="CommonAnnotationBeanPostProcessor类图"></p><h3 id="PersistenceAnnotationBeanPostProcessor"><a href="#PersistenceAnnotationBeanPostProcessor" class="headerlink" title="PersistenceAnnotationBeanPostProcessor"></a>PersistenceAnnotationBeanPostProcessor</h3><p>用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jpaPresent =</span><br><span class="line">    ClassUtils.isPresent(<span class="string">"javax.persistence.EntityManagerFactory"</span>, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader()) &amp;&amp;</span><br><span class="line">    <span class="comment">//org.springframework.orm包</span></span><br><span class="line">    ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure><p>rt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。</p><h3 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系:</p><p><img src="http://tu.duia.online/cd1a542d1c14d51080a35a0da3523f0a" alt="EventListenerMethodProcessor类图"></p><h3 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a>DefaultEventListenerFactory</h3><p>此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图:</p><p><img src="http://tu.duia.online/0c0944f3d37508e5b80b7eca693fec3a" alt="DefaultEventListenerFactory类图"></p><h2 id="逻辑关系整理"><a href="#逻辑关系整理" class="headerlink" title="逻辑关系整理"></a>逻辑关系整理</h2><p>普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图:</p><p><img src="http://tu.duia.online/d04e58203466f1480dbc93f15e64dc14" alt="CompositeComponentDefinition类图"></p><p>最终形成的数据结构如下图:</p><p><img src="http://tu.duia.online/49c83baa78343a17ec6107091c13ed05" alt="数据结构"></p><p>不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="ConfigurationClassPostProcessor-1"><a href="#ConfigurationClassPostProcessor-1" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure><p>注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。</p><h4 id="postProcessBeanDefinitionRegistry"><a href="#postProcessBeanDefinitionRegistry" class="headerlink" title="postProcessBeanDefinitionRegistry"></a>postProcessBeanDefinitionRegistry</h4><p>此方法大体由两部分组成。</p><h5 id="BeanPostProcessor注册-1"><a href="#BeanPostProcessor注册-1" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h5><p>此部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    RootBeanDefinition iabpp = <span class="keyword">new</span> RootBeanDefinition(ImportAwareBeanPostProcessor.class);</span><br><span class="line">    iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);</span><br><span class="line">    RootBeanDefinition ecbpp = <span class="keyword">new</span> RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class);</span><br><span class="line">    ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ImportAwareBeanPostProcessor"><a href="#ImportAwareBeanPostProcessor" class="headerlink" title="ImportAwareBeanPostProcessor"></a>ImportAwareBeanPostProcessor</h6><p>是ConfigurationClassPostProcessor的私有内部类。其类图:</p><p><img src="http://tu.duia.online/0468b8bd2da0743c046df44c8b8a633d" alt="ImportAwareBeanPostProcessor类图"></p><p>此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起:</p><p>有一个类负责生成Student bean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setAge(<span class="number">22</span>);</span><br><span class="line">        student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"importaware"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(StudentConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentConfig studentConfig;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleBean <span class="title">getSimpleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bean依赖</span></span><br><span class="line">        SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean(studentConfig.student());</span><br><span class="line">        <span class="keyword">return</span> simpleBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = </span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(SimpleBeanConfig.class);</span><br><span class="line">    SimpleBean simpleBean = context.getBean(SimpleBean.class);</span><br><span class="line">    System.out.println(simpleBean.getStudent().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以ImportAware接口的作用就是<strong>使被引用的配置类可以获得引用类的相关信息</strong>。</p><h6 id="EnhancedConfigurationBeanPostProcessor"><a href="#EnhancedConfigurationBeanPostProcessor" class="headerlink" title="EnhancedConfigurationBeanPostProcessor"></a>EnhancedConfigurationBeanPostProcessor</h6><p>用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。</p><h5 id="类解析"><a href="#类解析" class="headerlink" title="类解析"></a>类解析</h5><p>这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。</p><h6 id="bean名字生成策略"><a href="#bean名字生成策略" class="headerlink" title="bean名字生成策略"></a>bean名字生成策略</h6><p>对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。</p><p>ConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">SingletonBeanRegistry singletonRegistry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">    singletonRegistry = (SingletonBeanRegistry) registry;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; </span><br><span class="line">        <span class="comment">//org.springframework.context.annotation.internalConfigurationBeanNameGenerator</span></span><br><span class="line">        singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.</span><br><span class="line">            getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">        <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">        <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认是一个AnnotationBeanNameGenerator对象，其类图:</p><p><img src="http://tu.duia.online/30892dbfe202f07e88c0821639febfc9" alt="BeanNameGenerator类图"></p><p>那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: <strong>配置解析、BeanDefinition加载之后，Singleton初始化之前</strong>，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。</p><h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h4><p>此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。简略版的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = </span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line">    <span class="comment">//寻找@Configuration的BeanDefinition</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">        Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">             <span class="comment">//替换</span></span><br><span class="line">            beanDef.setBeanClass(enhancedClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigurationClassEnhancer.newEnhancer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; superclass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(superclass);</span><br><span class="line">    <span class="comment">//这里印证了前面EnhancedConfigurationBeanPostProcessor的说明</span></span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">    enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    <span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CALLBACK_FILTER是个什么东西呢:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConditionalCallbackFilter CALLBACK_FILTER = </span><br><span class="line">    <span class="keyword">new</span> ConditionalCallbackFilter(CALLBACKS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">    <span class="keyword">new</span> BeanMethodInterceptor(),</span><br><span class="line">    <span class="keyword">new</span> BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">    NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这么做的原因有两个:</p><ul><li><p>提供Scope支持:</p><p>我们可以使用@Scope注解来使用注解的方式配置其Scope:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setAge(<span class="number">22</span>);</span><br><span class="line">    student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。</p></li><li><p>实现EnhancedConfiguration接口</p></li></ul><h3 id="AutowiredAnnotationBeanPostProcessor-1"><a href="#AutowiredAnnotationBeanPostProcessor-1" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。</p><h4 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><h5 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h5><p>其中前者首先被调用，时机是当BeanDefinition被合并(和父Bean)，但是还没有用来创建Bean实例时。回顾下其调用入口:</p><p>AbstractAutowireCapableBeanFactory.doCreateBean(简略):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applyMergedBeanDefinitionPostProcessors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, </span></span></span><br><span class="line"><span class="function"><span class="params">    String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String  beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findAutowiringMetadata:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">    <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">            metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                &#125;</span><br><span class="line">                metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">                <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>injectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因:</p><ul><li>假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。</li><li>对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。</li></ul><p>可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。</p><p>@Autowire注解的扫描在buildAutowiringMetadata方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = </span><br><span class="line">        <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line">    <span class="comment">//循环检测父类</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =</span><br><span class="line">                <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, <span class="keyword">new</span> ReflectionUtils.FieldCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//不支持静态变量</span></span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">                <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation should be used on </span></span><br><span class="line"><span class="string">                                methods with parameters: "</span> + method);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，<strong>Spring注入注解可以配置在此bean的父类上</strong>。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。</p><h5 id="变量扫描"><a href="#变量扫描" class="headerlink" title="变量扫描"></a>变量扫描</h5><p>之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。</p><p>ReflectionUtils的实现其实就是访问者模式，其源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithLocalFields</span><span class="params">(Class&lt;?&gt; clazz, FieldCallback fc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Field field : getDeclaredFields(clazz)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.doWith(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>determineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。</p><h5 id="方法扫描"><a href="#方法扫描" class="headerlink" title="方法扫描"></a>方法扫描</h5><h6 id="bridge方法"><a href="#bridge方法" class="headerlink" title="bridge方法"></a>bridge方法</h6><p>就是方法扫描的第一行源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br></pre></td></tr></table></figure><p>此句代码的作用是<strong>判断method是否是bridge方法，如果是，寻找其真正的方法。</strong>这里的bridge方法并不是所谓的bridge模式。</p><p>有这样的demo代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意父类的返回类型是Object</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : MyList.class.getDeclaredMethods()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name: "</span> + method.getName() + <span class="string">", return: "</span> + method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: get, return: class java.lang.String</span><br><span class="line">name: get, return: class java.lang.Object</span><br></pre></td></tr></table></figure><p>通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method; returns &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if and only if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method as defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBridge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getModifiers() &amp; Modifier.BRIDGE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。</p><p>可以参考: <a href="http://ifeve.com/syntethic-and-bridge-methods/" target="_blank" rel="noopener">Java那些不为人知的特殊方法</a></p><p>到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。</p><h6 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h6><p>用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。</p><h4 id="postProcessPropertyValues"><a href="#postProcessPropertyValues" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><h5 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h5><p>AbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。</p><h5 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h5><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInjection</span><span class="params">(Object bean)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = bean.getClass();</span><br><span class="line">     <span class="comment">// 查找缓存</span></span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, <span class="keyword">null</span>);</span><br><span class="line">    metadata.inject(bean, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。</p><h6 id="Field注入"><a href="#Field注入" class="headerlink" title="Field注入"></a>Field注入</h6><p>实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。</p><h6 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h6><p>实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。</p><h3 id="RequiredAnnotationBeanPostProcessor-1"><a href="#RequiredAnnotationBeanPostProcessor-1" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。</p><h4 id="postProcessMergedBeanDefinition-1"><a href="#postProcessMergedBeanDefinition-1" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>空实现，就是这么任性:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="postProcessPropertyValues-1"><a href="#postProcessPropertyValues-1" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.validatedBeanNames.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip(<span class="keyword">this</span>.beanFactory, beanName)) &#123;</span><br><span class="line">            List&lt;String&gt; invalidProperties = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123;</span><br><span class="line">                    invalidProperties.add(pd.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!invalidProperties.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(buildExceptionMessage</span><br><span class="line">                    (invalidProperties, beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.validatedBeanNames.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h5><p>validatedBeanNames是一个Set<string>类型，对于已经检查过的bean，将其name加入Set，防止做无用功。</string></p><h5 id="PropertyDescriptor-1"><a href="#PropertyDescriptor-1" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h5><p>从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢?</p><p>AbstractAutowireCapableBeanFactory.populateBean相关代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filterPropertyDescriptorsForDependencyCheck单参数方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) &#123;</span><br><span class="line">    List&lt;PropertyDescriptor&gt; pds =</span><br><span class="line">            <span class="keyword">new</span> LinkedList&lt;PropertyDescriptor&gt;(Arrays.asList(bw.getPropertyDescriptors()));</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;PropertyDescriptor&gt; it = pds.iterator(); it.hasNext();) &#123;</span><br><span class="line">        PropertyDescriptor pd = it.next();</span><br><span class="line">        <span class="keyword">if</span> (isExcludedFromDependencyCheck(pd)) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pds.toArray(<span class="keyword">new</span> PropertyDescriptor[pds.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢?</p><p>BeanWrapperImpl.getPropertyDescriptors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</span><br><span class="line">    <span class="keyword">return</span> getCachedIntrospectionResults().getPropertyDescriptors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> CachedIntrospectionResults <span class="title">getCachedIntrospectionResults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Assert.state(getWrappedInstance() != <span class="keyword">null</span>, <span class="string">"BeanWrapper does not hold a bean instance"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cachedIntrospectionResults == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cachedIntrospectionResults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这时BeanWrapper便会把自己”内省”一遍。这从侧面说明@Reqired注解只对setter方法有效。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>有一个bean如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"simpleBean"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果:</p><p><img src="http://tu.duia.online/48f64d414119e0795f9c00f04cad26ea" alt="@Required测试"></p><h3 id="CommonAnnotationBeanPostProcessor-1"><a href="#CommonAnnotationBeanPostProcessor-1" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。</p><h4 id="postProcessMergedBeanDefinition-2"><a href="#postProcessMergedBeanDefinition-2" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>此方法的执行入口以及调用时机上面已经说过了。其源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String  beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findResourceMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h5><p>可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String  beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是<strong>遍历所有method寻找初始化和销毁方法标记</strong>。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setInitAnnotationType(PostConstruct.class);</span><br><span class="line">    setDestroyAnnotationType(PreDestroy.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个标签来自于javax.annotation包。那么怎么自定义呢?</p><p>CommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initAnnotationType"</span> <span class="attr">value</span>=<span class="string">"annotation.Init"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Init是一个很简单的自定义注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Init &#123;&#125;</span><br></pre></td></tr></table></figure><p>在自己的bean中使用此注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Init</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Init!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Spring便可以看到效果。</p><p>另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，<strong>Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持</strong>。为了达到只有一个实例的目的，需要为前面的配置加上ID。</p><h5 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h5><p>findResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。</p><h4 id="postProcessPropertyValues-2"><a href="#postProcessPropertyValues-2" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>套路很明显了。</p><h4 id="postProcessBeforeInitialization"><a href="#postProcessBeforeInitialization" class="headerlink" title="postProcessBeforeInitialization"></a>postProcessBeforeInitialization</h4><p>实现在父类InitDestroyAnnotationBeanPostProcessor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">    metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invokeInitMethods:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(Object target, String beanName)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Collection&lt;LifecycleElement&gt; initMethodsToIterate =</span><br><span class="line">            (<span class="keyword">this</span>.checkedInitMethods != <span class="keyword">null</span> ? <span class="keyword">this</span>.checkedInitMethods : <span class="keyword">this</span>.initMethods);</span><br><span class="line">    <span class="keyword">if</span> (!initMethodsToIterate.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleElement element : initMethodsToIterate) &#123;</span><br><span class="line">             <span class="comment">// 反射调用</span></span><br><span class="line">            element.invoke(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过从源码来看应该支持多个init方法。</p><h4 id="postProcessBeforeDestruction"><a href="#postProcessBeforeDestruction" class="headerlink" title="postProcessBeforeDestruction"></a>postProcessBeforeDestruction</h4><p>反射调用销毁方法，没啥说的了。</p><h3 id="EventListenerMethodProcessor-1"><a href="#EventListenerMethodProcessor-1" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>就一个值得关注的方法: afterSingletonsInstantiated。</p><h5 id="入口-2"><a href="#入口-2" class="headerlink" title="入口"></a>入口</h5><p>DefaultListableBeanFactory.preInstantiateSingletons相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = </span><br><span class="line">            (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><p>略过。</p><h1 id="component-scan"><a href="#component-scan" class="headerlink" title="component-scan"></a>component-scan</h1><p>ComponentScanBeanDefinitionParser.parse源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base-package属性</span></span><br><span class="line">    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">    <span class="comment">// 解析占位符</span></span><br><span class="line">    basePackage = parserContext.getReaderContext().getEnvironment()</span><br><span class="line">        .resolvePlaceholders(basePackage);</span><br><span class="line">    <span class="comment">//分割成数据</span></span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    <span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClassPathBeanDefinitionScanner <span class="title">configureScanner</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> useDefaultFilters = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123;</span><br><span class="line">        useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delegate bean definition registration to scanner class.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = createScanner</span><br><span class="line">        (parserContext.getReaderContext(), useDefaultFilters);</span><br><span class="line">    scanner.setResourceLoader(parserContext.getReaderContext().getResourceLoader());</span><br><span class="line">    scanner.setEnvironment(parserContext.getReaderContext().getEnvironment());</span><br><span class="line">    scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());</span><br><span class="line">    scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123;</span><br><span class="line">        scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    parseBeanNameGenerator(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseScope(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseTypeFilters(element, scanner, parserContext);</span><br><span class="line">    <span class="keyword">return</span> scanner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始按顺序分部分说明。</p><h3 id="use-default-filters"><a href="#use-default-filters" class="headerlink" title="use-default-filters"></a>use-default-filters</h3><p>component-scan注解会默认扫描喜闻乐见的@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。</p><h3 id="扫描器-创建-amp-初始化"><a href="#扫描器-创建-amp-初始化" class="headerlink" title="扫描器:创建 &amp; 初始化"></a>扫描器:创建 &amp; 初始化</h3><p>就是createScanner方法和下面那一坨setter方法，没啥好说的。</p><h3 id="resource-pattern"><a href="#resource-pattern" class="headerlink" title="resource-pattern"></a>resource-pattern</h3><p>用以配置扫描器扫描的路径，默认<code>**/*.class</code>。</p><h3 id="name-generator"><a href="#name-generator" class="headerlink" title="name-generator"></a>name-generator</h3><p>可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。</p><h3 id="scope-resolver"><a href="#scope-resolver" class="headerlink" title="scope-resolver"></a>scope-resolver</h3><p>指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图:</p><p><img src="http://tu.duia.online/b0bfa94c5d8e4aca4aa4a2a4dc28fc72" alt="ScopeMetadataResolver类图"></p><p>默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。</p><h3 id="scoped-proxy"><a href="#scoped-proxy" class="headerlink" title="scoped-proxy"></a>scoped-proxy</h3><p>此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。</p><h3 id="exclude-filter-include-filter"><a href="#exclude-filter-include-filter" class="headerlink" title="exclude-filter/include-filter"></a>exclude-filter/include-filter</h3><p>用法示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"base"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"javax.annotation.Resource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>parseTypeFilters方法负责此部分的解析，只贴部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (INCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addIncludeFilter(typeFilter);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (EXCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addExcludeFilter(typeFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="annotation-config-1"><a href="#annotation-config-1" class="headerlink" title="annotation-config"></a>annotation-config</h3><p>此属性等同于&lt;context:annotation-config /&gt;配置，默认就是true，也就是说，如果配置了context:component-scan其实就没有必要配置annotation-config 了。</p><h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>入口方法便是ClassPathBeanDefinitionScanner.doScan:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">         <span class="comment">// 逐包扫描</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                 <span class="comment">// 为BeanDefinition设置默认的属性</span></span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations</span><br><span class="line">                    ((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode</span><br><span class="line">                    (scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逐包扫描-BeanDefinition解析"><a href="#逐包扫描-BeanDefinition解析" class="headerlink" title="逐包扫描/BeanDefinition解析"></a>逐包扫描/BeanDefinition解析</h3><p>扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图:</p><p><img src="http://tu.duia.online/82b40a73e614cba7ebe65397d8c56963" alt="MetadataReader类图"></p><p>对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SimpleMetadataReader(Resource resource, ClassLoader classLoader) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> BufferedInputStream(resource.getInputStream());</span><br><span class="line">    ClassReader classReader;</span><br><span class="line">    classReader = <span class="keyword">new</span> ClassReader(is);</span><br><span class="line"></span><br><span class="line">    AnnotationMetadataReadingVisitor visitor = <span class="keyword">new</span> AnnotationMetadataReadingVisitor(classLoader);</span><br><span class="line">    classReader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.annotationMetadata = visitor;</span><br><span class="line">    <span class="comment">// (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)</span></span><br><span class="line">    <span class="keyword">this</span>.classMetadata = visitor;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析的关键便在于AnnotationMetadataReadingVisitor，其类图:</p><p><img src="http://tu.duia.online/c454f6c01aeffa715882fb41a4878fc7" alt="AnnotationMetadataReadingVisitor类图"></p><p>核心在于其visitAnnotation方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(<span class="keyword">final</span> String desc, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">    String className = Type.getType(desc).getClassName();</span><br><span class="line">    <span class="keyword">this</span>.annotationSet.add(className);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnnotationAttributesReadingVisitor(</span><br><span class="line">        className, <span class="keyword">this</span>.attributesMap, <span class="keyword">this</span>.metaAnnotationMap, <span class="keyword">this</span>.classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图:</p><p><img src="http://tu.duia.online/8ce3498b680dd491f461567ca7258ed7" alt="ScannedGenericBeanDefinition类图"></p><h3 id="Scope解析"><a href="#Scope解析" class="headerlink" title="@Scope解析"></a>@Scope解析</h3><p>AnnotationScopeMetadataResolver.resolveScopeMetadata:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScopeMetadata <span class="title">resolveScopeMetadata</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    ScopeMetadata metadata = <span class="keyword">new</span> ScopeMetadata();</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line">         <span class="comment">// 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">                annDef.getMetadata(), <span class="keyword">this</span>.scopeAnnotationType);</span><br><span class="line">        <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// @Scope值</span></span><br><span class="line">            metadata.setScopeName(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">            ScopedProxyMode proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line">            <span class="keyword">if</span> (proxyMode == <span class="keyword">null</span> || proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">                proxyMode = <span class="keyword">this</span>.defaultProxyMode;</span><br><span class="line">            &#125;</span><br><span class="line">            metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxyMode和xml的scoped-proxy属性是一个概念:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = <span class="string">"singleton"</span>, proxyMode = ScopedProxyMode.DEFAULT)</span><br></pre></td></tr></table></figure><p><strong>XML的属性是全局的配置，这个是局部(针对单个bean)的配置</strong>，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。</p><h3 id="bean名字生成"><a href="#bean名字生成" class="headerlink" title="bean名字生成"></a>bean名字生成</h3><p>AnnotationBeanNameGenerator.generateBeanName:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Explicit bean name found.</span></span><br><span class="line">            <span class="keyword">return</span> beanName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line">    <span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据注解"><a href="#根据注解" class="headerlink" title="根据注解"></a>根据注解</h4><p>默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">    AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">    Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">    String beanName = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 遍历当前bean拥有的所有类级注解</span></span><br><span class="line">    <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">         <span class="comment">// 获取此注解所有的属性</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line">        <span class="keyword">if</span> (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) &#123;</span><br><span class="line">            Object value = attributes.get(<span class="string">"value"</span>);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String strVal = (String) value;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    beanName = strVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isStereotypeWithNameValue</span><span class="params">(String annotationType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Set&lt;String&gt; metaAnnotationTypes, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// org.springframework.stereotype.Component</span></span><br><span class="line">    <span class="keyword">boolean</span> isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">        (metaAnnotationTypes != <span class="keyword">null</span> &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) ||</span><br><span class="line">        annotationType.equals(<span class="string">"javax.annotation.ManagedBean"</span>) ||</span><br><span class="line">        annotationType.equals(<span class="string">"javax.inject.Named"</span>);</span><br><span class="line">    <span class="keyword">return</span> (isStereotype &amp;&amp; attributes != <span class="keyword">null</span> &amp;&amp; attributes.containsKey(<span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>metaAnnotationTypes用以判断元注解，针对这种情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。</p><h4 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h4><p>如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base.SimpleBean -&gt; SimpleBean</span></span><br><span class="line">    String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class="line">    <span class="comment">//SimpleBean -&gt; simpleBean</span></span><br><span class="line">    <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，对于内部类: OuterClassName.InnerClassName -&gt; outerClassName.InnerClassName.</p><h3 id="其它注解解析"><a href="#其它注解解析" class="headerlink" title="其它注解解析"></a>其它注解解析</h3><p>入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"student"</span>)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_APPLICATION)</span><br><span class="line"><span class="meta">@Description</span>(<span class="string">"This is a simple bean."</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个”hint”，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。</p><h3 id="冲突检测"><a href="#冲突检测" class="headerlink" title="冲突检测"></a>冲突检测</h3><p>Spring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkCandidate</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有同名的，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanDefinition existingDef = <span class="keyword">this</span>.registry.getBeanDefinition(beanName);</span><br><span class="line">    BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();</span><br><span class="line">    <span class="keyword">if</span> (originatingDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        existingDef = originatingDef;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isCompatible(beanDefinition, existingDef)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConflictingBeanDefinitionException(<span class="string">"冲突啦!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isCompatible用于判断和之前的BeanDefinition是否兼容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCompatible</span><span class="params">(BeanDefinition newDefinition, BeanDefinition existingDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//// explicitly registered overriding bean</span></span><br><span class="line">    <span class="keyword">return</span> (!(existingDefinition <span class="keyword">instanceof</span> ScannedGenericBeanDefinition) || </span><br><span class="line">            <span class="comment">//// scanned same file twice</span></span><br><span class="line">            newDefinition.getSource().equals(existingDefinition.getSource()) || </span><br><span class="line">            <span class="comment">// scanned equivalent class twice</span></span><br><span class="line">            newDefinition.equals(existingDefinition));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<strong>如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的。</strong></p><h3 id="代理生成"><a href="#代理生成" class="headerlink" title="代理生成"></a>代理生成</h3><p>入口: ClassPathBeanDefinitionScanner.doScan:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure><p>AnnotationConfigUtils.applyScopedProxyMode:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BeanDefinitionHolder <span class="title">applyScopedProxyMode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line">    <span class="comment">// 基本都是从这里跑了</span></span><br><span class="line">    <span class="keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">    <span class="keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点:</p><ul><li>这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。</li><li>被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。</li><li>将被代理者以scopedTarget.原名字注册到容器，返回代理者。</li><li>代理者和被代理者同时存在于容器中。</li></ul><p>可以看出，这其实是一个偷天换日的过程。</p><p>做个实验:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boostrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">        SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">         System.out.println(bean.getClass().getName());</span><br><span class="line">         context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleBean已开启代理，输出的结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base.SimpleBean$$EnhancerBySpringCGLIB$$27256c61</span><br></pre></td></tr></table></figure><p>那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢?</p><p>DefaultListableBeanFactory.getBean(Class<t> requiredType, Object… args)部分源码:</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] beanNames = getBeanNamesForType(requiredType);</span><br><span class="line"><span class="comment">//不止一个满足条件(代理者和被代理者)</span></span><br><span class="line"><span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">         <span class="comment">// here</span></span><br><span class="line">        <span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">            autowireCandidates.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (autowireCandidates.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        beanNames = autowireCandidates.toArray(<span class="keyword">new</span> String[autowireCandidates.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。</p><h3 id="BeanDefinition注册"><a href="#BeanDefinition注册" class="headerlink" title="BeanDefinition注册"></a>BeanDefinition注册</h3><p>你懂的。</p><h2 id="Component注册"><a href="#Component注册" class="headerlink" title="Component注册"></a>Component注册</h2><p>套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。</p><h1 id="property-override"><a href="#property-override" class="headerlink" title="property-override"></a>property-override</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo:</p><p>定义如下的属性文件(property.properties):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.name=dog</span><br></pre></td></tr></table></figure><p>格式为: bean名字.属性名字=值。由如下的bean:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进行如下的配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"property.properties"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>运行如下的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">    SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">    System.out.println(bean.getStudent().getName());</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的便是dog，而不是skywalker。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下:</p><p><img src="http://tu.duia.online/b3a522d200541134265ac2ab1254cded" alt="PropertyOverrideBeanDefinitionParser类图"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码: </p><p>AbstractPropertyLoadingBeanDefinitionParser.doParse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    String location = element.getAttribute(<span class="string">"location"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(location)) &#123;</span><br><span class="line">        String[] locations = StringUtils.commaDelimitedListToStringArray(location);</span><br><span class="line">        builder.addPropertyValue(<span class="string">"locations"</span>, locations);</span><br><span class="line">    &#125;</span><br><span class="line">    String propertiesRef = element.getAttribute(<span class="string">"properties-ref"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(propertiesRef)) &#123;</span><br><span class="line">        builder.addPropertyReference(<span class="string">"properties"</span>, propertiesRef);</span><br><span class="line">    &#125;</span><br><span class="line">    String fileEncoding = element.getAttribute(<span class="string">"file-encoding"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(fileEncoding)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"fileEncoding"</span>, fileEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">    String order = element.getAttribute(<span class="string">"order"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(order)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"order"</span>, Integer.valueOf(order));</span><br><span class="line">    &#125;</span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreResourceNotFound"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-resource-not-found"</span>)));</span><br><span class="line">    builder.addPropertyValue(<span class="string">"localOverride"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"local-override"</span>)));</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="properties-ref"><a href="#properties-ref" class="headerlink" title="properties-ref"></a>properties-ref</h3><p>此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span>  <span class="attr">properties-ref</span>=<span class="string">"property"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"property"</span> <span class="attr">class</span>=<span class="string">"java.util.Properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"student.name"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样便可以看到结果。</p><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。</p><h3 id="ignore-resource-not-found"><a href="#ignore-resource-not-found" class="headerlink" title="ignore-resource-not-found"></a>ignore-resource-not-found</h3><p>如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。</p><h3 id="ignore-unresolvable"><a href="#ignore-unresolvable" class="headerlink" title="ignore-unresolvable"></a>ignore-unresolvable</h3><p>如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。</p><h3 id="local-override"><a href="#local-override" class="headerlink" title="local-override"></a>local-override</h3><p>这个属性让我很迷惑。Spring说是此选项决定”local”的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Properties[] localProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set local properties, e.g. via the "props" tag in XML bean definitions.</span></span><br><span class="line"><span class="comment"> * These can be considered defaults, to be overridden by properties</span></span><br><span class="line"><span class="comment"> * loaded from files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localProperties = <span class="keyword">new</span> Properties[] &#123;properties&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这应该就是Spring所说的”local”属性。好，我们来注入一下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span>  <span class="attr">location</span>=<span class="string">"property.properties"</span> <span class="attr">local-override</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"student.name"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向”local”注入?(context:property-override不允许子标签存在)</p><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图:</p><p><img src="http://tu.duia.online/62625252e36e91a60de225abd66db8da" alt="PropertyOverrideConfigurer类图"></p><h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><p>入口当然是BeanFactoryPostProcessor.postProcessBeanFactory(PropertyResourceConfigurer):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 属性加载</span></span><br><span class="line">        Properties mergedProps = mergeProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert the merged properties, if necessary.</span></span><br><span class="line">        convertProperties(mergedProps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let the subclass process the properties.</span></span><br><span class="line">        processProperties(beanFactory, mergedProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性加载"><a href="#属性加载" class="headerlink" title="属性加载"></a>属性加载</h3><p>PropertiesLoaderSupport.mergeProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Properties <span class="title">mergeProperties</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties result = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">        <span class="comment">// Load properties from file upfront, to let local properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Properties localProp : <span class="keyword">this</span>.localProperties) &#123;</span><br><span class="line">            CollectionUtils.mergePropertiesIntoMap(localProp, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">        <span class="comment">// Load properties from file afterwards, to let those properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。</p><h3 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h3><p>convertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。</p><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory factory, String beanName, String property, String value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinition bd = factory.getBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">while</span> (bd.getOriginatingBeanDefinition() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bd = bd.getOriginatingBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    PropertyValue pv = <span class="keyword">new</span> PropertyValue(property, value);</span><br><span class="line">    pv.setOptional(<span class="keyword">this</span>.ignoreInvalidKeys);</span><br><span class="line">    bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。</p><h1 id="property-placeholder"><a href="#property-placeholder" class="headerlink" title="property-placeholder"></a>property-placeholder</h1><p>这个怎么用已经喜闻乐见了</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。</p><p>PropertyPlaceholderBeanDefinitionParser.doParse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.doParse(element, builder);</span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreUnresolvablePlaceholders"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-unresolvable"</span>)));</span><br><span class="line">    String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp;</span><br><span class="line">            !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"systemPropertiesModeName"</span>, <span class="string">"SYSTEM_PROPERTIES_MODE_"</span></span><br><span class="line">            + systemPropertiesModeName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"value-separator"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"valueSeparator"</span>, element.getAttribute(<span class="string">"value-separator"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"trim-values"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"trimValues"</span>, element.getAttribute(<span class="string">"trim-values"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"null-value"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"nullValue"</span>, element.getAttribute(<span class="string">"null-value"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="system-properties-mode"><a href="#system-properties-mode" class="headerlink" title="system-properties-mode"></a>system-properties-mode</h3><p>Spring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。</p><h3 id="value-separator"><a href="#value-separator" class="headerlink" title="value-separator"></a>value-separator</h3><p>用于配置默认的值的分隔符:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"$&#123;student.name:skywalker&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果属性文件里没有student.name，那么就是skywalker。默认就是:。</p><h3 id="null-value"><a href="#null-value" class="headerlink" title="null-value"></a>null-value</h3><p>遇到哪些值应该当做空处理，比如可以把空串””设为这个，默认不对任何值进行处理。</p><h3 id="trim-values"><a href="#trim-values" class="headerlink" title="trim-values"></a>trim-values</h3><p>是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。</p><h3 id="BeanDefinition-1"><a href="#BeanDefinition-1" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>这次是PropertySourcesPlaceholderConfigurer，其类图:</p><p><img src="http://tu.duia.online/374e1898d10ab7dfb7cab85d7785c85e" alt="PropertySourcesPlaceholderConfigurer类图"></p><h2 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h2><p>PropertySourcesPlaceholderConfigurer.postProcessBeanFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.propertySources = <span class="keyword">new</span> MutablePropertySources();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addLast(</span><br><span class="line">                <span class="keyword">new</span> PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, </span><br><span class="line">                    <span class="keyword">this</span>.environment) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.source.getProperty(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        PropertySource&lt;?&gt; localPropertySource =</span><br><span class="line">                <span class="keyword">new</span> PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addFirst(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addLast(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processProperties(beanFactory, <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources));</span><br><span class="line">    <span class="keyword">this</span>.appliedPropertySources = <span class="keyword">this</span>.propertySources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样:</p><p>不使用property-placeholder标签，以显式的bean定义代替。</p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。</p><h1 id="load-time-weaver-amp-spring-configured"><a href="#load-time-weaver-amp-spring-configured" class="headerlink" title="load-time-weaver &amp; spring-configured"></a>load-time-weaver &amp; spring-configured</h1><p>这两个配置是紧密相关的，所以在一起说了。</p><p>load-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。</p><p>可以参考:</p><p><a href="http://sexycoding.iteye.com/blog/1062372" target="_blank" rel="noopener">Spring之LoadTimeWeaver——一个需求引发的思考</a></p><p><a href="http://www.iteye.com/topic/481813" target="_blank" rel="noopener">Spring LoadTimeWeaver 的那些事儿</a></p><h2 id="javaagent"><a href="#javaagent" class="headerlink" title="javaagent"></a>javaagent</h2><p>要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例:</p><p>-javaagent:D:\Software\maven-repos\org\springframework\spring-agent\2.5.6.SEC03\spring-agent-2.5.6.SEC03.jar</p><p>此jar包的META-INF/MANIFEST.MF文件需要配置如下一行:</p><p>Premain-Class: org.springframework.instrument.InstrumentationSavingAge<br> nt</p><p>Spring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationSavingAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instrumentation instrumentation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        instrumentation = inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instrumentation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。</p><h3 id="LoadTimeWeaver"><a href="#LoadTimeWeaver" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h3><p>此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系:</p><p><img src="http://tu.duia.online/0726e81aba163c9b3a8ef1edec699646" alt="LoadTimeWeaver继承体系"></p><p>LoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getBeanClassName</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果配置了weaver-class属性，那么使用其值</span></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.getAttribute(WEAVER_CLASS_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// org.springframework.context.weaving.DefaultContextLoadTimeWeaver</span></span><br><span class="line">    <span class="keyword">return</span> DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个BeanDefinition的id/name又是什么呢?</p><p>LoadTimeWeaverBeanDefinitionParser.resolveId:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolveId</span><span class="params">(Element element, AbstractBeanDefinition definition, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// loadTimeWeaver</span></span><br><span class="line">    <span class="keyword">return</span> ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。</p><h3 id="LoadTimeWeaverBeanDefinitionParser"><a href="#LoadTimeWeaverBeanDefinitionParser" class="headerlink" title="LoadTimeWeaverBeanDefinitionParser"></a>LoadTimeWeaverBeanDefinitionParser</h3><p>LoadTimeWeaverBeanDefinitionParser.doParse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="keyword">if</span> (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) &#123;</span><br><span class="line">            RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);</span><br><span class="line">            parserContext.registerBeanComponent(</span><br><span class="line">                    <span class="keyword">new</span> BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser().parse(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aspectj-weaving"><a href="#aspectj-weaving" class="headerlink" title="aspectj-weaving"></a>aspectj-weaving</h3><p>这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。</p><p>此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。</p><h3 id="是否开启"><a href="#是否开启" class="headerlink" title="是否开启"></a>是否开启</h3><p>isAspectJWeavingEnabled方法用于判断是否启用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAspectJWeavingEnabled</span><span class="params">(String value, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"on"</span>.equals(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"off"</span>.equals(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找aop.xml</span></span><br><span class="line">        ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AspectJWeavingEnabler"><a href="#AspectJWeavingEnabler" class="headerlink" title="AspectJWeavingEnabler"></a>AspectJWeavingEnabler</h3><p>从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图:</p><p><img src="http://tu.duia.online/ec7d1a908f913e4a515d7d0f8dcd6a6e" alt="AspectJWeavingEnabler类图"></p><h3 id="SpringConfiguredBeanDefinitionParser"><a href="#SpringConfiguredBeanDefinitionParser" class="headerlink" title="SpringConfiguredBeanDefinitionParser"></a>SpringConfiguredBeanDefinitionParser</h3><p>如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br></pre></td></tr></table></figure><p>其parse方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// org.springframework.context.config.internalBeanConfigurerAspect</span></span><br><span class="line">    <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">         <span class="comment">// org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect</span></span><br><span class="line">        def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);</span><br><span class="line">        def.setFactoryMethodName(<span class="string">"aspectOf"</span>);</span><br><span class="line">        def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        def.setSource(parserContext.extractSource(element));</span><br><span class="line">        parserContext.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition</span><br><span class="line">            (def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图:</p><p><img src="http://tu.duia.online/e5f1c7643e36acaf6542da73ab606c32" alt="AnnotationBeanConfigurerAspect类图"></p><p>AnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。</p><p>下面就去aj文件中看看到底定义了哪些pointcut以及advise。</p><p>语法可以参考:</p><p><a href="http://jinnianshilongnian.iteye.com/blog/1415606" target="_blank" rel="noopener">Spring 之AOP AspectJ切入点详解</a></p><h4 id="切点-pointcut"><a href="#切点-pointcut" class="headerlink" title="切点(pointcut)"></a>切点(pointcut)</h4><h5 id="inConfigurableBean"><a href="#inConfigurableBean" class="headerlink" title="inConfigurableBean"></a>inConfigurableBean</h5><p>在AnnotationBeanConfigurerAspect中定义，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">inConfigurableBean</span><span class="params">()</span> : @<span class="title">this</span><span class="params">(Configurable)</span></span>;</span><br></pre></td></tr></table></figure><p>@this没找到相关说明，结合@以及this的语义，猜测是匹配<strong>带有@Configurable注解(以及作为元注解)的类</strong>。</p><h5 id="beanConstruction"><a href="#beanConstruction" class="headerlink" title="beanConstruction"></a>beanConstruction</h5><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">beanConstruction</span><span class="params">(Object bean)</span> :</span></span><br><span class="line"><span class="function">            <span class="title">initialization</span><span class="params">(ConfigurableObject+.new(..)</span>) &amp;&amp; <span class="title">this</span><span class="params">(bean)</span></span>;</span><br></pre></td></tr></table></figure><p>initialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。</p><h5 id="preConstructionCondition"><a href="#preConstructionCondition" class="headerlink" title="preConstructionCondition"></a>preConstructionCondition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> &amp;&amp; <span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>由两个pointcut与运算而来。</p><h5 id="leastSpecificSuperTypeConstruction"><a href="#leastSpecificSuperTypeConstruction" class="headerlink" title="leastSpecificSuperTypeConstruction"></a>leastSpecificSuperTypeConstruction</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> : <span class="title">initialization</span><span class="params">(ConfigurableObject.new(..)</span>)</span>;</span><br></pre></td></tr></table></figure><h5 id="preConstructionConfiguration"><a href="#preConstructionConfiguration" class="headerlink" title="preConstructionConfiguration"></a>preConstructionConfiguration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">preConstructionConfiguration</span><span class="params">()</span> : <span class="title">preConstructionConfigurationSupport</span><span class="params">(*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionConfigurationSupport</span><span class="params">(Configurable c)</span> : @<span class="title">this</span><span class="params">(c)</span> &amp;&amp; <span class="title">if</span> <span class="params">(c.preConstruction()</span>)</span>;</span><br></pre></td></tr></table></figure><p>preConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。</p><h5 id="postConstructionCondition"><a href="#postConstructionCondition" class="headerlink" title="postConstructionCondition"></a>postConstructionCondition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">postConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> &amp;&amp; !<span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>mostSpecificSubTypeConstruction:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(thisJoinPoint.getSignature()</span>.<span class="title">getDeclaringType</span><span class="params">()</span> </span>== thisJoinPoint.getThis().getClass());</span><br></pre></td></tr></table></figure><p>advise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。</p><h4 id="advise"><a href="#advise" class="headerlink" title="advise"></a>advise</h4><h5 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before(Object bean) :</span><br><span class="line">    beanConstruction(bean) &amp;&amp; preConstructionCondition() &amp;&amp; inConfigurableBean()  &#123;</span><br><span class="line">    configureBean(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行-3"><a href="#运行-3" class="headerlink" title="运行"></a>运行</h2><p>AspectJWeavingEnabler.postProcessBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    enableAspectJWeaving(<span class="keyword">this</span>.loadTimeWeaver, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enableAspectJWeaving:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enableAspectJWeaving</span><span class="params">(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (weaverToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">            weaverToUse = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(beanClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No LoadTimeWeaver available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    weaverToUse.addTransformer(</span><br><span class="line">            <span class="keyword">new</span> AspectJClassBypassingClassFileTransformer(<span class="keyword">new</span> ClassPreProcessorAgentAdapter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h3><p>AspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢?</p><p>当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadTimeWeaver</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，关键在于LoadTimeWeaverAwareProcessor，类图:</p><p><img src="http://tu.duia.online/cdcad948d03952c35e63e11b6e17bc25" alt="LoadTimeWeaverAwareProcessor类图"></p><p>postProcessBeforeInitialization方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> LoadTimeWeaverAware) &#123;</span><br><span class="line">        LoadTimeWeaver ltw = <span class="keyword">this</span>.loadTimeWeaver;</span><br><span class="line">        <span class="keyword">if</span> (ltw == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>,</span><br><span class="line">                <span class="string">"BeanFactory required if no LoadTimeWeaver explicitly specified"</span>);</span><br><span class="line">             <span class="comment">// 去容器找 </span></span><br><span class="line">            ltw = <span class="keyword">this</span>.beanFactory.getBean(</span><br><span class="line">                ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);</span><br><span class="line">        &#125;</span><br><span class="line">        ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。</p><p>BeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点:</p><p>BeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的:</p><p>AbstractApplicationContext.refresh:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure><p>那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的?</p><p>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBeanPostProcessors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BeanPostProcessor&gt; <span class="title">getBeanPostProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanPostProcessors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br></pre></td></tr></table></figure><p>直接将实例添加到BeanFactory中，所以可以得出结论:</p><p><strong>我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加</strong>。</p><h3 id="BeanClassLoaderAware"><a href="#BeanClassLoaderAware" class="headerlink" title="BeanClassLoaderAware"></a>BeanClassLoaderAware</h3><h4 id="入口-3"><a href="#入口-3" class="headerlink" title="入口"></a>入口</h4><p>DefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢?</p><p>AbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setBeanClassLoader"><a href="#setBeanClassLoader" class="headerlink" title="setBeanClassLoader"></a>setBeanClassLoader</h4><p>这个方法很关键，对instrument的获取就是在这里。源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (serverSpecificLoadTimeWeaver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = serverSpecificLoadTimeWeaver;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> ReflectiveLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显分为三部分。</p><h5 id="服务器agent"><a href="#服务器agent" class="headerlink" title="服务器agent"></a>服务器agent</h5><p>Spring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>createServerSpecificLoadTimeWeaver源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> LoadTimeWeaver <span class="title">createServerSpecificLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String name = classLoader.getClass().getName();</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"weblogic"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebLogicLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.glassfish"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GlassFishLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.apache.catalina"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TomcatLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.jboss"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JBossLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"com.ibm"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebSphereLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<strong>对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现</strong>。</p><p>这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。</p><h5 id="Spring-agent"><a href="#Spring-agent" class="headerlink" title="Spring agent"></a>Spring agent</h5><p>这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInstrumentationAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getInstrumentation() != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AGENT_CLASS_PRESENT) &#123;</span><br><span class="line">        <span class="keyword">return</span> InstrumentationAccessor.getInstrumentation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。</p><p>InstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationAccessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstrumentationSavingAgent.getInstrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。</p><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW…)，检测的源码位于ReflectiveLoadTimeWeaver的构造器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(classLoader, <span class="string">"ClassLoader must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    <span class="keyword">this</span>.addTransformerMethod = ClassUtils.getMethodIfAvailable(</span><br><span class="line">            <span class="keyword">this</span>.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addTransformerMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档:</p><p><a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html#enabling-load-time-weaving" target="_blank" rel="noopener">Chapter 5. Load-Time Weaving</a></p><h3 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h3><p>从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。</p><p>AspectJClassBypassingClassFileTransformer.transform:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">    <span class="comment">// aspectj自身的类无需检测(织入)，直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (className.startsWith(<span class="string">"org.aspectj"</span>) || className.startsWith(<span class="string">"org/aspectj"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.transform(loader, className, classBeingRedefined, </span><br><span class="line">        protectionDomain, classfileBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图:</p><p><img src="http://tu.duia.online/8d15860c9c2c11667b615ebe5e94ba36" alt="ClassPreProcessorAgentAdapter类图"></p><p>根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4.</p><h3 id="Aj"><a href="#Aj" class="headerlink" title="Aj"></a>Aj</h3><p>Aj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Aj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。</p><h4 id="WeavingAdaptor初始化"><a href="#WeavingAdaptor初始化" class="headerlink" title="WeavingAdaptor初始化"></a>WeavingAdaptor初始化</h4><p>初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。</p><h5 id="aop-xml"><a href="#aop-xml" class="headerlink" title="aop.xml"></a>aop.xml</h5><h6 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h6><p>aop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的:</p><p>以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.AnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.AnnotationCacheAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.JCacheCacheAspect"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么解析后的结果:</p><p><img src="http://tu.duia.online/dfecbf68cdc94e14e8b13201b85bfde0" alt="aop.xml解析结果"></p><h6 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h6><p>入口方法在ClassLoaderWeavingAdaptor.registerDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">registerDefinitions</span><span class="params">(<span class="keyword">final</span> BcelWeaver weaver, <span class="keyword">final</span> ClassLoader loader, List&lt;Definition&gt; definitions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对应&lt;weaver options="-verbose"&gt;</span></span><br><span class="line">    registerOptions(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;exclude&gt;标签</span></span><br><span class="line">    registerAspectExclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;include&gt;标签</span></span><br><span class="line">    registerAspectInclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">// &lt;aspect&gt;</span></span><br><span class="line">    success = registerAspects(weaver, loader, definitions);</span><br><span class="line">    registerIncludeExclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;dump&gt;标签</span></span><br><span class="line">    registerDump(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//忽略返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Spring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;入口方法在BeanDefinitionParserDelegate.parseCustomElement：&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
      <category term="spring" scheme="https://duia.github.io/categories/spring/"/>
    
      <category term="源码阅读" scheme="https://duia.github.io/categories/spring/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="源码阅读" scheme="https://duia.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="spring" scheme="https://duia.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之建造者模式</title>
    <link href="https://duia.github.io/2016/11/26/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://duia.github.io/2016/11/26/Java设计模式之建造者模式/</id>
    <published>2016-11-26T03:44:00.000Z</published>
    <updated>2019-05-11T15:00:00.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/2019/1/75OZ01__3_S0QJLWTH9N4QR20190216150423993.png" alt="image"></p><a id="more"></a><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>将复杂对象的构造与其表示分开，以便相同的构造过程可以创建不同的表示。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>真实世界的例子</p><blockquote><p>设想一个角色扮演类游戏的角色生成器。电脑为你创造角色时，你可以逐步选择你想选择的角色的职业、性别、发色等细节，角色的生成就成了一个循序渐进的过程，当所有的选择都准备好的时候就完成了。</p></blockquote><p>用简单的话来说</p><blockquote><p>允许您创建不同的对象风格，同时避免构造器的污染；当可能有几种风格的对象时很有用；或者当创建对象时涉及很多步骤。</p></blockquote><p>大概就是这个意思，具体还需要看代码帮助理解意思：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Hero(Profession profession, String name, HairType hairType, HairColor hairColor, Armor armor, Weapon weapon) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所看到的，构造函数参数的数量可能会很快失去控制，并且可能很难理解参数的排列方式。还有如果你想在将来添加更多的选项，参数可以继续增长。这被称为可伸缩构造器的反模式。</p><p><strong>编程示例</strong></p><p>理智的选择是使用Builder模式。首先我们有我们想要创造的<code>Hero.java</code>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class Hero &#123;</span><br><span class="line">  private final Profession profession;</span><br><span class="line">  private final String name;</span><br><span class="line">  private final HairType hairType;</span><br><span class="line">  private final HairColor hairColor;</span><br><span class="line">  private final Armor armor;</span><br><span class="line">  private final Weapon weapon;</span><br><span class="line"></span><br><span class="line">  private Hero(Builder builder) &#123;</span><br><span class="line">    this.profession = builder.profession;</span><br><span class="line">    this.name = builder.name;</span><br><span class="line">    this.hairColor = builder.hairColor;</span><br><span class="line">    this.hairType = builder.hairType;</span><br><span class="line">    this.weapon = builder.weapon;</span><br><span class="line">    this.armor = builder.armor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static class Builder &#123;</span><br><span class="line">    private final Profession profession;</span><br><span class="line">    private final String name;</span><br><span class="line">    private HairType hairType;</span><br><span class="line">    private HairColor hairColor;</span><br><span class="line">    private Armor armor;</span><br><span class="line">    private Weapon weapon;</span><br><span class="line"></span><br><span class="line">    public Builder(Profession profession, String name) &#123;</span><br><span class="line">      this.profession = profession;</span><br><span class="line">      this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder withHairType(HairType hairType) &#123;</span><br><span class="line">      this.hairType = hairType;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder withHairColor(HairColor hairColor) &#123;</span><br><span class="line">      this.hairColor = hairColor;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder withArmor(Armor armor) &#123;</span><br><span class="line">      this.armor = armor;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder withWeapon(Weapon weapon) &#123;</span><br><span class="line">      this.weapon = weapon;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Hero build() &#123;</span><br><span class="line">      return new Hero(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hero mage = new Hero.Builder(Profession.MAGE, &quot;Riobard&quot;)</span><br><span class="line">    .withHairColor(HairColor.BLACK)</span><br><span class="line">    .withWeapon(Weapon.DAGGER)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>这样理解建造者模式比较容易理解，下边列出一般样例代码。</p><h2 id="标准代码实现"><a href="#标准代码实现" class="headerlink" title="标准代码实现"></a>标准代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 所要建造的产品类</span><br><span class="line"> */</span><br><span class="line">class Product &#123;</span><br><span class="line"></span><br><span class="line">    private String paths;</span><br><span class="line">    </span><br><span class="line">    public String getPaths() &#123;</span><br><span class="line">    return paths;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPaths(String paths) &#123;</span><br><span class="line">    this.paths = paths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 抽象建造者，</span><br><span class="line"> * 1、规定了建造的产品（如果有多个产品，可以适当添加抽象产品）</span><br><span class="line"> * 2、规定了建造每个产品所分步骤，不需要具体的实现过程，实现过程由具体的建造者进行实现</span><br><span class="line"> * 3、规定了建造每个产品时的步骤顺序（此步可以在导演类中进行），并建造完后返回对象</span><br><span class="line"> * 每要新建一个类似的产品种类时，均可继承该类，并实现具体的每个步骤即可，无需改动原有的类，实现了代码的可扩展性</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">abstract class Builder &#123;</span><br><span class="line"></span><br><span class="line">    protected abstract void buildPaths();</span><br><span class="line">    </span><br><span class="line">    public abstract Product build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 具体的建造者实现，针对同种产品可以有不通的建造的实现，也可以针对不同的产品分别实现不同的建造者。</span><br><span class="line"> */</span><br><span class="line">class ConcreteBuilder extends Builder &#123;</span><br><span class="line"></span><br><span class="line">    private Product product = new Product();</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void buildPaths() &#123;</span><br><span class="line">        product.setPaths(&quot;设置产品属性&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Product build() &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 导演类，预先持有产品的建造者，为需要不同于默认产品的用户提供不同的组装方式</span><br><span class="line"> * 对建造者的管理,并管理建造步骤</span><br><span class="line"> */</span><br><span class="line">class Director &#123;</span><br><span class="line"></span><br><span class="line">    private Builder builder;</span><br><span class="line">    </span><br><span class="line">    public Director(Builder builder)&#123;</span><br><span class="line">        this.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Product construct()&#123;</span><br><span class="line">        builder.buildPaths();</span><br><span class="line">        return builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">        Builder builder = new ConcreteBuilder();</span><br><span class="line">    </span><br><span class="line">        Director director = new Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上两种建造者模式的实现只是不同的写法，还可以有别的实现方式，我们可以在实际开发中根据具体业务进行选择，添加抽象产品类或者省略抽象建造者等等。</p><h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>使用Builder模式时</p><ul><li>创建复杂对象的算法应该独立于组成对象的部分以及它们如何组装</li><li>施工过程必须允许对构建的对象进行不同的表示</li></ul><h2 id="真实世界的例子"><a href="#真实世界的例子" class="headerlink" title="真实世界的例子"></a>真实世界的例子</h2><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener">java.lang.StringBuilder</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener">java.nio.ByteBuffer</a> as well as similar buffers such as FloatBuffer, IntBuffer and so on.</li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="noopener">java.lang.StringBuffer</a></li><li>All implementations of <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html" target="_blank" rel="noopener">java.lang.Appendable</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/2019/1/75OZ01__3_S0QJLWTH9N4QR20190216150423993.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/categories/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring源码阅读-aop</title>
    <link href="https://duia.github.io/2016/11/22/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-aop/"/>
    <id>https://duia.github.io/2016/11/22/spring源码阅读-aop/</id>
    <published>2016-11-22T13:30:00.000Z</published>
    <updated>2019-05-18T02:00:00.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>aop部分的解析器由AopNamespaceHandler注册，其init方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="aop-config"><a href="#aop-config" class="headerlink" title="aop:config"></a>aop:config</h1><p>此标签用以配置pointcut, advisor, aspect，实例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* exam.service..*.*(..))"</span> <span class="attr">id</span>=<span class="string">"transaction"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"transaction"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ConfigBeanDefinitionParser.parse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    CompositeComponentDefinition compositeDef =</span><br><span class="line">            <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), </span><br><span class="line">            parserContext.extractSource(element));</span><br><span class="line">    parserContext.pushContainingComponent(compositeDef);</span><br><span class="line">    <span class="comment">// 是否生成代理类</span></span><br><span class="line">    configureAutoProxyCreator(parserContext, element);</span><br><span class="line">    List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">    <span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">        String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">        <span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">            parsePointcut(elt, parserContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">            parseAdvisor(elt, parserContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">            parseAspect(elt, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parserContext.popAndRegisterContainingComponent();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析的过程主要分为以下几个部分。</p><h3 id="proxy-target-class-amp-expose-proxy"><a href="#proxy-target-class-amp-expose-proxy" class="headerlink" title="proxy-target-class &amp; expose-proxy"></a>proxy-target-class &amp; expose-proxy</h3><p>对应着aop:config的两个属性，前者代表是否为被代理这生成CGLIB子类，默认false，只为接口生成代理子类(话说如果不生成子类那么怎么拦截?)。后者代表是否将代理bean暴露给用户，如果暴露，可以通过Spring AopContext类获得，默认不暴露。</p><p>解析的过程无非就是属性的读取，不再详细说明。</p><h3 id="aop-pointcut"><a href="#aop-pointcut" class="headerlink" title="aop:pointcut"></a>aop:pointcut</h3><p>pointcut的解析是一个生成一个BeanDefinition并将其id, expression等属性保存在BeanDefinition中。注意以下几点:</p><ul><li>BeanDefinition的ID来自于id属性，如果没有，那么自动生成。</li><li>BeanDefinition的class是AspectJExpressionPointcut。</li><li>BeanDefinition的scope为prototype。</li></ul><p>AspectJExpressionPointcut类图:</p><p><img src="http://tu.duia.online/aa9dd45ed8036c51c0e9891177a65842" alt="AspectJExpressionPointcut类图"></p><h3 id="aop-advisor"><a href="#aop-advisor" class="headerlink" title="aop:advisor"></a>aop:advisor</h3><p>首先是其所有属性的示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">order</span>=<span class="string">""</span> <span class="attr">advice-ref</span>=<span class="string">"aopAdvice"</span> <span class="attr">pointcut</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>advisor概念是Spring独有的，来自于上古时代，应该是较早时候的aop概念的实现: <a href="http://aopalliance.sourceforge.net/" target="_blank" rel="noopener">AOP Alliance (Java/J2EE AOP standards)</a>。Spring官方的说法: <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-schema-advisors" target="_blank" rel="noopener">aop-schema-advisors</a>。</p><p>其相关的包/类就在spring-aop下:</p><p><img src="http://tu.duia.online/f2702935eca77c3121e6cefeff18428c" alt="aopalliance包"></p><p>advice-ref是必须的属性，<strong>并且这里的advice必须实现org.aopalliance.aop.Advice的子接口</strong>。这些子接口指的什么呢，见Spring官方文档: <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html#aop-api-advice-types" target="_blank" rel="noopener">aop-api-advice-types</a>。比如org.aopalliance.intercept.MethodInterceptor。</p><p>最常见的用途就是结合事务使用:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">propagation</span>=<span class="string">"NOT_SUPPORTED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">propagation</span>=<span class="string">"NOT_SUPPORTED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* exam.service..*.*(..))"</span> <span class="attr">id</span>=<span class="string">"transaction"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"transaction"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析的套路和楼上类似，只不过此处的beanClass是DefaultBeanFactoryPointcutAdvisor，其类图:</p><p><img src="http://tu.duia.online/d46beb78192fd2d1e8207c626e8548cd" alt="DefaultBeanFactoryPointcutAdvisor类图"></p><p>另外注意对于pointcut和pointcut-ref两者处理的区别，对于pointcut属性，Spring会同样创建一个AspectJExpressionPointcut类型的BeanDefinition，对于pointcut-ref会生成一个RuntimeBeanReference对象指向原pointcut的引用。此类的类图:</p><p><img src="http://tu.duia.online/ce3f404b8139851a6fde580de0b7d366" alt="RuntimeBeanReference类图"></p><p>可以看出，这种aop的实现需要实现各种接口，所以不应该再使用此种方式进行aop，除了Spring内部的实现。</p><h3 id="aop-aspect"><a href="#aop-aspect" class="headerlink" title="aop:aspect"></a>aop:aspect</h3><p>配置举例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aopAdvice"</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemoAdvice"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 必须配置，因为被代理的对象必须在Spring容器中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aopDemo"</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemo"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* base.aop.AopDemo.send())"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aopAdvice"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforeSend"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterSend"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析形成的BeanDefinition结构如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">AspectComponentDefinition</span><br><span class="line">    beanRefArray</span><br><span class="line">        RuntimeBeanReference(aop:aspect的ref属性)</span><br><span class="line">    beanDefArray</span><br><span class="line">        // 被注册</span><br><span class="line">        RootBeanDefinition(aop:declare-parents)</span><br><span class="line">            beanClass: DeclareParentsAdvisor</span><br><span class="line">            ConstructorArg</span><br><span class="line">                implement-interface</span><br><span class="line">                types-matching</span><br><span class="line">                default-impl</span><br><span class="line">                delegate-ref</span><br><span class="line">        // 被注册</span><br><span class="line">        RootBeanDefinition(aop:before,aop:after...)</span><br><span class="line">            beanClass: AspectJPointcutAdvisor</span><br><span class="line">            ConstructorArg</span><br><span class="line">                RootBeanDefinition</span><br><span class="line">                    beanClass: 由子标签决定</span><br><span class="line">                    ConstructorArg</span><br><span class="line">                        RootBeanDefinition</span><br><span class="line">                            beanClass: MethodLocatingFactoryBean</span><br><span class="line">                            properties</span><br><span class="line">                                targetBeanName: aspectName</span><br><span class="line">                                methodName: method属性</span><br><span class="line">                        RootBeanDefinition</span><br><span class="line">                            beanClass: SimpleBeanFactoryAwareAspectInstanceFactory</span><br><span class="line">                            properties</span><br><span class="line">                                aspectBeanName: aspectName</span><br><span class="line">                        //还有pointcut定义和引用...</span><br></pre></td></tr></table></figure><p>结构图里面的aspectName来自于aop:aspect的ref属性，此属性是必须配置的，因为Spring要知道aop:before等标签指定的方法是哪个bean/类/对象的方法。</p><h4 id="aop-declare-parents"><a href="#aop-declare-parents" class="headerlink" title="aop:declare-parents"></a>aop:declare-parents</h4><p>对于aop:declare-parents子标签，其决定的是代理子类应该实现哪些接口:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span> <span class="attr">types-matching</span>=<span class="string">""</span> <span class="attr">implement-interface</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>此标签最终被解析成为beanClass为DeclareParentsAdvisor的BeanDefinition，并注册到容器中。其类图:</p><p><img src="http://tu.duia.online/24fea4a4df9ed9d0ee37d040f74c9ba3" alt="DeclareParentsAdvisor类图"></p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>此处的其它指的是aop:before, aop:after等最核心的标签。其最终被解析为beanClass为AspectJPointcutAdvisor的BeanDefinition，类图:</p><p><img src="http://tu.duia.online/2c472bc55be18a052fa62a0817ad25b1" alt="AspectJPointcutAdvisor类图"></p><p>正如上面结构图里所描述的，其构造参数为一个BeanDefintion，此对象的beanClass是不确定的，由aop:before/after中的before和after决定，代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) &#123;</span><br><span class="line">    String elementName = parserContext.getDelegate().getLocalName(adviceElement);</span><br><span class="line">    <span class="keyword">if</span> (BEFORE.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJMethodBeforeAdvice.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AFTER.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJAfterAdvice.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AFTER_RETURNING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJAfterReturningAdvice.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AFTER_THROWING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJAfterThrowingAdvice.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AROUND.equals(elementName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AspectJAroundAdvice.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而此BeanDefintion的构造参数又由以下三个部分组成:</p><h5 id="MethodLocatingFactoryBean"><a href="#MethodLocatingFactoryBean" class="headerlink" title="MethodLocatingFactoryBean"></a>MethodLocatingFactoryBean</h5><p>第一个便是beanClass为此类型的BeanDefinition。其内部有一个methodName属性，存储的便是标签的method属性的值。其类图:</p><p><img src="http://tu.duia.online/bcc109a939fda148b45ecade325b6751" alt="MethodLocatingFactoryBean类图"></p><p>这个东西是干什么用的呢?其实是用于在指定的advice(aop:aspect的ref属性)中得到Method对象。入口在setBeanFactory方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; beanClass = beanFactory.getType(<span class="keyword">this</span>.targetBeanName);</span><br><span class="line">    <span class="keyword">this</span>.method = BeanUtils.resolveSignature(<span class="keyword">this</span>.methodName, beanClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SimpleBeanFactoryAwareAspectInstanceFactory"><a href="#SimpleBeanFactoryAwareAspectInstanceFactory" class="headerlink" title="SimpleBeanFactoryAwareAspectInstanceFactory"></a>SimpleBeanFactoryAwareAspectInstanceFactory</h5><p>其类图:</p><p><img src="http://tu.duia.online/bc9ba6b0874d32a5340718375708075d" alt="SimpleBeanFactoryAwareAspectInstanceFactory类图"></p><p>此类用于在BeanFactory中定位aspect bean，这个bean指的是谁?</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aopAdvice"</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemoAdvice"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>就是它!查找很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAspectInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getBean(<span class="keyword">this</span>.aspectBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从整个aop:aspect标签最终被解析为一个AspectJPointcutAdvisor来看，Spring在实现上仍将其作为Advisor的概念。</p><h2 id="代理子类生成"><a href="#代理子类生成" class="headerlink" title="代理子类生成"></a>代理子类生成</h2><p>关键在于AspectJAwareAdvisorAutoProxyCreator，此对象在ConfigBeanDefinitionParser的configureAutoProxyCreator方法中注册，其类图:</p><p><img src="http://tu.duia.online/cc83663a2f2a69115dfc807e0f41f441" alt="AspectJAwareAdvisorAutoProxyCreator类图"></p><p>那么子类生成的入口在哪里呢?</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>从AspectJAwareAdvisorAutoProxyCreator的类图中可以看出，此类实现了SmartInstantiationAwareBeanPostProcessor接口，所以很容易想到入口应该位于此接口及其父接口(BeanPostProcessor)的相关方法中。实际上确实是这样的。</p><h3 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h3><h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><p>先来回顾一下此方法在Bean创建的过程中的调用时机。</p><p>AbstractAutowireCapableBeanFactory.createBean部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br></pre></td></tr></table></figure><p>可以看出，调用发生在Bean实例的创建之前。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>AbstractAutoProxyCreator.postProcessBeforeInstantiation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanName == <span class="keyword">null</span> || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">            Object[] specificInterceptors = </span><br><span class="line">                getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">            <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分部分对其进行说明。</p><h4 id="应该代理"><a href="#应该代理" class="headerlink" title="应该代理 ?"></a>应该代理 ?</h4><p>Spring首先会对当前的beanClass进行检查(是否应该/可以对其进行代理)。</p><p>不应该代理的类分为两种情况: </p><ul><li>用于实现AOP的Spring基础类，此种情况在isInfrastructureClass方法中完成检测(单词Infrastructure正是基础设施的意思)。</li><li>子类定义的应该跳过的类，默认AbstractAutoProxyCreator的实现直接返回false，即都不应该跳过。</li></ul><h5 id="基础类检测"><a href="#基础类检测" class="headerlink" title="基础类检测"></a>基础类检测</h5><p>AbstractAutoProxyCreator.isInfrastructureClass:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，任何Advice、Pointcut、Advisor、AopInfrastructureBean的子类都被当做Spring实现AOP的基础设施类。</p><h5 id="跳过类检测"><a href="#跳过类检测" class="headerlink" title="跳过类检测"></a>跳过类检测</h5><p>即shouldSkip方法。前面提到了，AbstractAutoProxyCreator的默认实现直接返回fasle，这一特性被子类AspectJAwareAdvisorAutoProxyCreator重写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此方法跳过的是谁呢？</p><p>其实就是我们通过aop:aspect标签配置的切面，即:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aopAdvice"</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemoAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aopAdvice"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>里的aopAdvice。</p><p>从前面的aop:aspect一节中可以知道，Spring对于aop:config的解析其实是把aop:before/after等标签解析成为了AspectJPointcutAdvisor类型的BeanDefinition，而aopAdvice以AbstractAspectJAdvice的类型保存在其中。</p><p>所以可以得出结论: <strong>Spring跳过的是适用于当前bean的Advisor的Advice/Aspect对象</strong>。</p><h6 id="AOP逻辑"><a href="#AOP逻辑" class="headerlink" title="AOP逻辑"></a>AOP逻辑</h6><p><img src="http://tu.duia.online/50038bbaa00dc43322c9e947c86adfae" alt="AOP逻辑图"></p><p>那么Spring又是如何找到适用于当前bean的Advisor的呢?</p><h6 id="Advisor寻找"><a href="#Advisor寻找" class="headerlink" title="Advisor寻找"></a>Advisor寻找</h6><p>关键便是findCandidateAdvisors方法，此方法将逻辑委托给BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] advisorNames = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="comment">// 结果缓存</span></span><br><span class="line">        advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">        <span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 去容器中寻找</span></span><br><span class="line">            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                    <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">                advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，首先是从容器中获取到所有的Advisor示例，然后调用isEligibleBean方法逐一判断Advisor是否适用于当前bean。</p><h6 id="适用性检测"><a href="#适用性检测" class="headerlink" title="适用性检测"></a>适用性检测</h6><p>指的便是isEligibleBean方法。最终调用的是AbstractAdvisorAutoProxyCreator的同名方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEligibleAdvisorBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而AbstractAdvisorAutoProxyCreator的子类AspectJAwareAdvisorAutoProxyCreator并没有覆盖此方法，所以此处会对<strong>容器中所有的Advisor的Advice进行跳过</strong>。</p><h5 id="检测结果缓存"><a href="#检测结果缓存" class="headerlink" title="检测结果缓存"></a>检测结果缓存</h5><p>因为postProcessBeforeInstantiation方法会在每个bean初始化之前被调用，所以没有必要每次都真的进行基础类检测和跳过类检测，Spring使用了advisedBeans作为缓存用以提高性能。</p><h4 id="TargetSource"><a href="#TargetSource" class="headerlink" title="TargetSource"></a>TargetSource</h4><p>从源码中可以看出，对于自定义的TargetSource，Spring会立即执行代理子类的创建。Spring的代理其实是针对TargetSource的，其类图:</p><p><img src="http://tu.duia.online/aa71319a8e2580e09599e197780ff8b9" alt="TargetSource类图"></p><p>关于此接口在此不展开叙述。</p><h3 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h3><p>AbstractAutoProxyCreator.postProcessAfterInitialization:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键便在于wrapIfNecessary方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自定义TargetSource，已经进行过代理子类生成</span></span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，在此方法的开头又进行了基础类以及跳过类的检测，再次不再赘述。</p><h4 id="Advisor寻找-1"><a href="#Advisor寻找-1" class="headerlink" title="Advisor寻找"></a>Advisor寻找</h4><p>即getAdvicesAndAdvisorsForBean方法，这里进行的便是去容器中寻找适用于当前bean的Advisor，最终调用的是</p><p>AbstractAdvisorAutoProxyCreator.findEligibleAdvisors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findCandidateAdvisors前面已经说过了。</p><h5 id="适用性判断"><a href="#适用性判断" class="headerlink" title="适用性判断"></a>适用性判断</h5><p>findAdvisorsThatCanApply最终调用AopUtils.findAdvisorsThatCanApply:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">            <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于canApply方法，从源码中可以看出，对于Advisor的判断分为了IntroductionAdvisor以及非IntroductionAdvisor两种情况。</p><p>这种分开处理导致了<strong>IntroductionAdvisor在Advisor链中总是位于非IntroductionAdvisor前面</strong>。</p><p>canApply(candidate, clazz)其实等价于canApply(candidate, clazz, false):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">        PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line">        <span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It doesn't have a pointcut so we assume it applies.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，对于引入Advisor与其它Advisor是两种不同的判断方式。</p><h6 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h6><p>引入的概念在下面aop:scoped-proxy中有提到。因为引入的目的在于动态地向一个类添加另一种功能(接口)，所以只要判断给定的类是否是要引入到的类即可。</p><h6 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h6><p>AopUtils.canApply:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否Pointcut可以匹配当前类</span></span><br><span class="line">    <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">    <span class="comment">//是否Pointcut可以匹配所有方法</span></span><br><span class="line">    <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">        <span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;</span><br><span class="line">        (ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">    classes.add(targetClass);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    introductionAwareMethodMatcher</span><br><span class="line">                        .matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">                    methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的Pointcut由ClassFilter和MethodMatcher两部分组成，其中前者用以判断给定的类是否在Pointcut的匹配范围内，后者用以在ClassFilter匹配满足的情况下判断给定的方法是否在Pointcut匹配的范围内。</p><p>从源码中可以看出，如果ClassFilter匹配得到满足并且Pointcut并不能匹配此类的任意方法，便会<strong>用反射的方法获取targetClass(被检测类)的全部方法逐一交由Pointcut的MethodMatcher进行检测</strong>。</p><p>关于Pointcut表达式是如何解析及存储的在此不再展开。</p><h5 id="Advisor扩展"><a href="#Advisor扩展" class="headerlink" title="Advisor扩展"></a>Advisor扩展</h5><p>AbstractAdvisorAutoProxyCreator.extendAdvisors允许子类向Advisor链表中添加自己的Advisor。子类AspectJAwareAdvisorAutoProxyCreator重写了此方法，其逻辑是:</p><p>如果Advisor链表中的Advisor含有AspectJ Advice，那么将会把一个ExposeInvocationInterceptor添加到链表的表头，目的在于将MethodInvocation以ThreadLocal的方式暴露给后面所有的Advisor，暂不知道具体的用途。</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>即sortAdvisors方法，用于对实现了Ordered接口的Advisor进行排序。</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>AbstractAutoProxyCreator.createProxy(略去非关键代码):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将interceptor适配为Advisor</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">        proxyFactory.addAdvisor(advisor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JDK动态代理-or-Cglib"><a href="#JDK动态代理-or-Cglib" class="headerlink" title="JDK动态代理 or Cglib"></a>JDK动态代理 or Cglib</h5><p>由DefaultAopProxyFactory.createAopProxy方法决定使用何种方式创建代理子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() ||</span><br><span class="line">            hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很明显，如果指定了(proxy-target-classs设为true)使用Cglib，那么就会使用Cglib的方式，如果没有指定(或为false)，那么先回检测被代理类是否实现了自己的接口，如果实现了，那么就采用JDK动态代理的方式。</p><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>JdkDynamicAopProxy.getProxy:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到可以用来进行代理的接口</span></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//用来代理的接口中是否定义了equals或者是hashCode方法?</span></span><br><span class="line">    <span class="comment">//结果保存在内部equalsDefined和hashCodeDefined两个成员变量中</span></span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，关键的InvocationHandler参数其实就是JdkDynamicAopProxy自身。</p><p>其invoke方法较长，源码就不贴了，下面进行分部分说明。</p><h6 id="equals-amp-hashCode"><a href="#equals-amp-hashCode" class="headerlink" title="equals &amp; hashCode"></a>equals &amp; hashCode</h6><p>如果被代理类实现了equals或者是hashCode方法，那么生成的代理子类的equals、hashCode方法实际上执行的是JdkDynamicAopProxy相应方法的逻辑。</p><p>invoke方法部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">    <span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">    <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h6><p>对于切点方法，比如前面aop:aspect示例配置中的beforeSend</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforeSend"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Spring会创建一个MethodInvocation对象对所有相关的Advisor进行链式调用。invoke相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">Object retVal = invocation.proceed();</span><br></pre></td></tr></table></figure><h5 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h5><p>同样是对于Advisor的链式调用，不再详细展开。</p><h1 id="aop-scoped-proxy"><a href="#aop-scoped-proxy" class="headerlink" title="aop:scoped-proxy"></a>aop:scoped-proxy</h1><p>此配置一般是这样使用:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于ref属性，<strong>只会在userManager初始化时注入一次</strong>。这会造成什么问题呢?以session的Scope为例，因为只会注入一次，所以，<strong>userManager引用的始终是同一个userPreferences对象，即使现在可能已经过时了</strong>。此配置便可以使userManager引用的其实是一个对代理的引用，所以可以始终获取到最新的userPreferences。</p><p>其作用和注解@ScopedProxy相同。</p><p>其解析由ScopedProxyBeanDefinitionDecorator完成，类图:</p><p><img src="http://tu.duia.online/56e52ee952be40f52d2246ca88b2fa5d" alt="ScopedProxyBeanDefinitionDecorator类图"></p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h3><p>从类图可以看出，ScopedProxyBeanDefinitionDecorator和之前的解析器都不同，它的调用入口不同以往:</p><p>DefaultBeanDefinitionDocumentReader.processBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 装饰</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinitionParserDelegate.decorateIfRequired:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateIfRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">    String namespaceUri = getNamespaceURI(node);</span><br><span class="line">    <span class="keyword">if</span> (!isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">        NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver()</span><br><span class="line">            .resolve(namespaceUri);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler.</span><br><span class="line">                decorate(node, originalDef, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originalDef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一目了然。</p><p>这么做(装饰)的原因就是此标签是用在bean内部的，从decorate的方法签名可以看出，第二个便是父(bean)BeanDefinition，所以叫做装饰。</p><h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorate</span><span class="params">(Node node, BeanDefinitionHolder definition, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> proxyTargetClass = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element ele = (Element) node;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(PROXY_TARGET_CLASS)) &#123;</span><br><span class="line">            proxyTargetClass = Boolean.valueOf(ele.getAttribute(PROXY_TARGET_CLASS));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanDefinitionHolder holder =</span><br><span class="line">            ScopedProxyUtils.</span><br><span class="line">            createScopedProxy(definition, parserContext.getRegistry(), proxyTargetClass);</span><br><span class="line">    String targetBeanName = ScopedProxyUtils.getTargetBeanName(definition.getBeanName());</span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">    parserContext.getReaderContext().fireComponentRegistered(</span><br><span class="line">            <span class="keyword">new</span> BeanComponentDefinition(definition.getBeanDefinition(), targetBeanName));</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心便是createScopedProxy方法，其源码较长，但是这个套路之前见识过了，就是一个偷天换日: 创建一个新的BeanDefinition对象，beanName为被代理的bean的名字，被代理的bean名字为scopedTarget.原名字。被代理的bean扔将被注册到容器中。</p><p>新的BeanDefintion的beanClass为ScopedProxyFactoryBean，其类图:</p><p><img src="http://tu.duia.online/b45775a439cb813d40a715cf69746a25" alt="ScopedProxyFactoryBean类图"></p><h2 id="代理生成"><a href="#代理生成" class="headerlink" title="代理生成"></a>代理生成</h2><p>入口便是setBeanFactory方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    ConfigurableBeanFactory cbf = (ConfigurableBeanFactory) beanFactory;</span><br><span class="line">    <span class="keyword">this</span>.scopedTargetSource.setBeanFactory(beanFactory);</span><br><span class="line">    ProxyFactory pf = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    pf.copyFrom(<span class="keyword">this</span>);</span><br><span class="line">    pf.setTargetSource(<span class="keyword">this</span>.scopedTargetSource);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; beanType = beanFactory.getType(<span class="keyword">this</span>.targetBeanName);</span><br><span class="line">    <span class="keyword">if</span> (!isProxyTargetClass() || beanType.isInterface() || </span><br><span class="line">        Modifier.isPrivate(beanType.getModifiers())) &#123;</span><br><span class="line">         <span class="comment">// JDK动态代理可用的接口</span></span><br><span class="line">        pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add an introduction that implements only the methods on ScopedObject.</span></span><br><span class="line">    ScopedObject scopedObject = <span class="keyword">new</span> DefaultScopedObject</span><br><span class="line">        (cbf, <span class="keyword">this</span>.scopedTargetSource.getTargetBeanName());</span><br><span class="line">    pf.addAdvice(<span class="keyword">new</span> DelegatingIntroductionInterceptor(scopedObject));</span><br><span class="line">    <span class="comment">// Add the AopInfrastructureBean marker to indicate that the scoped proxy</span></span><br><span class="line">    <span class="comment">// itself is not subject to auto-proxying! Only its target bean is.</span></span><br><span class="line">    pf.addInterface(AopInfrastructureBean.class);</span><br><span class="line">    <span class="keyword">this</span>.proxy = pf.getProxy(cbf.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个套路上面也见过了。</p><h3 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h3><p>核心的拦截逻辑是通过DelegatingIntroductionInterceptor来完成的，其类图:</p><p><img src="http://tu.duia.online/1e9ca3328386e419c42e122fe3399e69" alt="DelegatingIntroductionInterceptor类图"></p><p>AdvisedSupport.addAdvice方法将其转化为Advisor:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(<span class="keyword">int</span> pos, Advice advice)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> IntroductionInfo) &#123;</span><br><span class="line">        <span class="comment">// We don't need an IntroductionAdvisor for this kind of introduction:</span></span><br><span class="line">        <span class="comment">// It's fully self-describing.</span></span><br><span class="line">        addAdvisor(pos, <span class="keyword">new</span> DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> DynamicIntroductionAdvice) &#123;</span><br><span class="line">        <span class="comment">// We need an IntroductionAdvisor for this kind of introduction.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addAdvisor(pos, <span class="keyword">new</span> DefaultPointcutAdvisor(advice));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，DelegatingIntroductionInterceptor被包装为DefaultIntroductionAdvisor对象。</p><p>DelegatingIntroductionInterceptor到底是个什么东西呢?这其实就引出了Spring的Introduction(引入)概念。</p><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>通常意义上的Spring AOP一般是在方法层面上进行逻辑的改变，而引入指的是在不修改类源码的情况下，<strong>直接为一个类添加新的功能</strong>。下面是一个引入使用的例子:</p><p><a href="http://blog.csdn.net/lzghxjt/article/details/51974336" target="_blank" rel="noopener">SpringAOP中的IntroductionInterceptor</a></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="自定义Scope"><a href="#自定义Scope" class="headerlink" title="自定义Scope"></a>自定义Scope</h3><p>为了便于测试，我们定义一个生存周期仅仅在于一次调用的Scope，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get被调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="string">"skywalker-"</span> + (index++), index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//忽略其它方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其注册到容器中，有两种方法:</p><ul><li><p>在代码中: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getBeanFactory().registerScope(<span class="string">"one"</span>, <span class="keyword">new</span> OneScope());</span><br></pre></td></tr></table></figure></li><li><p>配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scopes"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.scope.OneScope"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>此时就可以使用我们自己的Scope了:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span> <span class="attr">id</span>=<span class="string">"simpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"student"</span> <span class="attr">ref</span>=<span class="string">"student"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span> <span class="attr">scope</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>执行以下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleBean simpleBean = context.getBean(SimpleBean.class);</span><br><span class="line">System.out.println(simpleBean.getStudent().getName());</span><br><span class="line">System.out.println(simpleBean.getStudent().getName());</span><br></pre></td></tr></table></figure><p>可以看到以下输出:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get被调用</span><br><span class="line">skywalker-0</span><br><span class="line">get被调用</span><br><span class="line">skywalker-1</span><br></pre></td></tr></table></figure><p>可以得出结论: <strong>当调用被代理的bean的方法时才会触发Scoped的语义，只是获得其对象(getStudent)没有效果</strong>。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h3><p>从根本上来说在于AbstractBeanFactory.doGetBean，部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope非prototype和Singleton</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    String scopeName = mbd.getScope();</span><br><span class="line">    <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">    Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scopes是BeanFactory内部的一个 LinkedHashMap&lt;String, Scope&gt;类型的对象。scope.get实际上调用的就是我们的OneSocpe的get方法，没有用到ObjectFactory。</p><p>所以，<strong>每调用一次getBean，就会导致一个新的Sudent被创建并返回</strong>。</p><h3 id="代理子类"><a href="#代理子类" class="headerlink" title="代理子类"></a>代理子类</h3><p>还有一个关键的问题，从上面可以知道SimpleBean内部的student引用其实是一个CGLIB代理子类的对象，那么当调用这个代理对象的相应方法(比如getName)时，是怎样导致Student重新创建(或是getBean被调用)的?</p><h3 id="CallbackFilter-amp-Callback"><a href="#CallbackFilter-amp-Callback" class="headerlink" title="CallbackFilter &amp; Callback"></a>CallbackFilter &amp; Callback</h3><p>必须首先理解下CGLIB的这两个概念。</p><h4 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h4><p><strong>Callback是Cglib所有自定义逻辑(增强)的共同接口</strong>。</p><p>其简略类图:</p><p><img src="http://tu.duia.online/aba8498ca2ccde009ea2d28cc1c1be3b" alt="Callback类图"></p><h4 id="CallbackFilter"><a href="#CallbackFilter" class="headerlink" title="CallbackFilter"></a>CallbackFilter</h4><p><strong>在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</strong></p><p>jdk并不支持这么搞，只支持设置一个InvocationHandler处理(拦截)所有的方法。其类图:</p><p><img src="http://tu.duia.online/9dbeb323f5b71d09dbe6e164227f1a5d" alt="CallbackFilter类图"></p><p>Cglib的Enhancer可以指定一个Callback数组，而accept方法的返回值是一个int值，其实就是Callback数组的下标，这样便达到了指定回调逻辑的目的。</p><p>参考:</p><p><a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener">CGLIB介绍与原理</a></p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>一般的方法使用的是DynamicAdvisedInterceptor作为回调逻辑，其intercept关键源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> </span>&#123;</span><br><span class="line">    Object target = getTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>target就是被代理对象。</p><p>getTarget:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getTarget</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.advised.getTargetSource().getTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TargetSource前面说过了，默认是SimpleBeanTargetSource:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(getTargetBeanName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，真相大白。</p><h1 id="aop-aspectj-autoproxy"><a href="#aop-aspectj-autoproxy" class="headerlink" title="aop:aspectj-autoproxy"></a>aop:aspectj-autoproxy</h1><p>此标签用以开启对于@AspectJ注解风格AOP的支持。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="proxy-target-class"><a href="#proxy-target-class" class="headerlink" title="proxy-target-class"></a>proxy-target-class</h3><p>你懂的。</p><h3 id="expose-proxy"><a href="#expose-proxy" class="headerlink" title="expose-proxy"></a>expose-proxy</h3><p>是否应该把代理对象暴露给AopContext，默认false。</p><h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(void base.aop.AopDemo.send(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSend</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"beforeSend()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send之前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="被代理类"><a href="#被代理类" class="headerlink" title="被代理类"></a>被代理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopDemo</span> <span class="keyword">implements</span> <span class="title">AopDemoInter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send from aopdemo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"receive from aopdemo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"inter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.aop.AopDemo"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.aop.annotation.AspectDemo"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>因为AopDemo实现了AopDemoInter接口，但做实验的send方法又不在此接口里定义，所以只能用cglib的方式代理。</p><p>可以看出，<strong>即使标注了@Aspect注解，仍然需要将切面自己配置到Spring容器中。</strong></p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>AspectJAutoProxyBeanDefinitionParser.parse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    AopNamespaceUtils.</span><br><span class="line">        registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">    extendBeanDefinition(element, parserContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册最终在AopConfigUtils.registerOrEscalateApcAsRequired方法中完成，创建器实际上是一个AnnotationAwareAspectJAutoProxyCreator类的对象，此类是前面AspectJAwareAdvisorAutoProxyCreator的子类。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>既然是AspectJAwareAdvisorAutoProxyCreator的子类，那么其代理子类的创建等核心逻辑自然是一样的。这里所需要关注的地方自然是所不一样的地方: 即是如何体现其注解的特性的。</p><p>前面说过，AspectJAwareAdvisorAutoProxyCreator通过findCandidateAdvisors方法来找到适用于bean的Advisor，所以注解的特性也是通过重写此方法来体现。</p><p>AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="comment">//这里</span></span><br><span class="line">    advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buildAspectJAdvisors方法所做的便是<strong>从容器中得到所有的bean，逐一判断是不是一个Aspect</strong>。那么判断Aspect的依据是什么?</p><p>AbstractAspectJAdvisorFactory.isAspect:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAspect</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于其它的实现细节不再探究。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Spring对于AspectJ风格AOP的支持停留在外表(注解)上面，内部的实现仍然是自己的东西。</p><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="AOP切面的坑"><a href="#AOP切面的坑" class="headerlink" title="AOP切面的坑"></a>AOP切面的坑</h2><ol><li>定义在private方法上的切面不会被执行，这个很容易理解，毕竟子类不能覆盖父类的私有方法。</li><li>同一个代理子类内部的方法相互调用不会再次执行切面。</li></ol><p>这里以Cglib为例对第二点进行说明，cglib的相关核心组件可以参考前面CallbackFilter &amp; Callback部分。对于配置了一个切面的典型场景，Spring内部的执行流程可总结如下图:</p><p><img src="http://tu.duia.online/4cae312cd6aa1b8ef1fc308c5f10fd94" alt="Cglib调用流程"></p><p>核心便是对目标方法的调用上，这里由CglibMethodInvocation的invokeJoinpoint实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publicMethod) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.methodProxy.invoke(<span class="keyword">this</span>.target, <span class="keyword">this</span>.arguments);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是非public方法，那么Spring将使用反射的方法对其进行调用，因为反射将其可访问性设为true。MethodProxy是Cglib对方法代理的抽象，这里的关键是<strong>方法调用的对象(目标)是我们的原生类对象，而不是Cglib代理子类的对象，这就从根本上决定了对同类方法的调用不会再次经过切面</strong>。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>前面aop:aspectj-autoproxy-属性-expose-proxy一节提到了，Spring允许我们将代理子类暴露出来，可以进行如下配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"simpleMethodInterceptor"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* aop.SimpleAopBean.*(..))"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们需要在一个被代理方法中调用同类的方法时(此方法也需要经过切面)，可以这样调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testB执行"</span>);</span><br><span class="line">    ((SimpleAopBean) AopContext.currentProxy()).testC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实是一个ThreadLocal，当Cglib代理子类创建调用链之间便会将代理类设置到其中，DynamicAdvisedInterceptor.intercept相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">    <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">    oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">    setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;aop部分的解析器由AopNamespaceHandler注册，其init方法:&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="spring" scheme="https://duia.github.io/categories/spring/"/>
    
      <category term="源码阅读" scheme="https://duia.github.io/categories/spring/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="源码阅读" scheme="https://duia.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="spring" scheme="https://duia.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring源码阅读-基础</title>
    <link href="https://duia.github.io/2016/11/16/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%9F%BA%E7%A1%80/"/>
    <id>https://duia.github.io/2016/11/16/spring源码阅读-基础/</id>
    <published>2016-11-16T14:10:00.000Z</published>
    <updated>2019-05-11T15:00:00.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>本部分从最基本的Spring开始。配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">    SimpleBean bean = context.getBean(SimpleBean.class);</span><br><span class="line">    bean.send();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>SimpleBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am send method from SimpleBean!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><p>整个继承体系如下:</p><p><img src="/upload/2019/1/ResourceLoader20190216152855827.jpg" alt="ResourceLoader继承体系"></p><p>ResourceLoader代表了<strong>加载资源的一种方式，正是策略模式的实现</strong>。</p><p>构造器源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext          parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//null</span></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="comment">//默认true</span></span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getResourcePatternResolver:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathMatchingResourcePatternResolver支持Ant风格的路径解析。</p><h3 id="设置配置文件路径"><a href="#设置配置文件路径" class="headerlink" title="设置配置文件路径"></a>设置配置文件路径</h3><p>即AbstractRefreshableConfigApplicationContext.setConfigLocations:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String... locations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolvePath:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: <code>new ClassPathXmlApplicationContext(&quot;classpath:config.xml&quot;);</code>那么classpath:就是需要被解析的。</p><p>getEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Environment接口"><a href="#Environment接口" class="headerlink" title="Environment接口"></a>Environment接口</h4><p>继承体系:</p><p><img src="/upload/2019/1/Environment20190216153011886.jpg" alt="Environment继承体系"></p><p>Environmen接口<strong>代表了当前应用所处的环境。</strong>从此接口的方法可以看出，其主要和profile、Property相关。</p><h5 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h5><p>Spring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。<strong>Spring容器管理的所有bean都是和一个profile绑定在一起的。</strong>使用了Profile的配置文件示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"develop"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:jdbc-develop.properties"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:jdbc-production.properties"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"test"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:jdbc-test.properties"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在启动代码中可以用如下代码设置活跃(当前使用的)Profile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getEnvironment().setActiveProfiles(<span class="string">"dev"</span>);</span><br></pre></td></tr></table></figure><p>当然使用的方式还有很多(比如注解)，参考:</p><p><a href="http://radiumxie.iteye.com/blog/1851919" target="_blank" rel="noopener">spring3.1 profile 配置不同的环境</a></p><p><a href="http://www.mkyong.com/spring/spring-profiles-example/" target="_blank" rel="noopener">Spring Profiles example</a></p><h5 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h5><p>这里的Property指的是程序运行时的一些参数，引用注释:</p><blockquote><p>properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on.</p></blockquote><h4 id="Environment构造器"><a href="#Environment构造器" class="headerlink" title="Environment构造器"></a>Environment构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MutablePropertySources propertySources = <span class="keyword">new</span> MutablePropertySources(<span class="keyword">this</span>.logger);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    customizePropertySources(<span class="keyword">this</span>.propertySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PropertySources接口"><a href="#PropertySources接口" class="headerlink" title="PropertySources接口"></a>PropertySources接口</h5><p>继承体系:</p><p><img src="/upload/2019/1/PropertySources20190216153122626.jpg" alt="PropertySources继承体系"></p><p>此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。</p><p>StandardEnvironment.customizePropertySources:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** System environment property source name: &#123;<span class="doctag">@value</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = <span class="string">"systemEnvironment"</span>;</span><br><span class="line"><span class="comment">/** JVM system properties property source name: &#123;<span class="doctag">@value</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = <span class="string">"systemProperties"</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>&#123;</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> MapPropertySource</span><br><span class="line">        (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> SystemEnvironmentPropertySource</span><br><span class="line">        (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PropertySource接口"><a href="#PropertySource接口" class="headerlink" title="PropertySource接口"></a>PropertySource接口</h5><p>PropertySource接口代表了键值对的Property来源。继承体系：</p><p><img src="/upload/2019/1/PropertySource20190216153201730.jpg" alt="PropertySource继承体系"></p><p>AbstractEnvironment.getSystemProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map) System.getProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map) <span class="keyword">new</span> ReadOnlySystemAttributesMap() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> String <span class="title">getSystemAttribute</span><span class="params">(String attributeName)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(attributeName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(format(<span class="string">"Caught AccessControlException when accessing system "</span> +</span><br><span class="line">                                <span class="string">"property [%s]; its value will be returned [null]. Reason: %s"</span>,</span><br><span class="line">                                attributeName, ex.getMessage()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。</p><p>getSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。</p><h4 id="路径Placeholder处理"><a href="#路径Placeholder处理" class="headerlink" title="路径Placeholder处理"></a>路径Placeholder处理</h4><p>AbstractEnvironment.resolveRequiredPlaceholders:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="comment">//text即配置文件路径，比如classpath:config.xml</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertyResolver.resolveRequiredPlaceholders(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>propertyResolver是一个PropertySourcesPropertyResolver对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConfigurablePropertyResolver propertyResolver =</span><br><span class="line">            <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources);</span><br></pre></td></tr></table></figure><h5 id="PropertyResolver接口"><a href="#PropertyResolver接口" class="headerlink" title="PropertyResolver接口"></a>PropertyResolver接口</h5><p>PropertyResolver继承体系(排除Environment分支):</p><p><img src="/upload/2019/1/PropertyResolver20190216153244555.jpg" alt="PropertyResolver继承体系"></p><p>此接口正是用来解析PropertyResource。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>AbstractPropertyResolver.resolveRequiredPlaceholders:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.strictHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.strictHelper = createPlaceholderHelper(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doResolvePlaceholders(text, <span class="keyword">this</span>.strictHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PropertyPlaceholderHelper <span class="title">createPlaceholderHelper</span><span class="params">(<span class="keyword">boolean</span> ignoreUnresolvablePlaceholders)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//三个参数分别是$&#123;, &#125;, :</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="keyword">this</span>.placeholderPrefix, <span class="keyword">this</span>.placeholderSuffix,</span><br><span class="line">        <span class="keyword">this</span>.valueSeparator, ignoreUnresolvablePlaceholders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doResolvePlaceholders：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doResolvePlaceholders</span><span class="params">(String text, PropertyPlaceholderHelper helper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//PlaceholderResolver接口依然是策略模式的体现</span></span><br><span class="line">    <span class="keyword">return</span> helper.replacePlaceholders(text, <span class="keyword">new</span> PropertyPlaceholderHelper.PlaceholderResolver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPropertyAsRawString(placeholderName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"spring"</span>, <span class="string">"classpath"</span>);</span><br><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"$&#123;spring&#125;:config.xml"</span>);</span><br><span class="line">SimpleBean bean = context.getBean(SimpleBean.class);</span><br></pre></td></tr></table></figure><p>这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getPropertyAsRawString</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProperty(key, String.class, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">            Object value = propertySource.getProperty(key);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。</p><p>注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。</p><h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2><p>Spring bean解析就在此方法，所以单独提出来。</p><p>AbstractApplicationContext.refresh:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">    <span class="comment">//空实现</span></span><br><span class="line">    initPropertySources();</span><br><span class="line">    <span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line">    <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性校验"><a href="#属性校验" class="headerlink" title="属性校验"></a>属性校验</h4><p>AbstractEnvironment.validateRequiredProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> <span class="keyword">throws</span> MissingRequiredPropertiesException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.propertyResolver.validateRequiredProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPropertyResolver.validateRequiredProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MissingRequiredPropertiesException ex = <span class="keyword">new</span> MissingRequiredPropertiesException();</span><br><span class="line">    <span class="keyword">for</span> (String key : <span class="keyword">this</span>.requiredProperties) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getProperty(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ex.addMissingRequiredProperty(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ex.getMissingRequiredProperties().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>requiredProperties是通过setRequiredProperties方法设置的，保存在一个list里面，默认是空的，也就是不需要校验任何属性。</p><h3 id="BeanFactory创建"><a href="#BeanFactory创建" class="headerlink" title="BeanFactory创建"></a>BeanFactory创建</h3><p>由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//如果已经存在，那么销毁之前的</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建了一个DefaultListableBeanFactory对象</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h4><p>此接口实际上就是Bean容器，其继承体系:</p><p><img src="/upload/2019/1/BeanFactory20190216153345382.jpg" alt="BeanFactory继承体系"></p><h4 id="BeanFactory定制"><a href="#BeanFactory定制" class="headerlink" title="BeanFactory定制"></a>BeanFactory定制</h4><p>AbstractRefreshableApplicationContext.customizeBeanFactory方法用于给子类提供一个自由配置的机会，默认实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//默认false，不允许覆盖</span></span><br><span class="line">        beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//默认false，不允许循环引用</span></span><br><span class="line">        beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean加载"><a href="#Bean加载" class="headerlink" title="Bean加载"></a>Bean加载</h4><p>AbstractXmlApplicationContext.loadBeanDefinitions，这个便是核心的bean加载了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    <span class="comment">//默认空实现</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EntityResolver"><a href="#EntityResolver" class="headerlink" title="EntityResolver"></a>EntityResolver</h5><p>此处只说明用到的部分继承体系:</p><p><img src="/upload/2019/1/EntityResolver20190216153445595.jpg" alt="EntityResolver继承体系"></p><p>EntityResolver接口在org.xml.sax中定义。DelegatingEntityResolver用于schema和dtd的解析。</p><h5 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h5><p>继承体系:</p><p><img src="/upload/2019/1/BeanDefinitionReader20190216153522690.jpg" alt="BeanDefinitionReader继承体系"></p><h5 id="路径解析-Ant"><a href="#路径解析-Ant" class="headerlink" title="路径解析(Ant)"></a>路径解析(Ant)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="comment">//here</span></span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractBeanDefinitionReader.loadBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        counter += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个参数为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="comment">//参见ResourceLoader类图，ClassPathXmlApplicationContext实现了此接口</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getResource的实现在AbstractApplicationContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//构造器中初始化，PathMatchingResourcePatternResolver对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathMatchingResourcePatternResolver是ResourceLoader继承体系的一部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">    <span class="comment">//classpath:</span></span><br><span class="line">    <span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">        <span class="comment">// a class path resource (multiple resources for same name possible)</span></span><br><span class="line">        <span class="comment">//matcher是一个AntPathMatcher对象</span></span><br><span class="line">        <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern</span><br><span class="line">            .substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">            <span class="comment">// a class path resource pattern</span></span><br><span class="line">            <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// all class path resources with the given name</span></span><br><span class="line">            <span class="keyword">return</span> findAllClassPathResources(locationPattern</span><br><span class="line">                .substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Only look for a pattern after a prefix here</span></span><br><span class="line">        <span class="comment">// (to not get fooled by a pattern symbol in a strange prefix).</span></span><br><span class="line">        <span class="keyword">int</span> prefixEnd = locationPattern.indexOf(<span class="string">":"</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">            <span class="comment">// a file pattern</span></span><br><span class="line">            <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a single resource with the given name</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isPattern:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPattern</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (path.indexOf(<span class="string">'*'</span>) != -<span class="number">1</span> || path.indexOf(<span class="string">'?'</span>) != -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出配置文件路径是支持ant风格的，也就是可以这么写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"con*.xml"</span>);</span><br></pre></td></tr></table></figure><p>具体怎么解析ant风格的就不写了。</p><h5 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h5><p>入口方法在AbstractBeanDefinitionReader的217行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载</span></span><br><span class="line">Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br></pre></td></tr></table></figure><p>最终逐个调用XmlBeanDefinitionReader的loadBeanDefinitions方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Resource是代表一种资源的接口，其类图:</p><p><img src="/upload/2019/1/Resource20190216153615404.jpg" alt="Resource类图"></p><p>EncodedResource扮演的其实是一个装饰器的模式，为InputStreamSource添加了字符编码(虽然默认为null)。这样为我们自定义xml配置文件的编码方式提供了机会。</p><p>之后关键的源码只有两行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">    InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">    <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputSource是org.xml.sax的类。</p><p>doLoadBeanDefinitions：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span> </span>&#123;</span><br><span class="line">    Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doLoadDocument:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">        getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>documentLoader是一个DefaultDocumentLoader对象，此类是DocumentLoader接口的唯一实现。getEntityResolver方法返回ResourceEntityResolver，上面说过了。errorHandler是一个SimpleSaxErrorHandler对象。</p><p>校验模型其实就是确定xml文件使用xsd方式还是dtd方式来校验，忘了的话左转度娘。Spring会通过读取xml文件的方式判断应该采用哪种。</p><p>NamespaceAware默认false，因为默认配置了校验为true。</p><p>DefaultDocumentLoader.loadDocument:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">    ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里就是老套路了，可以看出，Spring还是使用了dom的方式解析，即一次全部load到内存</span></span><br><span class="line">    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">    <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createDocumentBuilderFactory比较有意思:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance()</span></span>;</span><br><span class="line">    factory.setNamespaceAware(namespaceAware);</span><br><span class="line">    <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">        <span class="comment">//此方法设为true仅对dtd有效，xsd(schema)无效</span></span><br><span class="line">        factory.setValidating(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">            <span class="comment">// Enforce namespace aware for XSD...</span></span><br><span class="line">             <span class="comment">//开启xsd(schema)支持</span></span><br><span class="line">            factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">             <span class="comment">//这个也是Java支持Schema的套路，可以问度娘</span></span><br><span class="line">            factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Bean解析"><a href="#Bean解析" class="headerlink" title="Bean解析"></a>Bean解析</h5><p>XmlBeanDefinitionReader.registerBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBeanDefinitionDocumentReader:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast</span><br><span class="line">      <span class="comment">//反射</span></span><br><span class="line">      (BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>documentReaderClass默认是DefaultBeanDefinitionDocumentReader，这其实也是策略模式，通过setter方法可以更换其实现。</p><p>注意cast方法，代替了强转。</p><p>createReaderContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">        <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>problemReporter是一个FailFastProblemReporter对象。</p><p>eventListener是EmptyReaderEventListener对象，此类里的方法都是空实现。</p><p>sourceExtractor是NullSourceExtractor对象，直接返回空，也是空实现。</p><p>getNamespaceHandlerResolver默认返回DefaultNamespaceHandlerResolver对象，用来获取xsd对应的处理器。</p><p>XmlReaderContext的作用感觉就是这一堆参数的容器，糅合到一起传给DocumentReader，并美其名为Context。可以看出，Spring中到处都是策略模式，大量操作被抽象成接口。</p><p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doRegisterBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    <span class="comment">//默认的命名空间即</span></span><br><span class="line">    <span class="comment">//http://www.springframework.org/schema/beans</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">//检查profile属性</span></span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            <span class="comment">//profile属性可以以,分割</span></span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    postProcessXml(root);</span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delegate的作用在于处理beans标签的嵌套，其实Spring配置文件是可以写成这样的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"java.lang.Object"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>xml(schema)的命名空间其实类似于java的报名，命名空间采用URL，比如Spring的是这样:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>xmlns属性就是xml规范定义的用来设置命名空间的。这样设置了之后其实里面的bean元素全名就相当于<code>http://www.springframework.org/schema/beans:bean</code>，可以有效的防止命名冲突。命名空间可以通过规范定义的org.w3c.dom.Node.getNamespaceURI方法获得。</p><p>注意一下profile的检查, AbstractEnvironment.acceptsProfiles:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptsProfiles</span><span class="params">(String... profiles)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(profiles, <span class="string">"Must specify at least one profile"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String profile : profiles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(profile) &amp;&amp; profile.charAt(<span class="number">0</span>) == <span class="string">'!'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isProfileActive(profile.substring(<span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isProfileActive(profile)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理很简单，注意从源码可以看出，<strong>profile属性支持!取反</strong>。</p><p>preProcessXml方法是个空实现，供子类去覆盖，<strong>目的在于给子类一个把我们自定义的标签转为Spring标准标签的机会</strong>, 想的真周到。</p><p>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，对于非默认命名空间的元素交由delegate处理。</p><h4 id="默认命名空间解析"><a href="#默认命名空间解析" class="headerlink" title="默认命名空间解析"></a>默认命名空间解析</h4><p>即import, alias, bean, 嵌套的beans四种元素。parseDefaultElement:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//"import"</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// recurse</span></span><br><span class="line">        doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>写法示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"CTIContext.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"customerContext.xml"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>importBeanDefinitionResource套路和之前的配置文件加载完全一样，不过注意被import进来的文件是先于当前文件 被解析的。</p><h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><p>加入有一个bean名为componentA-dataSource，但是另一个组件想以componentB-dataSource的名字使用，就可以这样定义:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"componentA-dataSource"</span> <span class="attr">alias</span>=<span class="string">"componentB-dataSource"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>processAliasRegistration核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">    getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">    getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面的源码可以发现，registry其实就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口。registerAlias方法的实现在SimpleAliasRegistry:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">    Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</span><br><span class="line">    Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</span><br><span class="line">    <span class="comment">//名字和别名一样</span></span><br><span class="line">    <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">        <span class="comment">//ConcurrentHashMap</span></span><br><span class="line">        <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">        <span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">                <span class="comment">// An existing alias - no need to re-register</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException</span><br><span class="line">                    (<span class="string">"Cannot register alias '"</span> + alias + <span class="string">"' for name '"</span> +</span><br><span class="line">                    name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        checkForAliasCircle(name, alias);</span><br><span class="line">        <span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以别名关系的保存使用Map完成，key为别名，value为本来的名字。</p><h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><p>bean节点是Spring最最常见的节点了。</p><p>DefaultBeanDefinitionDocumentReader.processBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition</span><br><span class="line">                (bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="id-amp-name处理"><a href="#id-amp-name处理" class="headerlink" title="id &amp; name处理"></a>id &amp; name处理</h6><p>最终调用BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)，源码较长，分部分说明。</p><p>首先获取到id和name属性，<strong>name属性支持配置多个，以逗号分隔，如果没有指定id，那么将以第一个name属性值代替。id必须是唯一的，name属性其实是alias的角色，可以和其它的bean重复，如果name也没有配置，那么其实什么也没做</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    <span class="comment">//按,分隔</span></span><br><span class="line">    String[] nameArr = StringUtils.tokenizeToStringArray</span><br><span class="line">        (nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">    aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line">String beanName = id;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//name的第一个值作为id</span></span><br><span class="line">    beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//校验id是否已重复，如果重复直接抛异常</span></span><br><span class="line">    <span class="comment">//校验是通过内部一个HashSet完成的，出现过的id都会保存进此Set</span></span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="beanName生成"><a href="#beanName生成" class="headerlink" title="beanName生成"></a>beanName生成</h6><p>如果name和id属性都没有指定，那么Spring会自己生成一个, BeanDefinitionParserDelegate.parseBeanDefinitionElement:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">aliases.add(beanClassName);</span><br></pre></td></tr></table></figure><p>可见，Spring同时会把类名作为其别名。</p><p>最终调用的是BeanDefinitionReaderUtils.generateBeanName:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateBeanName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinition definition, BeanDefinitionRegistry registry, <span class="keyword">boolean</span> isInnerBean)</span> </span>&#123;</span><br><span class="line">    String generatedBeanName = definition.getBeanClassName();</span><br><span class="line">    <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (definition.getParentName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            generatedBeanName = definition.getParentName() + <span class="string">"$child"</span>;</span><br><span class="line">             <span class="comment">//工厂方法产生的bean</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (definition.getFactoryBeanName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            generatedBeanName = definition.getFactoryBeanName() + <span class="string">"$created"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String id = generatedBeanName;</span><br><span class="line">    <span class="keyword">if</span> (isInnerBean) &#123;</span><br><span class="line">        <span class="comment">// Inner bean: generate identity hashcode suffix.</span></span><br><span class="line">        id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + </span><br><span class="line">            ObjectUtils.getIdentityHexString(definition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Top-level bean: use plain class name.</span></span><br><span class="line">        <span class="comment">// Increase counter until the id is unique.</span></span><br><span class="line">        <span class="keyword">int</span> counter = -<span class="number">1</span>;</span><br><span class="line">         <span class="comment">//用类名#自增的数字命名</span></span><br><span class="line">        <span class="keyword">while</span> (counter == -<span class="number">1</span> || registry.containsBeanDefinition(id)) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">            id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="bean解析"><a href="#bean解析" class="headerlink" title="bean解析"></a>bean解析</h6><p>还是分部分说明(parseBeanDefinitionElement)。</p><p>首先获取到bean的class属性和parent属性，配置了parent之后，当前bean会继承父bean的属性。之后根据class和parent创建BeanDefinition对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">    className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line">String parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">    parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br></pre></td></tr></table></figure><p>BeanDefinition的创建在BeanDefinitionReaderUtils.createBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String parentName, String className, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">    bd.setParentName(parentName);</span><br><span class="line">    <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bd.setBeanClassName(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后是解析bean的其它属性，其实就是读取其配置，调用相应的setter方法保存在BeanDefinition中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br></pre></td></tr></table></figure><p>之后解析bean的decription子元素:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">name</span>=<span class="string">"one, two"</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SimpleBean<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就仅仅是个描述。</p><p>然后是meta子元素的解析，meta元素在xml配置文件里是这样的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">name</span>=<span class="string">"one, two"</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注释上说，这样可以将任意的元数据附到对应的bean definition上。解析过程源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMetaElements</span><span class="params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> </span>&#123;</span><br><span class="line">    NodeList nl = ele.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">            Element metaElement = (Element) node;</span><br><span class="line">            String key = metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">            String value = metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">             <span class="comment">//就是一个key, value的载体，无他</span></span><br><span class="line">            BeanMetadataAttribute attribute = <span class="keyword">new</span> BeanMetadataAttribute(key, value);</span><br><span class="line">             <span class="comment">//sourceExtractor默认是NullSourceExtractor，返回的是空</span></span><br><span class="line">            attribute.setSource(extractSource(metaElement));</span><br><span class="line">            attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractBeanDefinition继承自BeanMetadataAttributeAccessor类，底层使用了一个LinkedHashMap保存metadata。这个metadata具体是做什么暂时还不知道。</p><p>lookup-method解析：</p><p>此标签的作用在于当一个bean的某个方法被设置为lookup-method后，<strong>每次调用此方法时，都会返回一个新的指定bean的对象</strong>。用法示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"apple"</span> <span class="attr">class</span>=<span class="string">"cn.com.willchen.test.di.Apple"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--水果盘--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"fruitPlate"</span> <span class="attr">class</span>=<span class="string">"cn.com.willchen.test.di.FruitPlate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getFruit"</span> <span class="attr">bean</span>=<span class="string">"apple"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据保存在Set中，对应的类是MethodOverrides。可以参考:</p><p><a href="http://www.cnblogs.com/ViviChan/p/4981619.html" target="_blank" rel="noopener">Spring - lookup-method方式实现依赖注入</a></p><p>replace-mothod解析:</p><p>此标签用于替换bean里面的特定的方法实现，替换者必须实现Spring的MethodReplacer接口，有点像aop的意思。</p><p>配置文件示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"replacer"</span> <span class="attr">class</span>=<span class="string">"springroad.deomo.chap4.MethodReplace"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"springroad.deomo.chap4.LookupMethodBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">replacer</span>=<span class="string">"replacer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span> <span class="attr">match</span>=<span class="string">"String"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>arg-type的作用是指定替换方法的参数类型，因为接口的定义参数都是Object的。参考: <a href="http://blog.csdn.net/lee576/article/details/8725548" target="_blank" rel="noopener">SPRING.NET 1.3.2 学习20–方法注入之替换方法注入</a></p><p>解析之后将数据放在ReplaceOverride对象中，里面有一个LinkedList<string>专门用于保存arg-type。</string></p><p>构造参数(constructor-arg)解析:</p><p>作用一目了然，使用示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>Cat<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>type一般不需要指定，除了泛型集合那种。除此之外，constructor-arg还支持name, index, ref等属性，可以具体的指定参数的位置等。构造参数解析后保存在BeanDefinition内部一个ConstructorArgumentValues对象中。如果设置了index属性，那么以Map&lt;Integer, ValueHolder&gt;的形式保存，反之，以List<valueholder>的形式保存。</valueholder></p><p>property解析:</p><p>非常常用的标签，用以为bean的属性赋值，支持value和ref两种形式，示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>value和ref属性不能同时出现，如果是ref，那么将其值保存在不可变的RuntimeBeanReference对象中，其实现了BeanReference接口，此接口只有一个getBeanName方法。如果是value，那么将其值保存在TypedStringValue对象中。最终将对象保存在BeanDefinition内部一个MutablePropertyValues对象中(内部以ArrayList实现)。</p><p>qualifier解析:</p><p>配置示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"12"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"org.springframework.beans.factory.annotation.Qualifier"</span> <span class="attr">value</span>=<span class="string">"student"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"seaswalker"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">"student_2"</span>&gt;</span><span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>SimpleBean部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">private</span> Student student;</span><br></pre></td></tr></table></figure><p>此标签和@Qualifier, @Autowired两个注解一起使用才有作用。@Autowired注解采用按类型查找的方式进行注入，如果找到多个需要类型的bean便会报错，有了@Qualifier标签就可以再按照此注解指定的名称查找。两者结合相当于实现了按类型+名称注入。type属性可以不指定，因为默认就是那个。qualifier标签可以有attribute子元素，比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"org.springframework.beans.factory.annotation.Qualifier"</span> <span class="attr">value</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br></pre></td></tr></table></figure><p>貌似是用来在qualifier也区分不开的时候使用。attribute键值对保存在BeanMetadataAttribute对象中。整个qualifier保存在AutowireCandidateQualifier对象中。</p><h6 id="Bean装饰"><a href="#Bean装饰" class="headerlink" title="Bean装饰"></a>Bean装饰</h6><p>这部分是针对其它schema的属性以及子节点，比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.Student"</span> <span class="attr">primary</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-override</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没见过这种用法，留个坑。</p><h6 id="Bean注册"><a href="#Bean注册" class="headerlink" title="Bean注册"></a>Bean注册</h6><p>BeanDefinitionReaderUtils.registerBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registry其实就是DefaultListableBeanFactory对象，registerBeanDefinition方法主要就干了这么两件事:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是Map，另一个是List，一目了然。registerAlias方法的实现在其父类SimpleAliasRegistry，就是把键值对放在了一个ConcurrentHashMap里。</p><p>ComponentRegistered事件触发:</p><p>默认是个空实现，前面说过了。</p><h6 id="BeanDefiniton数据结构"><a href="#BeanDefiniton数据结构" class="headerlink" title="BeanDefiniton数据结构"></a>BeanDefiniton数据结构</h6><p>BeanDefiniton数据结构如下图:</p><p><img src="/uploads/spring/images/BeanDefinition.jpg" alt="BeanDefinition数据结构"></p><h5 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h5><p>beans元素的嵌套直接递归调用DefaultBeanDefinitionDocumentReader.parseBeanDefinitions。</p><h4 id="其它命名空间解析"><a href="#其它命名空间解析" class="headerlink" title="其它命名空间解析"></a>其它命名空间解析</h4><p>入口在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions-&gt;BeanDefinitionParserDelegate.parseCustomElement(第二个参数为空):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">    String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">    NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamespaceHandlerResolver由XmlBeanDefinitionReader初始化，是一个DefaultNamespaceHandlerResolver对象，也是NamespaceHandlerResolver接口的唯一实现。</p><p>其resolve方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">    Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">        <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String className = (String) handlerOrClassName;</span><br><span class="line">        Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line">        NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">        namespaceHandler.init();</span><br><span class="line">        handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">        <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易看出，Spring其实使用了一个Map了保存其映射关系，key就是命名空间的uri，value是<strong>NamespaceHandler对象或是Class完整名，如果发现是类名，那么用反射的方法进行初始化，如果是NamespaceHandler对象，那么直接返回</strong>。</p><p>NamespaceHandler映射关系来自于各个Spring jar包下的META-INF/spring.handlers文件，以spring-context包为例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></table></figure><h5 id="NamespaceHandler继承体系"><a href="#NamespaceHandler继承体系" class="headerlink" title="NamespaceHandler继承体系"></a>NamespaceHandler继承体系</h5><p><img src="/upload/2019/1/NamespaceHandler20190216153833238.jpg" alt="NamespaceHandler继承体系"></p><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>resolve中调用了其init方法，此方法用以向NamespaceHandler对象注册BeanDefinitionParser对象。<strong>此接口用以解析顶层(beans下)的非默认命名空间元素，比如<code>&lt;context:annotation-config /&gt;</code></strong>。</p><p>所以这样逻辑就很容易理解了: <strong>每种子标签的解析仍是策略模式的体现，init负责向父类NamespaceHandlerSupport注册不同的策略，由父类的NamespaceHandlerSupport.parse方法根据具体的子标签调用相应的策略完成解析的过程</strong>。</p><p>此部分较为重要，所以重新开始大纲。</p><h5 id="BeanFactory数据结构"><a href="#BeanFactory数据结构" class="headerlink" title="BeanFactory数据结构"></a>BeanFactory数据结构</h5><p>BeanDefinition在BeanFactory中的主要数据结构如下图:</p><p><img src="/upload/2019/1/Beanfactory_structure20190216153904330.jpg" alt="Beanfactory数据结构"></p><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><p>此方法负责对BeanFactory进行一些特征的设置工作，”特征”包含这么几个方面:</p><h4 id="BeanExpressionResolver"><a href="#BeanExpressionResolver" class="headerlink" title="BeanExpressionResolver"></a>BeanExpressionResolver</h4><p>此接口只有一个实现: StandardBeanExpressionResolver。接口只含有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">evaluate</span><span class="params">(String value, BeanExpressionContext evalContext)</span></span></span><br></pre></td></tr></table></figure><p>prepareBeanFactory将一个此对象放入BeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span>  StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br></pre></td></tr></table></figure><p>StandardBeanExpressionResolver对象内部有一个关键的成员: SpelExpressionParser,其整个类图:</p><p><img src="/upload/2019/1/ExpressionParser20190216153944300.jpg" alt="ExpressionParser继承体系"></p><p>这便是Spring3.0开始出现的Spel表达式的解释器。</p><h4 id="PropertyEditorRegistrar"><a href="#PropertyEditorRegistrar" class="headerlink" title="PropertyEditorRegistrar"></a>PropertyEditorRegistrar</h4><p>此接口用于向Spring注册java.beans.PropertyEditor，只有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerCustomEditors(PropertyEditorRegistry registry)</span><br></pre></td></tr></table></figure><p>实现也只有一个: ResourceEditorRegistrar。</p><p>在编写xml配置时，我们设置的值都是字符串形式，所以在使用时肯定需要转为我们需要的类型，PropertyEditor接口正是定义了这么个东西。</p><p>prepareBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br></pre></td></tr></table></figure><p>BeanFactory也暴露了registerCustomEditors方法用以添加自定义的转换器，所以这个地方是组合模式的体现。</p><p>我们有两种方式可以添加自定义PropertyEditor:</p><ul><li><p>通过<code>context.getBeanFactory().registerCustomEditor</code></p></li><li><p>通过Spring配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customEditors"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"base.Cat"</span> <span class="attr">value</span>=<span class="string">"base.CatEditor"</span> /&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考: <a href="http://blog.csdn.net/zhoudaxia/article/details/36247883" target="_blank" rel="noopener">深入理解JavaBean(2)：属性编辑器PropertyEditor</a></p><h4 id="环境注入"><a href="#环境注入" class="headerlink" title="环境注入"></a>环境注入</h4><p>在Spring中我们自己的bean可以通过实现EnvironmentAware等一系列Aware接口获取到Spring内部的一些对象。prepareBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>ApplicationContextAwareProcessor核心的invokeAwareInterfaces方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">            ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="依赖解析忽略"><a href="#依赖解析忽略" class="headerlink" title="依赖解析忽略"></a>依赖解析忽略</h4><p>此部分设置哪些接口在进行依赖注入的时候应该被忽略:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br></pre></td></tr></table></figure><h4 id="bean伪装"><a href="#bean伪装" class="headerlink" title="bean伪装"></a>bean伪装</h4><p>有些对象并不在BeanFactory中，但是我们依然想让它们可以被装配，这就需要伪装一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>伪装关系保存在一个<code>Map&lt;Class&lt;?&gt;, Object&gt;</code>里。</p><h4 id="LoadTimeWeaver"><a href="#LoadTimeWeaver" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h4><p>如果配置了此bean，那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个东西具体是干什么的在后面context:load-time-weaver中说明。</p><h4 id="注册环境"><a href="#注册环境" class="headerlink" title="注册环境"></a>注册环境</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().</span><br><span class="line">        getSystemEnvironment());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>containsLocalBean特殊之处在于不会去父BeanFactory寻找。</p><h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>此方法允许子类在所有的bean尚未初始化之前注册BeanPostProcessor。空实现且没有子类覆盖。</p><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>BeanFactoryPostProcessor接口允许我们在bean正是初始化之前改变其值。此接口只有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span>;</span><br></pre></td></tr></table></figure><p>有两种方式可以向Spring添加此对象:</p><ul><li><p>通过代码的方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.addBeanFactoryPostProcessor</span><br></pre></td></tr></table></figure></li><li><p>通过xml配置的方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBeanFactoryPostProcessor"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>注意此时尚未进行bean的初始化工作，初始化是在后面的finishBeanFactoryInitialization进行的，所以在BeanFactoryPostProcessor对象中获取bean会导致提前初始化。</p><p>此方法的关键源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory,</span><br><span class="line">        getBeanFactoryPostProcessors());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBeanFactoryPostProcessors获取的就是AbstractApplicationContext的成员beanFactoryPostProcessors(ArrayList)，但是很有意思，<strong>只有通过context.addBeanFactoryPostProcessor这种方式添加的才会出现在这个List里，所以对于xml配置方式，此List其实没有任何元素。玄机就在PostProcessorRegistrationDelegate里</strong>。</p><p>核心思想就是使用BeanFactory的getBeanNamesForType方法获取相应的BeanDefinition的name数组，之后逐一调用getBean方法获取到bean(初始化)，getBean方法后面再说。</p><p>注意此处有一个优先级的概念，如果你的BeanFactoryPostProcessor同时实现了Ordered或者是PriorityOrdered接口，那么会被首先执行。</p><h3 id="BeanPostProcessor注册"><a href="#BeanPostProcessor注册" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h3><p>此部分实质上是在BeanDefinitions中寻找BeanPostProcessor，之后调用BeanFactory.addBeanPostProcessor方法保存在一个List中，注意添加时仍然有优先级的概念，优先级高的在前面。</p><h3 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h3><p>此接口用以支持Spring国际化。继承体系如下:</p><p><img src="/upload/2019/1/MessageSource2019021615404914.jpg" alt="MessageSource继承体系"></p><p>AbstractApplicationContext的initMessageSource()方法就是在BeanFactory中查找MessageSource的bean，如果配置了此bean，那么调用getBean方法完成其初始化并将其保存在AbstractApplicationContext内部messageSource成员变量中，用以处理ApplicationContext的getMessage调用，因为从继承体系上来看，ApplicationContext是MessageSource的子类，此处是委托模式的体现。如果没有配置此bean，那么初始化一个DelegatingMessageSource对象，此类是一个空实现，同样用以处理getMessage调用请求。</p><p>参考: <a href="http://stamen.iteye.com/blog/1541732" target="_blank" rel="noopener">学习Spring必学的Java基础知识(8)—-国际化信息</a></p><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>此接口代表了Spring的事件驱动(监听器)模式。一个事件驱动包含三部分:</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>java的所有事件对象一般都是java.util.EventObject的子类，Spring的整个继承体系如下:</p><p><img src="/upload/2019/1/EventObject20190216154539941.jpg" alt="EventObject继承体系"></p><h4 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h4><h5 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h5><p><img src="/upload/2019/1/ApplicationEventPublisher20190216154621676.jpg" alt="ApplicationEventPublisher继承体系"></p><p>一目了然。</p><h5 id="ApplicationEventMulticaster"><a href="#ApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster"></a>ApplicationEventMulticaster</h5><p>ApplicationEventPublisher实际上正是将请求委托给ApplicationEventMulticaster来实现的。其继承体系:</p><p><img src="/upload/2019/1/ApplicationEventMulticaster201902161546589.jpg" alt="ApplicationEventMulticaster继承体系"></p><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>所有的监听器是jdk EventListener的子类，这是一个mark接口。继承体系:</p><p><img src="/upload/2019/1/EventListener20190216154742511.jpg" alt="EventListener继承体系"></p><p>可以看出SmartApplicationListener和GenericApplicationListener是高度相似的，都提供了事件类型检测和顺序机制，而后者是从Spring4.2加入的，Spring官方文档推荐使用后者代替前者。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>前面说过ApplicationEventPublisher是通过委托给ApplicationEventMulticaster实现的，所以refresh方法中完成的是对ApplicationEventMulticaster的初始化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br></pre></td></tr></table></figure><p>initApplicationEventMulticaster则首先在BeanFactory中寻找ApplicationEventMulticaster的bean，如果找到，那么调用getBean方法将其初始化，如果找不到那么使用SimpleApplicationEventMulticaster。</p><h4 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h4><p>AbstractApplicationContext.publishEvent核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleApplicationEventMulticaster.multicastEvent:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        Executor executor = getTaskExecutor();</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    invokeListener(listener, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="监听器获取"><a href="#监听器获取" class="headerlink" title="监听器获取"></a>监听器获取</h5><p>获取当然还是通过beanFactory的getBean来完成的，值得注意的是Spring在此处使用了缓存(ConcurrentHashMap)来加速查找的过程。</p><h5 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h5><p>可以看出，如果executor不为空，那么监听器的执行实际上是异步的。那么如何配置同步/异步呢?</p><h6 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"multicasterExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.event.SimpleApplicationEventMulticaster"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"taskExecutor"</span> <span class="attr">ref</span>=<span class="string">"multicasterExecutor"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>task schema是Spring从3.0开始加入的，使我们可以不再依赖于Quartz实现定时任务，源码在org.springframework.core.task包下，使用需要引入schema：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task"</span><br><span class="line">xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd"</span><br></pre></td></tr></table></figure><p>可以参考: <a href="http://gong1208.iteye.com/blog/1773177" target="_blank" rel="noopener">Spring定时任务的几种实现</a></p><h6 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h6><p>开启注解支持:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启@AspectJ AOP代理 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 任务调度器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 任务执行器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"executor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--开启注解调度支持 @Async @Scheduled--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"executor"</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在代码中使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailRegisterListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">RegisterEvent</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(<span class="keyword">final</span> RegisterEvent event)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"注册成功，发送确认邮件给："</span> + ((User)event.getSource()).getUsername());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考: <a href="http://jinnianshilongnian.iteye.com/blog/1902886" target="_blank" rel="noopener">详解Spring事件驱动模型</a></p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>这又是一个模版方法，允许子类在进行bean初始化之前进行一些定制操作。默认空实现。</p><h3 id="ApplicationListener注册"><a href="#ApplicationListener注册" class="headerlink" title="ApplicationListener注册"></a>ApplicationListener注册</h3><p>registerListeners方法干的，没什么好说的。</p><h3 id="singleton初始化"><a href="#singleton初始化" class="headerlink" title="singleton初始化"></a>singleton初始化</h3><p>finishBeanFactoryInitialization：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType</span><br><span class="line">        (LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分部分说明。</p><h4 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h4><p>此接口用于类型之间的转换，在Spring里其实就是把配置文件中的String转为其它类型，从3.0开始出现，目的和jdk的PropertyEditor接口是一样的，参考ConfigurableBeanFactory.setConversionService注释:</p><blockquote><blockquote><p>Specify a Spring 3.0 ConversionService to use for converting<br>property values, as an alternative to JavaBeans PropertyEditors.<br>@since 3.0</p></blockquote></blockquote><h4 id="StringValueResolver"><a href="#StringValueResolver" class="headerlink" title="StringValueResolver"></a>StringValueResolver</h4><p>用于解析注解的值。接口只定义了一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h4><p>实现了此接口的bean可以得到LoadTimeWeaver，此处仅仅初始化。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>DefaultListableBeanFactory.preInstantiateSingletons:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX </span><br><span class="line">                    + beanName);</span><br><span class="line">                <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                    isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                            ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = </span><br><span class="line">                (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先进行Singleton的初始化，其中如果bean是FactoryBean类型(注意，只定义了factory-method属性的普通bean并不是FactoryBean)，并且还是SmartFactoryBean类型，那么需要判断是否需要eagerInit(isEagerInit是此接口定义的方法)。</p><h1 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h1><p>这里便是bean初始化的核心逻辑。源码比较复杂，分开说。以getBean(String name)为例。AbstractBeanFactory.getBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数表示bean的Class类型，第三个表示创建bean需要的参数，最后一个表示不需要进行类型检查。</p><h2 id="beanName转化"><a href="#beanName转化" class="headerlink" title="beanName转化"></a>beanName转化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br></pre></td></tr></table></figure><p>这里是将FactoryBean的前缀去掉以及将别名转为真实的名字。</p><h2 id="手动注册bean检测"><a href="#手动注册bean检测" class="headerlink" title="手动注册bean检测"></a>手动注册bean检测</h2><p>前面注册环境一节说过，Spring其实手动注册了一些单例bean。这一步就是检测是不是这些bean。如果是，那么再检测是不是工厂bean，如果是返回其工厂方法返回的实例，如果不是返回bean本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查父容器"><a href="#检查父容器" class="headerlink" title="检查父容器"></a>检查父容器</h2><p>如果父容器存在并且存在此bean定义，那么交由其父容器初始化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">    <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">    <span class="comment">//此方法其实是做了前面beanName转化的逆操作，因为父容器同样会进行转化操作</span></span><br><span class="line">    String nameToLookup = originalBeanName(name);</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖初始化"><a href="#依赖初始化" class="headerlink" title="依赖初始化"></a>依赖初始化</h2><p>bean可以由depends-on属性配置依赖的bean。Spring会首先初始化依赖的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">         <span class="comment">//检测是否存在循环依赖</span></span><br><span class="line">        <span class="keyword">if</span> (isDependent(beanName, dependsOnBean)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dependsOnBean + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">        getBean(dependsOnBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerDependentBean进行了依赖关系的注册，这么做的原因是Spring在即进行bean销毁的时候会首先销毁被依赖的bean。依赖关系的保存是通过一个ConcurrentHashMap&lt;String, Set<string>&gt;完成的，key是bean的真实名字。</string></p><h2 id="Singleton初始化"><a href="#Singleton初始化" class="headerlink" title="Singleton初始化"></a>Singleton初始化</h2><p>虽然这里大纲是Singleton初始化，但是getBean方法本身是包括所有scope的初始化，在这里一次说明了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getSingleton方法"><a href="#getSingleton方法" class="headerlink" title="getSingleton方法"></a>getSingleton方法</h3><h4 id="是否存在"><a href="#是否存在" class="headerlink" title="是否存在"></a>是否存在</h4><p>首先会检测是否已经存在，如果存在，直接返回:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的单例bean都保存在这样的数据结构中: <code>ConcurrentHashMap&lt;String, Object&gt;</code>。</p><h4 id="bean创建"><a href="#bean创建" class="headerlink" title="bean创建"></a>bean创建</h4><p>源码位于AbstractAutowireCapableBeanFactory.createBean，主要分为几个部分:</p><h5 id="lookup-method检测"><a href="#lookup-method检测" class="headerlink" title="lookup-method检测"></a>lookup-method检测</h5><p>此部分用于检测lookup-method标签配置的方法是否存在:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br></pre></td></tr></table></figure><p>prepareMethodOverrides:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">    <span class="comment">// Check that lookup methods exists.</span></span><br><span class="line">    MethodOverrides methodOverrides = getMethodOverrides();</span><br><span class="line">    <span class="keyword">if</span> (!methodOverrides.isEmpty()) &#123;</span><br><span class="line">        Set&lt;MethodOverride&gt; overrides = methodOverrides.getOverrides();</span><br><span class="line">        <span class="keyword">synchronized</span> (overrides) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MethodOverride mo : overrides) &#123;</span><br><span class="line">                prepareMethodOverride(mo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepareMethodOverride:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareMethodOverride</span><span class="params">(MethodOverride mo)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(</span><br><span class="line">                <span class="string">"Invalid method override: no method with name '"</span> + mo.getMethodName() +</span><br><span class="line">                <span class="string">"' on class ["</span> + getBeanClassName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Mark override as not overloaded, to avoid the overhead of arg type checking.</span></span><br><span class="line">        mo.setOverloaded(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="InstantiationAwareBeanPostProcessor触发"><a href="#InstantiationAwareBeanPostProcessor触发" class="headerlink" title="InstantiationAwareBeanPostProcessor触发"></a>InstantiationAwareBeanPostProcessor触发</h5><p>在这里触发的是其postProcessBeforeInitialization和postProcessAfterInstantiation方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br></pre></td></tr></table></figure><p>继续:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，<strong>如果InstantiationAwareBeanPostProcessor返回的不是空，那么将不会继续执行剩下的Spring初始化流程，此接口用于初始化自定义的bean，主要是在Spring内部使用</strong>。</p><h5 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h5><p>同样分为几部分。</p><h6 id="创建-createBeanInstance"><a href="#创建-createBeanInstance" class="headerlink" title="创建(createBeanInstance)"></a>创建(createBeanInstance)</h6><p>关键代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBeanInstance的创建过程又分为以下几种情况:</p><ul><li><p>工厂bean:</p><p>调用instantiateUsingFactoryMethod方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, RootBeanDefinition mbd, Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，此处的工厂bean指的是配置了factory-bean/factory-method属性的bean，不是实现了FacrotyBean接口的bean。如果没有配置factory-bean属性，那么factory-method指向的方法必须是静态的。此方法主要做了这么几件事:</p><ul><li><p>初始化一个BeanWrapperImpl对象。</p></li><li><p>根据设置的参数列表使用反射的方法寻找相应的方法对象。</p></li><li><p>InstantiationStrategy:</p><p>bean的初始化在此处又抽成了策略模式，类图:</p><p><img src="/uploads/spring/images/InstantiationStrategy.jpg" alt="InstantiationStrategy类图"></p><p>instantiateUsingFactoryMethod部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beanInstance = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">    mbd, beanName, <span class="keyword">this</span>.beanFactory, factoryBean, factoryMethodToUse, argsToUse);</span><br></pre></td></tr></table></figure><p>getInstantiationStrategy返回的是CglibSubclassingInstantiationStrategy对象。此处instantiate实现也很简单，就是调用工厂方法的Method对象反射调用其invoke即可得到对象，SimpleInstantiationStrategy.</p><p>instantiate核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object factoryBean, <span class="keyword">final</span> Method factoryMethod, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factoryMethod.invoke(factoryBean, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>构造器自动装配</p><p>createBeanInstance部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Need to determine the constructor...</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">  mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">    <span class="comment">//配置了&lt;constructor-arg&gt;子元素</span></span><br><span class="line">  mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">  <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>determineConstructorsFromBeanPostProcessors源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">  <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">              SmartInstantiationAwareBeanPostProcessor ibp = </span><br><span class="line">                  (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">              Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">              <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> ctors;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见是由SmartInstantiationAwareBeanPostProcessor决定的，默认是没有配置这种东西的。</p><p>之后就是判断bean的自动装配模式，可以通过如下方式配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span> <span class="attr">primary</span>=<span class="string">"true"</span> <span class="attr">autowire</span>=<span class="string">"default"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>autowire共有以下几种选项:</p><ul><li>no: 默认的，不进行自动装配。在这种情况下，只能通过ref方式引用其它bean。</li><li>byName: 根据bean里面属性的名字在BeanFactory中进行查找并装配。</li><li>byType: 按类型。</li><li>constructor: 以byType的方式查找bean的构造参数列表。</li><li>default: 由父bean决定。</li></ul><p>参考: <a href="http://www.cnblogs.com/ViviChan/p/4981539.html" target="_blank" rel="noopener">Spring - bean的autowire属性(自动装配)</a></p><p>autowireConstructor调用的是ConstructorResolver.autowireConstructor，此方法主要做了两件事:</p><ul><li><p>得到合适的构造器对象。</p></li><li><p>根据构造器参数的类型去BeanFactory查找相应的bean:</p><p>入口方法在ConstructorResolver.resolveAutowiredArgument:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveAutowiredArgument</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        MethodParameter param, String beanName, Set&lt;String&gt; autowiredBeanNames, </span></span></span><br><span class="line"><span class="function"><span class="params">        TypeConverter typeConverter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.resolveDependency(</span><br><span class="line">            <span class="keyword">new</span> DependencyDescriptor(param, <span class="keyword">true</span>), beanName, </span><br><span class="line">            autowiredBeanNames, typeConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终调用的还是CglibSubclassingInstantiationStrategy.instantiate方法，关键源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">           <span class="comment">//反射调用</span></span><br><span class="line">      <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果配置了lookup-method标签，<strong>得到的实际上是用Cglib生成的目标类的代理子类</strong>。</p><p>CglibSubclassingInstantiationStrategy.instantiateWithMethodInjection:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Must generate CGLIB subclass...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CglibSubclassCreator(bd, owner).instantiate(ctor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认构造器</p><p>一行代码，很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br></pre></td></tr></table></figure></li></ul><h6 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h6><p>触发源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">        mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口也是Spring内部使用的，不管它了。</p><h6 id="属性解析"><a href="#属性解析" class="headerlink" title="属性解析"></a>属性解析</h6><p>入口方法: AbstractAutowireCapableBeanFactory.populateBean，它的作用是: 根据autowire类型进行autowire by name，by type 或者是直接进行设置，简略后的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有&lt;property&gt;的值</span></span><br><span class="line">    PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设值</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autowireByName源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回所有引用(ref="XXX")的bean名称</span></span><br><span class="line">    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">             <span class="comment">//从BeanFactory获取</span></span><br><span class="line">            Object bean = getBean(propertyName);</span><br><span class="line">            pvs.add(propertyName, bean);</span><br><span class="line">            registerDependentBean(propertyName, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autowireByType也是同样的套路，所以可以得出结论: <strong>autowireByName和autowireByType方法只是先获取到引用的bean，真正的设值是在applyPropertyValues中进行的。</strong></p><h6 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h6><p>Spring判断一个属性可不可以被设置(存不存在)是通过java bean的内省操作来完成的，也就是说，属性可以被设置的条件是<strong>此属性拥有public的setter方法，并且注入时的属性名应该是setter的名字</strong>。</p><h6 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h6><p>此处的初始化指的是bean已经构造完成，执行诸如调用其init方法的操作。相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initializeBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的操作步骤一目了然。</p><ul><li><p>Aware方法触发:</p><p>我们的bean有可能实现了一些XXXAware接口，此处就是负责调用它们:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">          ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">          ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">          ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BeanPostProcessor触发，没什么好说的</p></li><li><p>调用init方法:</p><p>在XML配置中，bean可以有一个init-method属性来指定初始化时调用的方法。从原理来说，其实就是一个反射调用。不过注意这里有一个InitializingBean的概念。</p><p>此接口只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>如果我们的bean实现了此接口，那么此方法会首先被调用。此接口的意义在于: 当此bean的所有属性都被设置(注入)后，给bean一个利用现有属性重新组织或是检查属性的机会。感觉和init方法有些冲突，不过此接口在Spring被广泛使用。</p></li></ul><h3 id="getObjectForBeanInstance"><a href="#getObjectForBeanInstance" class="headerlink" title="getObjectForBeanInstance"></a>getObjectForBeanInstance</h3><p>位于AbstractBeanFactory，此方法的目的在于如果bean是FactoryBean，那么返回其工厂方法创建的bean，而不是自身。</p><h2 id="Prototype初始化"><a href="#Prototype初始化" class="headerlink" title="Prototype初始化"></a>Prototype初始化</h2><p>AbstractBeanFactory.doGetBean相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">    <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">    Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="beforePrototypeCreation"><a href="#beforePrototypeCreation" class="headerlink" title="beforePrototypeCreation"></a>beforePrototypeCreation</h3><p>此方法用于确保在同一时刻只能有一个此bean在初始化。</p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>和单例的是一样的，不在赘述。</p><h3 id="afterPrototypeCreation"><a href="#afterPrototypeCreation" class="headerlink" title="afterPrototypeCreation"></a>afterPrototypeCreation</h3><p>和beforePrototypeCreation对应的，你懂的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看出，初始化其实和单例是一样的，只不过单例多了一个是否已经存在的检查。</p><h2 id="其它Scope初始化"><a href="#其它Scope初始化" class="headerlink" title="其它Scope初始化"></a>其它Scope初始化</h2><p>其它就指的是request、session。此部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    String scopeName = mbd.getScope();</span><br><span class="line">    <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">    <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scopes是一个LinkedHashMap&lt;String, Scope&gt;，可以调用 ConfigurableBeanFactory定义的registerScope方法注册其值。</p><p>Scope接口继承体系:</p><p><img src="/upload/2019/1/Scope20190216155031766.jpg" alt="Scope继承体系"></p><p>根据socpe.get的注释，此方法如果找到了叫做beanName的bean，那么返回，如果没有，将调用ObjectFactory创建之。Scope的实现参考类图。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h1&gt;&lt;p&gt;本部分从最基本的Spring开始。配置文件:&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;base.SimpleBean&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;启动代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ClassPathXmlApplicationContext context = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span class=&quot;string&quot;&gt;&quot;config.xml&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SimpleBean bean = context.getBean(SimpleBean.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bean.send();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    context.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="spring" scheme="https://duia.github.io/categories/JAVA/spring/"/>
    
      <category term="源码阅读" scheme="https://duia.github.io/categories/JAVA/spring/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="源码阅读" scheme="https://duia.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="spring" scheme="https://duia.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之策略模式</title>
    <link href="https://duia.github.io/2016/11/13/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://duia.github.io/2016/11/13/Java设计模式之策略模式/</id>
    <published>2016-11-13T13:36:00.000Z</published>
    <updated>2019-05-11T15:00:00.127Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/2019/1/151298116520190216151017418.jpg" alt="image"></p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在软件开发中常常遇到这种情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。</p><p>这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。</p><p>比如定义一系列的算法,把每一个算法封装起来,并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式。</p><h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><p>许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。</p><p>当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用。</p><p>一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以动态的改变对象的行为<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li><li>策略模式将造成产生很多策略类</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。</li><li>抽象策略类(Strategy):定义所有支持的算法的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法。</li><li>具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在我现在接触的一个项目中，有这样一个需求：</p><blockquote><p>考试抓卷功能：根据请求的参数的不同去抓取对应的一份试卷。</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 试卷类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//各种属性略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成试卷的策略接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function">Paper <span class="title">makePaper</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 环境类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(IStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Paper <span class="title">doMakePaper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.makePaper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略一：获取并组合真题试卷</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy1</span> <span class="keyword">implements</span> <span class="title">IStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Paper <span class="title">makePaper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Paper paper = <span class="keyword">new</span> Paper();</span><br><span class="line">        System.out.println(<span class="string">"获取相关数据：真题试卷信息、题型、试题等数据。"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数据整理：整理数据，生成符合客户端需要的真题试卷。"</span>);</span><br><span class="line">        <span class="keyword">return</span> paper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略二：试题30个试题进行随机练习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy2</span> <span class="keyword">implements</span> <span class="title">IStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Paper <span class="title">makePaper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Paper paper = <span class="keyword">new</span> Paper();</span><br><span class="line">        System.out.println(<span class="string">"获取相关数据：随机30个试题"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数据整理：整理试题，生成符合客户端要求的练习试卷。"</span>);</span><br><span class="line">        <span class="keyword">return</span> paper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述: 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 王鹏程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@E</span>-mail: wpcfree@qq.com <span class="doctag">@QQ</span>: 376205421</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span>: http://www.duia.online</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context;</span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> Strategy1());<span class="comment">//利用策略一生成试卷</span></span><br><span class="line">        Paper paper = context.doMakePaper();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> Strategy2());<span class="comment">//利用策略二生成试卷</span></span><br><span class="line">        paper = context.doMakePaper();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：客户端处出现的硬编码选择策略可以结合工厂模式进行更好的优化处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/2019/1/151298116520190216151017418.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/categories/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>jquery.datatables.js实现java服务端</title>
    <link href="https://duia.github.io/2016/11/08/jquery.datatables.js%E5%AE%9E%E7%8E%B0java%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://duia.github.io/2016/11/08/jquery.datatables.js实现java服务端/</id>
    <published>2016-11-08T14:13:00.000Z</published>
    <updated>2019-04-07T00:00:00.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Datatable-js整合使用"><a href="#Datatable-js整合使用" class="headerlink" title="Datatable.js整合使用"></a>Datatable.js整合使用</h2><h3 id="开启服务器模式支持"><a href="#开启服务器模式支持" class="headerlink" title="开启服务器模式支持"></a>开启服务器模式支持</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#example'</span>).DataTable( &#123;</span><br><span class="line">    serverSide: <span class="literal">true</span>,</span><br><span class="line">    ajax: &#123;</span><br><span class="line">        url: <span class="string">'/data-source'</span>,</span><br><span class="line">        type: <span class="string">'POST'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>默认向后台发送的请求格式是二维数组格式如<code>columns[0][search][value]=...</code><br>可以如下代码修改发送请求的格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ajax: &#123;</span><br><span class="line">    url: <span class="string">"/some/url.json"</span>),</span><br><span class="line">    type: <span class="string">"POST"</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        data.condition = &#123;<span class="comment">//添加额外的搜索条件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    dataType: <span class="string">"json"</span>,</span><br><span class="line">    processData: <span class="literal">false</span>,<span class="comment">//processData的默认值是true。用于对data参数进行序列化处理</span></span><br><span class="line">    contentType: <span class="string">'application/json;charset=UTF-8'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h3 id="服务端代码封装如下："><a href="#服务端代码封装如下：" class="headerlink" title="服务端代码封装如下："></a>服务端代码封装如下：</h3><p>DataTablesRequest.java：用于参数的接收，该类中涉及到的Search、Order、Columns自行根据datatables的请求参数进行封装。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTablesRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer draw;</span><br><span class="line">    <span class="keyword">private</span> Integer start;</span><br><span class="line">    <span class="keyword">private</span> Integer length;</span><br><span class="line">    <span class="keyword">private</span> Search search;</span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"order"</span>)<span class="comment">//需要jackson的支持</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Column&gt; columns;<span class="comment">//需要排序的话添加，不需要可以删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件，这个参数和前端添加额外的搜索添加的参数名统一</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; condition = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//特殊setter。用于排序，在查询数据前先调用来设置排序字段，我这里只设置了单值排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        condition.put(<span class="string">"orderColumn"</span>, <span class="keyword">this</span>.columns.get(<span class="keyword">this</span>.orders.get(<span class="number">0</span>).getColumn()).getData());</span><br><span class="line">        condition.put(<span class="string">"orderDir"</span>, <span class="keyword">this</span>.orders.get(<span class="number">0</span>).getDir());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其它getters sestters略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DataTablesResponse.java：返回到前台数据的封装，利用泛型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTablesResponse</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必要。出于安全的考虑，强烈要求把这个转换为整形</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer draw;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必要。即没有过滤的记录数（数据库里总共记录数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer recordsTotal;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必要。过滤后的记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer recordsFiltered;</span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line">    <span class="comment">//具体查询出的数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; data = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getter、setter省略</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上将接收参数和返回数据的实体分开封装，也可以将以上两个类合并。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>XxxxxServiceImpl.java：举个使用的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxServiceImpl</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> XxxDao xxxDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页获取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> query</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataTablesResponse&lt;Xxx&gt; <span class="title">searchPage</span><span class="params">(DataTablesRequest query)</span> </span>&#123;</span><br><span class="line">    query.setOrder();<span class="comment">//设置排序</span></span><br><span class="line">    DataTablesResponse&lt;Xxx&gt; dtr = <span class="keyword">new</span> DataTablesResponse&lt;Xxx&gt;();</span><br><span class="line">    dtr.setDraw(query.getDraw());</span><br><span class="line">    dtr.setData(xxxDao.searchXxx(query));<span class="comment">//根据条件去数据库查询数据</span></span><br><span class="line">    dtr.setRecordsFiltered(xxxDao.countXxx(query));<span class="comment">//获取符合条件的数据条数</span></span><br><span class="line">    query.setCondition(<span class="keyword">null</span>);<span class="comment">//清空查询条件</span></span><br><span class="line">    dtr.setRecordsTotal(xxxDao.countXxx(query));<span class="comment">//查询数据总个数</span></span><br><span class="line">    <span class="keyword">return</span> dtr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dao层查询数据的具体方法靠大家自己实现了。</p><h2 id="使用中遇到的问题"><a href="#使用中遇到的问题" class="headerlink" title="使用中遇到的问题"></a>使用中遇到的问题</h2><h3 id="bootstrap样式分页显示首页尾页"><a href="#bootstrap样式分页显示首页尾页" class="headerlink" title="bootstrap样式分页显示首页尾页"></a>bootstrap样式分页显示首页尾页</h3><p>配置<code>pagingType</code>属性，分页按钮的显示方式，其属性值有：</p><ul><li>numbers - Page number buttons only (1.10.8)</li><li>simple - ‘Previous’ and ‘Next’ buttons only</li><li>simple_numbers - ‘Previous’ and ‘Next’ buttons, plus page numbers</li><li>full - ‘First’, ‘Previous’, ‘Next’ and ‘Last’ buttons</li><li>full_numbers - ‘First’, ‘Previous’, ‘Next’ and ‘Last’ buttons, plus page numbers</li></ul><h3 id="保留分页信息"><a href="#保留分页信息" class="headerlink" title="保留分页信息"></a>保留分页信息</h3><p>添加、修改或删除数据后需要刷新列表，如果需要保留分页信息，datatables提供了相应的api：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table.draw(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">table.ajax.reload(<span class="literal">null</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><p>说明：使用jquery.datatables.js版本 1.10.12</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Datatable-js整合使用&quot;&gt;&lt;a href=&quot;#Datatable-js整合使用&quot; class=&quot;headerlink&quot; title=&quot;Datatable.js整合使用&quot;&gt;&lt;/a&gt;Datatable.js整合使用&lt;/h2&gt;&lt;h3 id=&quot;开启服务器模式支持&quot;&gt;&lt;a href=&quot;#开启服务器模式支持&quot; class=&quot;headerlink&quot; title=&quot;开启服务器模式支持&quot;&gt;&lt;/a&gt;开启服务器模式支持&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&#39;#example&#39;&lt;/span&gt;).DataTable( &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    serverSide: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ajax: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        url: &lt;span class=&quot;string&quot;&gt;&#39;/data-source&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        type: &lt;span class=&quot;string&quot;&gt;&#39;POST&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="js" scheme="https://duia.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://duia.github.io/tags/js/"/>
    
      <category term="jquery" scheme="https://duia.github.io/tags/jquery/"/>
    
      <category term="dataTables" scheme="https://duia.github.io/tags/dataTables/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式之代理模式</title>
    <link href="https://duia.github.io/2016/11/02/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://duia.github.io/2016/11/02/java设计模式之代理模式/</id>
    <published>2016-11-02T07:16:00.000Z</published>
    <updated>2019-04-03T17:00:00.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h2><p>代理（Proxy）是一个使用率非常高的设计模式。为其他对象提供一种代理以控制对这个对象的访问。</p><h2 id="代理模式的好处"><a href="#代理模式的好处" class="headerlink" title="代理模式的好处"></a>代理模式的好处</h2><ul><li>职责清晰：真实的对象做好自己的本职工作即可，其他扩展性和附带性的工作交给代理处理。</li><li>高扩展性：由于真实对象和代理对象具有相同的接口（抽象类），所以在不修改真实对象的情况下，我们可以任何扩展代理类，对真实对象的功能进行扩展。从而达到了“对修改关闭，对扩展开放”，保证了系统的稳定性。</li></ul><p>貌似还有别的好处或别的说法，用用自己体会一下才是最好的。<br><a id="more"></a></p><h2 id="代理模式怎么用"><a href="#代理模式怎么用" class="headerlink" title="代理模式怎么用"></a>代理模式怎么用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 抽象对象角色：声明了目标对象和代理对象的共同接口，</span></span><br><span class="line"><span class="comment">* 这样一来在任何可以使用目标对象的地方都可以使用代理对象。</span></span><br><span class="line"><span class="comment">* 该类也可以是接口。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 目标对象角色：定义了代理对象所代表的目标对象。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">extends</span> <span class="title">AbstractObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一些操作</span></span><br><span class="line">        System.out.println(<span class="string">"一些操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 代理对象角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；</span></span><br><span class="line"><span class="comment">* 代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。</span></span><br><span class="line"><span class="comment">* 代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，</span></span><br><span class="line"><span class="comment">* 而不是单纯地将调用传递给目标对象。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">extends</span> <span class="title">AbstractObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">AbstractObject object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">object = <span class="keyword">new</span> RealObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyObject</span><span class="params">(AbstractObject object)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.object = object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用目标对象之前可以做相关操作</span></span><br><span class="line">        System.out.println(<span class="string">"before"</span>);        </span><br><span class="line">        object.operation();        </span><br><span class="line">        <span class="comment">//调用目标对象之后可以做相关操作</span></span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 客户端调用</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">AbstractObject obj = <span class="keyword">new</span> ProxyObject();</span><br><span class="line">        obj.operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>以上代码样例的代理模式是一种最简单的代理情况，被称之为静态代理。静态代理有一定的具局限性，也有它自己的不足。</p><p>通过观察上边的代码，可以发现，静态代理必须要求被代理对象实现某个接口或继承某个抽象类，同时，如果想扩展接口的功能，必须维护真实对象和代理对象，等。</p><h3 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h3><p>这里的普通代理意思为我们只能访问代理角色，为不能直接访问真实角色，比较简单，看下面代码示例：</p><p>（代码基本与上边示例相同，以下只列不同之处）</p><p>为真实对象添加如下代码，限制构造函数，从而限制了我们对真实对象的直接访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">extends</span> <span class="title">AbstractObject</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealObject</span><span class="params">(AbstractObject object, String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不能创建真实对象"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相应的修改代理对象的构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">extends</span> <span class="title">AbstractObject</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyObject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = <span class="keyword">new</span> RealObject(<span class="keyword">this</span>, name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用如下，我们无法在直接使用真实对象，使用代理对象时我们也无需关注它为谁做代理了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//    AbstractObject obj1 = new RealObject(new RealObject(), "wpc");</span></span><br><span class="line">    <span class="comment">//    obj1.operation();</span></span><br><span class="line">        AbstractObject obj2 = <span class="keyword">new</span> ProxyObject(<span class="string">"wpc"</span>);</span><br><span class="line">        obj2.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="强制代理"><a href="#强制代理" class="headerlink" title="强制代理"></a>强制代理</h3><p>所谓强制代理就是说我们必须通过真实对象来找到它的代理来进行访问，即真实对象指定了自己的代理对象。</p><p>我们new出来的代理以及真实对象都不能被访问成功。</p><p>这时候接口或抽象类需要添加一个获取代理的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractObject <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相应的真实对象和代理对象要实现该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">extends</span> <span class="title">AbstractObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//我的代理</span></span><br><span class="line">    <span class="keyword">private</span> AbstractObject proxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealObject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractObject <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = <span class="keyword">new</span> ProxyObject(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMyProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.proxy == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMyProxy()) &#123;</span><br><span class="line">            <span class="comment">//一些操作</span></span><br><span class="line">            System.out.println(<span class="string">"一些操作"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"请使用自己的代理"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">extends</span> <span class="title">AbstractObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">AbstractObject object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyObject</span><span class="params">(AbstractObject object)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractObject <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用目标对象之前可以做相关操作</span></span><br><span class="line">        System.out.println(<span class="string">"before"</span>);        </span><br><span class="line">        object.operation();        </span><br><span class="line">        <span class="comment">//调用目标对象之后可以做相关操作</span></span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AbstractObject obj = <span class="keyword">new</span> RealObject(<span class="string">"wpc"</span>);</span><br><span class="line"><span class="comment">//        obj.operation();//直接访问是不可以的</span></span><br><span class="line"><span class="comment">//        AbstractObject proxy = new ProxyObject(obj);//new新代理也不可以</span></span><br><span class="line">        AbstractObject proxy = obj.getProxy();<span class="comment">//必须获取自己的代理</span></span><br><span class="line">        proxy.operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理属于压轴出场，这个属于重点。主要就是因为我们在实际的开发过程中接触的会比较多，或许你用了但却不知道。我们都知道Spring主要有两大思想，一个是IoC，另一个就是AOP，我们不但要知道怎么通过AOP来满足的我们的功能，我们更需要学习的是其底层是怎么样的一个原理，而AOP的原理就是java的动态代理机制。</p><p>在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>直接上代码，通过举例子是学习的最好方式，其中涉及到的重点内容我都通过在类和方法上进行注解，大家可以学习：</p><p>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//　这个就是我们要代理的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    构造方法，给我们要代理的真实对象赋初值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:   指代我们所代理的那个真实对象</span></span><br><span class="line"><span class="comment">     * method:  指代的是我们所要调用真实对象的某个方法的Method对象</span></span><br><span class="line"><span class="comment">     * args:    指代的是调用真实对象某个方法时接受的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//在代理真实对象前我们可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"代理前..."</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Method:"</span> + method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在代理真实对象后我们也可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"代理后..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们要代理的真实对象</span></span><br><span class="line">        Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> DynamicProxy(realSubject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * loader:　　一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载</span></span><br><span class="line"><span class="comment">         * interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</span></span><br><span class="line"><span class="comment">         * handler:　　一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</span></span><br><span class="line"><span class="comment">         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象</span></span><br><span class="line"><span class="comment">         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</span></span><br><span class="line"><span class="comment">         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回的对象既不是Subject类型的对象，也不是InvocationHandler的对象</span></span><br><span class="line">        <span class="comment">//而是$Proxy0类似的代理对象</span></span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line">        subject.rent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是我所理解的动态代理机制，这个知识点非常非常的重要，包括我们Spring的AOP其就是通过动态代理的机制实现的，所以我们必须要好好的理解动态代理的机制。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>动态代理更有利于程序的扩展；不需要更改原有的代码。 （白话：静态代理的代理对象必须和被代理对象实现相同的接口，如果要调整接口，相应的需要调整真实对象和代理对象，而动态代理没有实现接口类，接口和真实对象调整是不需要进行维护代理对象的。）</li><li>能在运行过程中根据接口的类型动态的调用实现该接口的类 。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是代理模式&quot;&gt;&lt;a href=&quot;#什么是代理模式&quot; class=&quot;headerlink&quot; title=&quot;什么是代理模式&quot;&gt;&lt;/a&gt;什么是代理模式&lt;/h2&gt;&lt;p&gt;代理（Proxy）是一个使用率非常高的设计模式。为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;h2 id=&quot;代理模式的好处&quot;&gt;&lt;a href=&quot;#代理模式的好处&quot; class=&quot;headerlink&quot; title=&quot;代理模式的好处&quot;&gt;&lt;/a&gt;代理模式的好处&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;职责清晰：真实的对象做好自己的本职工作即可，其他扩展性和附带性的工作交给代理处理。&lt;/li&gt;
&lt;li&gt;高扩展性：由于真实对象和代理对象具有相同的接口（抽象类），所以在不修改真实对象的情况下，我们可以任何扩展代理类，对真实对象的功能进行扩展。从而达到了“对修改关闭，对扩展开放”，保证了系统的稳定性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;貌似还有别的好处或别的说法，用用自己体会一下才是最好的。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/categories/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式之工厂模式</title>
    <link href="https://duia.github.io/2016/10/30/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://duia.github.io/2016/10/30/java设计模式之工厂模式/</id>
    <published>2016-10-30T09:22:00.000Z</published>
    <updated>2019-04-06T19:00:00.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是工厂模式"><a href="#什么是工厂模式" class="headerlink" title="什么是工厂模式"></a>什么是工厂模式</h2><p>工厂模式在《Java与模式》中分为三类：</p><ul><li>简单工厂模式（Simple Factory）：不利于产生系列产品；</li><li>工厂方法模式（Factory Method）：又称为多形性工厂；</li><li>抽象工厂模式（Abstract Factory）：又称为工具箱，产生产品族，但不利于产生新的产品</li></ul><a id="more"></a><p>这三种模式从上到下逐步抽象，并且更具一般性。GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。（以上内容摘抄）</p><h2 id="工厂模式有什么好处"><a href="#工厂模式有什么好处" class="headerlink" title="工厂模式有什么好处"></a>工厂模式有什么好处</h2><p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p>（我喜欢用通俗易懂的话语描述）：如果在我们的程序中有很多地方需要创建对象A，并且每次创建A后都会有必要的设置，如果不采用工厂模式的话就会在很多地方出现类似于如下的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.set...(...);</span><br><span class="line">a.set...(...);</span><br><span class="line">...<span class="comment">//其它可能更多的设置</span></span><br></pre></td></tr></table></figure></p><p>如果采用工厂模式，我们可以将以上代码封装到一个方法中，每次需要创建A对象时，调用该方法即可。这就是工厂方法的理解。</p><p>所以，这样就带来以下好处：</p><ul><li>代码的共用性，封装成方法可以减少代码量</li><li>当以后发现需要修改A对象创建的代码时，只需修改一处，省时省力，很好的体现了编程中解耦的思想。</li></ul><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>其定义为：定义一个用于创建对象的接口，让子类决定实例哪一个类。工厂方法使一个类的实例化延迟到了其子类中。</p><p>通用类图如下：</p><p><img src="/upload/2019/1/factory20190216151203855.png" alt="image"></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>工厂模式的产品接口<code>IProduct.java</code>，也可以是抽象类，提供产品的共性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>产品A<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"产品A运行..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>产品类可以有多个，类似于产品A，其他就不写了。下边所涉及的所有工厂类都为这个产品接口及具体的产品所服务，所以就不多强调产品接口和产品实现类了。</p><p>工厂类接口<code>IFactory.java</code>的定义有多种，每种也都有自己的优势和不足，以下举出两种情况，大家可以分别感受一下：</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>IFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProduct <span class="title">product</span><span class="params">(String type)</span></span>;<span class="comment">//参数为字符串</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProduct <span class="title">produce</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"a"</span>.equals(type))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"b"</span>.equals(type))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Test.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        IProduct pA = factory.produce(<span class="string">"a"</span>);</span><br><span class="line">        pA.run();<span class="comment">//产品A运行...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据参数字符串来创建所需要的对象，由于我们编程有一原则是面向接口的，利用该方法的前提必须知道每种对象对应的字符串，并且当传进去的字符串参数没有时则会创建对象失败。如果每次需要新增一个对象，需要相应的修改工厂类。</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>这种方式和第一种类似，只不过是将方法的参数换成了<code>Class</code>，这样实现的好处正好弥补第一种方式的不足。</p><p>IFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jdk1.5开始的新特性泛型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends IProduct&gt; <span class="function">T <span class="title">product</span><span class="params">(Class&lt;T&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Factory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorys</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends IProduct&gt; <span class="function">T <span class="title">product</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    T t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            t = (T) Class.forName(c.getName()).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Test.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFactory f = <span class="keyword">new</span> Factorys();</span><br><span class="line">        IProduct pA = f.product(ProductA.class);</span><br><span class="line">        pA.run();<span class="comment">//产品A运行...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实还可以构建无参数的工厂方法，具体我也就不列举了，大家可以自行扩展一下，我上边所列举的也不是标准，实现形式可以有很多，勤于思考，不要把编程看成简单的copy。</p><h2 id="工厂方法模式的扩展"><a href="#工厂方法模式的扩展" class="headerlink" title="工厂方法模式的扩展"></a>工厂方法模式的扩展</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>大家仔细看了前边的代码，会发现一个看起来多余的地方，如上实现工厂方法模式的方式，其实没必要出现那个工厂接口，因为只有一个工厂类，所以可以省去工厂接口，工厂类实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorys</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends IProduct&gt; <span class="function">T <span class="title">product</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    T t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            t = (T) Class.forName(c.getName()).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意方法多加了个<code>static</code>修饰，这样还可以免去每次创建工厂类的过程。</p><h3 id="工厂库房"><a href="#工厂库房" class="headerlink" title="工厂库房"></a>工厂库房</h3><p>在单例模式中，每次获取实例时有个判断是否已实例化的过程，利用这个思想我们可以为“工厂”加个“库房”，生产出来的产品保存起来，下次再用是可以去“库房”里获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorys</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IProduct&gt; map = <span class="keyword">new</span> HashMap&lt;String, IProduct&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> &lt;T extends IProduct&gt; <span class="function">T <span class="title">product</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(c.getName())) &#123;</span><br><span class="line"><span class="keyword">return</span> (T) map.get(c.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"创建产品..."</span>);</span><br><span class="line">t = (T) Class.forName(c.getName()).newInstance();</span><br><span class="line">map.put(c.getName(), t);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Test.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">IProduct pA = Factorys.product(ProductA.class);</span><br><span class="line">pA.run();</span><br><span class="line">IProduct pB = Factorys.product(ProductA.class);</span><br><span class="line">pB.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二次生产产品的时候不会进行创建，而是获取。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>在前期看工厂模式的时候，步入了一个误区，我发现这也是好多博客上出现的问题，他们简单将上边我所进行扩展的没有抽象接口的那种方式认为是工厂方法模式，而将只要出现了抽象工厂接口的模式认为是抽象工厂模式，而实际却并非这样。</p><p>抽象工厂模式暂时也没用过，以下全为个人理解总结，如有错误，大家提出来，咱们共同进步：</p><p>仔细回味一下工厂方法模式，一个工厂生产同一类型的产品，即继承或实现了同一抽象类或接口的实现类。而用工厂方法模式生产该类的目的就是要将一部分对该类的设置封装到工厂方法中，所以即使生产的不是同一个类，同一类型的类，也只能进行相同的设置，这样也就产生了这个局限性，就是必须为用这个工厂生产的类经过一个相同的“加工过程”，而你遇上对所生产的类有不同的设置是不可以的，这个时候就需要用到抽象工厂模式了。</p><p>抽象工厂的概念：为创建一组相关或相互依赖的对象提供一个接口，而无须指定它们的具体类。</p><p>这个概念也是够抽象的，举例说明：</p><p>一组相关或相互依赖的对象抽象类（接口）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProductA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProductB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以有N多个这样的抽象产品类或接口，每种抽象类或接口下可能有多个具体的产品类：</p><p>A类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">implements</span> <span class="title">IProductA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">implements</span> <span class="title">IProductA</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…</p><p>B类也一样。</p><p>IFactory.java，由于有多组不同类型的产品，所以工厂需要有多个生产方法来生产不同组的产品系列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//A类产品生产线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProductA <span class="title">productA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//B类产品生产线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProducB <span class="title">productB</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每组类型产品生产的具体过程不一样：<br>Factory1.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory1</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProductA <span class="title">productA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProductB <span class="title">productB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Factory2.java类似<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory2</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProductA <span class="title">productA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProductB <span class="title">productB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Test.java，每次生产产品时无需指定具体的类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFactory factory1 = <span class="keyword">new</span> Factory1();</span><br><span class="line">        IFactory factory2 = <span class="keyword">new</span> Factory2();</span><br><span class="line">        IProductA pA1 = factory1.produceA();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后总结，需要仔细想一想，理解清楚，抽象工厂模式如同咱们中学学习的象限，从两个维度去生产产品，回归到概念，确定了要生产的产品种类和使用那个工厂，也就相当于确定了X轴和Y轴，自然也就确定了那一点，即具体的产品，即概念中所说的不需要指定具体的类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是工厂模式&quot;&gt;&lt;a href=&quot;#什么是工厂模式&quot; class=&quot;headerlink&quot; title=&quot;什么是工厂模式&quot;&gt;&lt;/a&gt;什么是工厂模式&lt;/h2&gt;&lt;p&gt;工厂模式在《Java与模式》中分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单工厂模式（Simple Factory）：不利于产生系列产品；&lt;/li&gt;
&lt;li&gt;工厂方法模式（Factory Method）：又称为多形性工厂；&lt;/li&gt;
&lt;li&gt;抽象工厂模式（Abstract Factory）：又称为工具箱，产生产品族，但不利于产生新的产品&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/categories/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式之单例模式</title>
    <link href="https://duia.github.io/2016/10/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://duia.github.io/2016/10/22/java设计模式之单例模式/</id>
    <published>2016-10-22T05:16:00.000Z</published>
    <updated>2019-04-25T08:00:00.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。</p><h2 id="单例模式的好处"><a href="#单例模式的好处" class="headerlink" title="单例模式的好处"></a>单例模式的好处</h2><ul><li>某些类创建比较频繁，尤其对于一些大型的对象，这是一笔很大的系统开销，应用单例可以减小内存开销。</li><li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</li><li>可以避免对资源的多重占用，如对同一文件的写操作，单例可以保证同时只有一个写操作。</li></ul><p>貌似还有别的好处或别的说法，用用自己体会一下才是最好的。<br><a id="more"></a></p><h2 id="单利模式怎么用"><a href="#单利模式怎么用" class="headerlink" title="单利模式怎么用"></a>单利模式怎么用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 私有构造方法，防止被实例化 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态工程方法，创建实例 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试时经常遇到会问到或者让快速写一个单例出来，可用一句话描述如下：</p><blockquote><p>一个类，将此类的构造函数私有化，并在内部提供一个静态实例对象和获取该实例的静态方法，每次获取该实例时做个判断，看是否进行过实例化，如果没有先进行实例化。</p></blockquote><h2 id="哪里使用过"><a href="#哪里使用过" class="headerlink" title="哪里使用过"></a>哪里使用过</h2><ul><li>回收站，咱们所使用的windows系统的回收站就是单例的。</li><li>spring中，每个bean默认全部都是单例的，spring容器管理这这些bean的生命周期</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="懒汉式的线程安全问题"><a href="#懒汉式的线程安全问题" class="headerlink" title="懒汉式的线程安全问题"></a>懒汉式的线程安全问题</h3><p>上边的例子被称为懒汉式，即在第一次获取实例的时候进行实例化，如果存在高并发时会产生多次实例化的问题，当<code>new Singleton()</code>执行完还没来得及赋值给<code>instance</code>时，如果第二个程序又来获取实例，正好运行到了<code>if(instance == null)</code>处，就会再次进行实例化对象。</p><p>所以考虑到线程安全的问题，可以加入synchronized修饰，如下，可放在方法上或创建对象时。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样做会严重影响程序性能，每次获取或者实例化时都需要等待上次运行完成，所以性能比较底下。</p><p>考虑到上边性能问题，可以将实例化过程提出成单个的方法，加上synchronized修饰，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">syncInit();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样除非在第一次实例化时，之后获取实例不会有性能问题了</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>以上均为懒汉式单例模式，如果采用饿汉式就不会产生多次实例化的问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由于是静态成员变量，类产生时也就实例化了这个类，就不会有多次实例化问题 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实际中更好的应用"><a href="#实际中更好的应用" class="headerlink" title="实际中更好的应用"></a>实际中更好的应用</h3><p>实际情况下，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 私有构造方法，防止被实例化 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取实例 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonFactory.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。</p><p>同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。</p><h3 id="利用单例写法，扩展指定个数对象的创建"><a href="#利用单例写法，扩展指定个数对象的创建" class="headerlink" title="利用单例写法，扩展指定个数对象的创建"></a>利用单例写法，扩展指定个数对象的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singletons</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要产生的对象最大个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxNum = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//设置了属性便于测试</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singletons</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个私有的集合，来储存对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Singletons&gt; list = <span class="keyword">new</span> ArrayList&lt;Singletons&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态代码块，加载类的同时，产生相应的对象保存在集合中</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxNum; i++) &#123;</span><br><span class="line">list.add(<span class="keyword">new</span> Singletons(<span class="string">"单例"</span>+i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供静态的对外方式，随机获取一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singletons <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">return</span> list.get(random.nextInt(maxNum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Singleton3 [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：每次打印的结果可能会不同，随机从三个对象中获取一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//每次打印的对象是不同的</span></span><br><span class="line">System.out.println(Singletons.getInstance());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是个人对单例模式的理解，并结合了一些在实际开发中使用过的情况进行的总结。如果错误请大家及时指出，以便更正。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是单例模式&quot;&gt;&lt;a href=&quot;#什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式&quot;&gt;&lt;/a&gt;什么是单例模式&lt;/h2&gt;&lt;p&gt;单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。&lt;/p&gt;
&lt;h2 id=&quot;单例模式的好处&quot;&gt;&lt;a href=&quot;#单例模式的好处&quot; class=&quot;headerlink&quot; title=&quot;单例模式的好处&quot;&gt;&lt;/a&gt;单例模式的好处&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;某些类创建比较频繁，尤其对于一些大型的对象，这是一笔很大的系统开销，应用单例可以减小内存开销。&lt;/li&gt;
&lt;li&gt;省去了new操作符，降低了系统内存的使用频率，减轻GC压力。&lt;/li&gt;
&lt;li&gt;可以避免对资源的多重占用，如对同一文件的写操作，单例可以保证同时只有一个写操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;貌似还有别的好处或别的说法，用用自己体会一下才是最好的。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/categories/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://duia.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>RedisTemplate在项目中的使用</title>
    <link href="https://duia.github.io/2016/10/18/RedisTemplate%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://duia.github.io/2016/10/18/RedisTemplate在项目中的使用/</id>
    <published>2016-10-18T14:02:00.000Z</published>
    <updated>2019-04-25T08:00:00.007Z</updated>
    
    <content type="html"><![CDATA[<p>API是好东西，开篇先放上两API，以下会用得着，学会多看API。</p><p><a href="http://docs.spring.io/spring-data/redis/docs/current/api/" target="_blank" rel="noopener">Spring Data Redis 1.7.4.RELEASE API</a></p><p><a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">redis中文文档</a></p><p>接着上篇文章， <a href="/post/springmvc-mybatis-redis.html">spring+mybatis+redis</a>，在实际的开发中，需要人工的去对redis缓冲进行增删改查（原因文章最后讨论，重点），于是使用到了Spring Data Redis的RedisTemplate，在初次使用过程中总结了一些学习使用的过程，并做了部分归纳，具体如下。</p><p>使用过redisTemplate的童鞋可以直接跳到<strong>实际开发中的使用情况</strong>部分，有更重要的内容需要讨论。</p><h2 id="注入redisTemplate"><a href="#注入redisTemplate" class="headerlink" title="注入redisTemplate"></a>注入redisTemplate</h2><p>在spring-redis.xml添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.core.RedisTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jedisConnectionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keySerializer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueSerializer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashKeySerializer"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashValueSerializer"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样便可在控制层或业务逻辑层代码中获取并使用redisTemplate。</p><h2 id="JAVA集合和Redis集合"><a href="#JAVA集合和Redis集合" class="headerlink" title="JAVA集合和Redis集合"></a>JAVA集合和Redis集合</h2><p>不要试图使用泛型Java集合，例如<code>RedisTemplate&lt;Key,Collection&lt;?&gt;&gt;</code>，这种用法等价于在jvm把Collection&lt;?&gt;序列化成字节数组，以value的形式保存到redis中，很显然，这种方法非常低效，不仅存在大量的序列化反序列化操作，并且每次操作集合都要首先获取一个完整的集合（包含所有的元素）。这是很容易理解的，举个例子，如果你想将一个集合保存在redis缓冲中，如果将集合序列化后转换成一大段字符串，并以key-value的形式保存就会犯了上边说的错误，而redis有保存这个结构数据的数据类型了，我们可以根据具体需求将其保存成List、Set、ZSet数据格式。redis提供的5中数据类型，Value，List，Set，ZSet（Sorted Set）和Map，具体详细大家可以自行学习一下。</p><h2 id="RedisTemplate的主要方法"><a href="#RedisTemplate的主要方法" class="headerlink" title="RedisTemplate的主要方法"></a>RedisTemplate的主要方法</h2><blockquote><p>RedisTemplate&lt;K, V&gt; implements RedisOperations&lt;K, V&gt;</p></blockquote><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td>&lt;HK,HV&gt; BoundHashOperations&lt;K,HK,HV&gt;</td><td>boundHashOps(K key)  返回绑定了key的Hash类型操作执行类。</td></tr><tr><td>BoundListOperations&lt;K,V&gt;</td><td>boundListOps(K key) 返回绑定了key的List类型操作执行类。</td></tr><tr><td>BoundSetOperations&lt;K,V&gt;</td><td>boundSetOps(K key) 返回绑定了key的Set类型操作执行类。</td></tr><tr><td>BoundValueOperations&lt;K,V&gt;</td><td>boundValueOps(K key)  返回绑定了key的简单（String）类型操作执行类。</td></tr><tr><td>BoundZSetOperations&lt;K,V&gt;</td><td>boundZSetOps(K key) 返回绑定了key的有序Set类型操作执行类。</td></tr><tr><td>&lt;HK,HV&gt; HashOperations&lt;K,HK,HV&gt;</td><td>opsForHash() 返回Hash类型操作执行类。</td></tr><tr><td>ListOperations&lt;K,V&gt;</td><td>opsForList() 返回List类型操作执行类。</td></tr><tr><td>SetOperations&lt;K,V&gt;</td><td>opsForSet() 返回Set类型操作执行类。</td></tr><tr><td>ValueOperations&lt;K,V&gt;</td><td>opsForValue() 返回简单（String）类型操作执行类。</td></tr><tr><td>ZSetOperations&lt;K,V&gt;</td><td>opsForZSet() 返回有序Set类型操作执行类。</td></tr></tbody></table><p>Bound开头的方法获取了一个指定操作对象（key）的operator，在一个连接（事务）内只能操作这个key对应的value。<br>没有Bound开头的方法是获取一个operator，但是没有指定操作的对象（key），可以在一个连接（事务）内操作多个key以及对应的value。该部分是对redis操作的高度封装，利用该该方法返回的对象便可完成大部分的操作。</p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><t> T</t></td><td>execute(RedisCallback<t> action) 操作Redis中的 connection.</t></td></tr></tbody></table><p>以上的方法是redisTemplate中执行操作的底层方法，任何基于redisTemplate之上的调用(比如，valueOperations)最终都会被封装成RedisCallback，redisTemplate在execute方法中将会直接使用jedis客户端API进行与server通信，而且在如果使用了连接池，则会在操作之后执行returnSource。</p><p>其他常用操作</p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td>void</td><td>delete(K key) 根据key删除缓冲</td></tr><tr><td>Boolean</td><td>hasKey(K key) 判断key是否存在</td></tr><tr><td>Set<k></k></td><td>keys(K pattern) 根据pattren匹配key</td></tr></tbody></table><h2 id="Redis中5种数据类型的操作API"><a href="#Redis中5种数据类型的操作API" class="headerlink" title="Redis中5种数据类型的操作API"></a>Redis中5种数据类型的操作API</h2><h3 id="ValueOperations"><a href="#ValueOperations" class="headerlink" title="ValueOperations"></a>ValueOperations</h3><p>该数据类型可以理解为java中的<code>Map&lt;Object, Object&gt;</code></p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td>Integer</td><td>append(K key, String value) 在key的value后追加，没有该key是新增</td></tr><tr><td>String</td><td>get(K key, long start, long end) </td></tr><tr><td>V</td><td>get(Object key) 根据key获取value</td></tr><tr><td>V</td><td>getAndSet(K key, V value) </td></tr><tr><td>List<v></v></td><td>multiGet(Collection<k> keys) </k></td></tr><tr><td>void</td><td>multiSet(Map&lt;? extends K,? extends V&gt; m) </td></tr><tr><td>void</td><td>set(K key, V value) 新增</td></tr><tr><td>void</td><td>set(K key, V value, long offset) </td></tr><tr><td>void</td><td>set(K key, V value, long timeout, TimeUnit unit) Set key to hold the string value until timeout.</td></tr><tr><td>Long</td><td>size(K key) </td></tr></tbody></table><h3 id="ListOperations-lt-K-V-gt"><a href="#ListOperations-lt-K-V-gt" class="headerlink" title="ListOperations&lt;K,V&gt;"></a>ListOperations&lt;K,V&gt;</h3><p>该数据类型可以看作是<code>Map&lt;Object, List&lt;Objeck&gt;&gt;</code>，该数据通过key获取到的是一个集合</p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td>V</td><td>index(K key, long index) </td></tr><tr><td>V</td><td>leftPop(K key) 获取key表示的集合的第一个值，同时会将第一值删除</td></tr><tr><td>V</td><td>leftPop(K key, long timeout, TimeUnit unit) </td></tr><tr><td>Long</td><td>leftPush(K key, V value) 在key表示的集合最前边添加value</td></tr><tr><td>Long</td><td>leftPush(K key, V pivot, V value) </td></tr><tr><td>Long</td><td>leftPushAll(K key, Collection<v> values)  在key表示的集合前边添加一个集合</v></td></tr><tr><td>Long</td><td>leftPushAll(K key, V… values) 同上</td></tr><tr><td>Long</td><td>rightPush(K key, V value) 参考leftPush</td></tr><tr><td>Long</td><td>rightPushAll(K key, Collection<v> values) 参考leftPushAll</v></td></tr><tr><td>Long</td><td>rightPushAll(K key, V… values) 同上</td></tr></tbody></table><h3 id="SetOperations-lt-K-V-gt"><a href="#SetOperations-lt-K-V-gt" class="headerlink" title="SetOperations&lt;K,V&gt;"></a>SetOperations&lt;K,V&gt;</h3><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td>Long</td><td>add(K key, V… values) 添加一个或多个value到key集合中</td></tr><tr><td>Set<v></v></td><td>difference(K key, Collection<k> otherKeys) 差集，key代表的集合中在otherKeys代表全部集合中都没有的元素</k></td></tr><tr><td>Set<v></v></td><td>difference(K key, K otherKey) 差集，key代表的集合中在otherKey代表集合中没有的元素</td></tr><tr><td>Set<v></v></td><td>intersect(K key, Collection<k> otherKeys)</k></td></tr><tr><td>Set<v></v></td><td>intersect(K key, K otherKey) 交集，key代表集合的交集</td></tr><tr><td>Boolean</td><td>isMember(K key, Object o) 判断o是否是key代表集合中的元素</td></tr><tr><td>Set<v></v></td><td>members(K key) 返回key集合中的成员</td></tr><tr><td>Set<v></v></td><td>union(K key, Collection<k> otherKeys) </k></td></tr><tr><td>Set<v></v></td><td>union(K key, K otherKey) 并集，所有key代表集合的并集</td></tr></tbody></table><h3 id="ZSetOperations-lt-K-V-gt"><a href="#ZSetOperations-lt-K-V-gt" class="headerlink" title="ZSetOperations&lt;K,V&gt;"></a>ZSetOperations&lt;K,V&gt;</h3><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td>Boolean</td><td>add(K key, V value, double score) 在key表示的set集合中添加value，score用于排序</td></tr><tr><td>Long</td><td>count(K key, double min, double max) </td></tr><tr><td>Set<v></v></td><td>range(K key, long start, long end) 获取key表示的set集合，start起始位置，end结束位置，获取全部分别赋值为0, -1</td></tr><tr><td>Set<v></v></td><td>rangeByScore(K key, double min, double max) 获取key表示的集合中score在min和max之间数据的set集合，包含min和max，获取全部可分别赋值为Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY</td></tr></tbody></table><h3 id="HashOperations-lt-K-V-gt"><a href="#HashOperations-lt-K-V-gt" class="headerlink" title="HashOperations&lt;K,V&gt;"></a>HashOperations&lt;K,V&gt;</h3><p>类似于java中的<code>Map&lt;String, Map&lt;String, Object&gt;&gt;</code></p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td>Long</td><td>delete(H key, Object… hashKeys) 删除key、hashKeys值</td></tr><tr><td>Map&lt;HK,HV&gt;</td><td>entries(H key) 获取key代表的map集合</td></tr><tr><td>HV</td><td>get(H key, Object hashKey) 从key代表的map中获取hashKey的值</td></tr><tr><td>Boolean</td><td>hasKey(H key, Object hashKey) 判断key的map中hashKey是否存在</td></tr><tr><td>Set<hk></hk></td><td>keys(H key) 获取key代表map集合的键集合</td></tr><tr><td>List<hv></hv></td><td>multiGet(H key, Collection<hk> hashKeys) 获取key的map中hashKeys对应的值集合</hk></td></tr><tr><td>void</td><td>put(H key, HK hashKey, HV value) 在key的map中保存hashKey-value</td></tr><tr><td>void</td><td>putAll(H key, Map&lt;? extends HK,? extends HV&gt; m) </td></tr><tr><td>List<hv></hv></td><td>values(H key) 获取key的map集合中值的集合</td></tr></tbody></table><h2 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a>API的使用</h2><p>如果大家看了<a href="http://docs.spring.io/spring-data/redis/docs/current/api/" target="_blank" rel="noopener">Spring Data Redis 1.7.4.RELEASE API</a>，相信大家一定和我一样有困惑，除了全是英文，大部分方法是没有任何说明的，简单说说我的方法，和大家分享一下，大家有什么好方法也可以共享一下。首先先感谢一下<a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">redis中文文档</a>团队，这个API写的好。</p><p>下载Spring Data Redis 1.7.4.RELEASE的源码后，可以进行方法跟踪，以上的所有方法进行一步一步往低层走后，全会出现类似以下的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> execute(<span class="keyword">new</span> RedisCallback&lt;...&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> ... doInRedis(RedisConnection connection) &#123;</span><br><span class="line"><span class="keyword">return</span> connection....</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>connection所调用的方法全部可以在<a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">redis中文文档</a>中找到，包括参数，大家就很容易理解Spring Data Redis 1.7.4.RELEASE中方法的用途了。</p><h2 id="实际开发中的使用情况"><a href="#实际开发中的使用情况" class="headerlink" title="实际开发中的使用情况"></a>实际开发中的使用情况</h2><p>先说一下我最直接的感受：使用redisTemplate真是一个出力不讨好的选择。完全代表个人感受，大家可以谈谈你们的看法。</p><p>当第一次接到这个要求，要求项目中要使用redisTemplate人工控制缓冲的，一直在思考一个问题，也问过领导同事，“出于一个什么样的目的要这样去控制缓冲”，在我再三询问下竟然有同事给出了“就是想用，没理由”的理由，领导给的答案是“如果直接使用自动mybatis+redis的缓冲方式，没有指定的添加修改缓冲，缓冲会放的太多，占用空间”。</p><p>在接下来的工作中开始了添加缓冲功能，遇到了以下应该思考的问题：</p><ul><li>哪里该添加缓冲</li><li>什么时候需要删除或修改缓冲</li><li>redis缓冲key值的规则制定，以确保缓冲的灵活性</li><li>缓冲数据的保存形式该选什么</li><li>本以写好的代码不得不加入新的逻辑业务功能模块</li><li>甚至有些多表关联的数据为了存取修改缓冲的方便不得不再拆成单表进行多次查询的方式</li><li>…</li></ul><p>以上就是我在实际开发中遇到的问题，带来的开发负担是小，主要是影响到了原先已经测试通过的代码功能，也曾想着有什么更好的方式方法来解决这样的问题，所以在总结了以上内容也提出了自己的疑问，希望有遇到过类似问题的前辈们指点一二。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;API是好东西，开篇先放上两API，以下会用得着，学会多看API。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.spring.io/spring-data/redis/docs/current/api/&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
      <category term="spring" scheme="https://duia.github.io/categories/JAVA/spring/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="API" scheme="https://duia.github.io/tags/API/"/>
    
      <category term="redis" scheme="https://duia.github.io/tags/redis/"/>
    
      <category term="spring" scheme="https://duia.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>springmvc+mybatis+redis</title>
    <link href="https://duia.github.io/2016/10/09/springmvc+mybatis+redis/"/>
    <id>https://duia.github.io/2016/10/09/springmvc+mybatis+redis/</id>
    <published>2016-10-09T14:52:00.000Z</published>
    <updated>2019-04-25T08:00:00.024Z</updated>
    
    <content type="html"><![CDATA[<p>利用springmvc+mybatis+redis搭建第三方缓冲功能程序。</p><h4 id="springmvc-mybatis项目，这里搭建过程就略了"><a href="#springmvc-mybatis项目，这里搭建过程就略了" class="headerlink" title="springmvc+mybatis项目，这里搭建过程就略了"></a>springmvc+mybatis项目，这里搭建过程就略了</h4><h4 id="准备redis服务器-这里提供window和linux系统的版本下载链接："><a href="#准备redis服务器-这里提供window和linux系统的版本下载链接：" class="headerlink" title="准备redis服务器,这里提供window和linux系统的版本下载链接："></a>准备redis服务器,这里提供window和linux系统的版本下载链接：</h4><p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">window redis</a></p><p><a href="http://redis.io/download" target="_blank" rel="noopener">Linux redis</a><br><a id="more"></a></p><h4 id="修改pom-xml，在原先基础上添加一下代码"><a href="#修改pom-xml，在原先基础上添加一下代码" class="headerlink" title="修改pom.xml，在原先基础上添加一下代码"></a>修改pom.xml，在原先基础上添加一下代码</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加类"><a href="#添加类" class="headerlink" title="添加类"></a>添加类</h4><p>RedisCache.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wpc.redis;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> com.wpc.util.SerializeUtil;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.exceptions.JedisConnectionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现redis第三方缓冲</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> W鹏程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisConnectionFactory jedisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCache</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cache instances require an ID"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        RedisConnection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = jedisConnectionFactory.getConnection();</span><br><span class="line">            connection.flushDb();</span><br><span class="line">            connection.flushAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisConnectionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        RedisConnection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = jedisConnectionFactory.getConnection();</span><br><span class="line">            result = SerializeUtil.unserialize(connection.get(SerializeUtil.serialize(key)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisConnectionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.readWriteLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        RedisConnection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = jedisConnectionFactory.getConnection();</span><br><span class="line">            result = Integer.valueOf(connection.dbSize().toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisConnectionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        RedisConnection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = jedisConnectionFactory.getConnection();</span><br><span class="line">            connection.set(SerializeUtil.serialize(key), SerializeUtil.serialize(value));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisConnectionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        RedisConnection connection = <span class="keyword">null</span>;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = jedisConnectionFactory.getConnection();</span><br><span class="line">            result = connection.expire(SerializeUtil.serialize(key), <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisConnectionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setJedisConnectionFactory</span><span class="params">(JedisConnectionFactory jedisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisCache.jedisConnectionFactory = jedisConnectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisCacheTransfer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wpc.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工具bean，作用是在启动容器的时候利用spring将JedisConnectionFactory注入到RedisCache</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> W鹏程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheTransfer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJedisConnectionFactory</span><span class="params">(JedisConnectionFactory jedisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisCache.setJedisConnectionFactory(jedisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SerializeUtil.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wpc.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.cache.CacheException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化和反序列化工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> W鹏程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(Object object) &#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(object);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">            <span class="keyword">return</span> ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="添加spring-redis-xml"><a href="#添加spring-redis-xml" class="headerlink" title="添加spring-redis.xml"></a>添加spring-redis.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:config/redis.properties"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.pool.minIdle&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.pool.maxIdle&#125;"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.pool.maxActive&#125;"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.pool.maxWait&#125;"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.pool.testOnBorrow&#125;"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.host&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.port&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.password&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usePool"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"poolConfig"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisCacheTransfer"</span> <span class="attr">class</span>=<span class="string">"com.wpc.redis.RedisCacheTransfer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jedisConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jedisConnectionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>redis.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis.pool.maxActive=100</span><br><span class="line">redis.pool.minIdle=1</span><br><span class="line">redis.pool.maxIdle=20</span><br><span class="line">redis.pool.maxWait=3000</span><br><span class="line">redis.pool.testOnBorrow=true</span><br><span class="line">redis.host=127.0.0.1</span><br><span class="line">redis.port=6379</span><br><span class="line">redis.password=</span><br></pre></td></tr></table></figure></p><h4 id="开始mybatis对缓冲的支持，在mybatis-config-xml中添加："><a href="#开始mybatis对缓冲的支持，在mybatis-config-xml中添加：" class="headerlink" title="开始mybatis对缓冲的支持，在mybatis-config.xml中添加："></a>开始mybatis对缓冲的支持，在mybatis-config.xml中添加：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在所需要写入缓冲的-Mapper-xml文件加入如下代码："><a href="#在所需要写入缓冲的-Mapper-xml文件加入如下代码：" class="headerlink" title="在所需要写入缓冲的*Mapper.xml文件加入如下代码："></a>在所需要写入缓冲的*Mapper.xml文件加入如下代码：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"LRU"</span> <span class="attr">type</span>=<span class="string">"com.wpc.redis.RedisCache"</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样所有的查询语句都会加入到缓冲中，如有些查询不需要的话可以在<code>select</code>标签加入<code>useCache=&quot;false&quot;</code>属性。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试的时候可以把日志级别设置为debug级别，这样可以看到Mybatis的sql语句。当走缓存的时候，是不会打印sql语句的，反之会出现sql语句。</p><p>PS: 以上讨论了借用redis开启mybatis的第三方缓冲功能，在我工作过程中遇到了利用spring-redis的redisTemplate的地方，所以下一次我将讲讲我在工作中使用redisTemplate的过程遇到的问题。希望和大家共同讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用springmvc+mybatis+redis搭建第三方缓冲功能程序。&lt;/p&gt;
&lt;h4 id=&quot;springmvc-mybatis项目，这里搭建过程就略了&quot;&gt;&lt;a href=&quot;#springmvc-mybatis项目，这里搭建过程就略了&quot; class=&quot;headerlink&quot; title=&quot;springmvc+mybatis项目，这里搭建过程就略了&quot;&gt;&lt;/a&gt;springmvc+mybatis项目，这里搭建过程就略了&lt;/h4&gt;&lt;h4 id=&quot;准备redis服务器-这里提供window和linux系统的版本下载链接：&quot;&gt;&lt;a href=&quot;#准备redis服务器-这里提供window和linux系统的版本下载链接：&quot; class=&quot;headerlink&quot; title=&quot;准备redis服务器,这里提供window和linux系统的版本下载链接：&quot;&gt;&lt;/a&gt;准备redis服务器,这里提供window和linux系统的版本下载链接：&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/MSOpenTech/redis/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;window redis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://redis.io/download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux redis&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://duia.github.io/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://duia.github.io/tags/java/"/>
    
      <category term="redis" scheme="https://duia.github.io/tags/redis/"/>
    
      <category term="spring" scheme="https://duia.github.io/tags/spring/"/>
    
      <category term="springmvc" scheme="https://duia.github.io/tags/springmvc/"/>
    
      <category term="mybatis" scheme="https://duia.github.io/tags/mybatis/"/>
    
  </entry>
  
</feed>
