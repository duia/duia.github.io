<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">






<meta name="description" content="宁在地狱为王，不愿天堂为仆">
<meta name="keywords" content="W鹏程,鹏程">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="https://duia.github.io/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="宁在地狱为王，不愿天堂为仆">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">
<meta name="twitter:description" content="宁在地狱为王，不愿天堂为仆">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://duia.github.io/">





  <title>个人博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d05b0991ea544c8d9c4cb7a57ff5fc4d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-technology">
          <a href="/technology/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-file-text"></i> <br>
            
            技术关注
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2019/05/16/Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流/" itemprop="url">Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-16T19:45:00+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/spring-boot/" itemprop="url" rel="index">
                    <span itemprop="name">spring boot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://user-images.githubusercontent.com/9434884/43697219-3cb4ef3a-9975-11e8-9a9c-73f4f537442d.png" alt="Sentinel Logo"></p>
<h1 id="Sentinel-分布式系统的流量防卫兵"><a href="#Sentinel-分布式系统的流量防卫兵" class="headerlink" title="Sentinel: 分布式系统的流量防卫兵"></a>Sentinel: 分布式系统的流量防卫兵</h1><h2 id="Sentinel-是什么？"><a href="#Sentinel-是什么？" class="headerlink" title="Sentinel 是什么？"></a>Sentinel 是什么？</h2><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p>快速上手可以参照官网给出的<a href="https://github.com/alibaba/Sentinel/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">新手指南</a>进行尝试了解。</p>
<p><a href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5" target="_blank" rel="noopener">详细介绍</a></p>
<p>本文主要对实际开发中遇到的问题，以及官网推荐的使用方式进行整合的过程遇到的问题进行整理。</p>
<h2 id="Sentinel-Zookeeper动态数据源-Springboot客户端-集群限流"><a href="#Sentinel-Zookeeper动态数据源-Springboot客户端-集群限流" class="headerlink" title="Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流"></a>Sentinel + Zookeeper动态数据源 + Springboot客户端 + 集群限流</h2><p>控制台可以使用官方给提供的jar，springboot项目最快的集成过程可以参考<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/wiki/Sentinel" target="_blank" rel="noopener">Spring Cloud Alibaba Sentinel</a>，也可以看我如下整理的代码进行快速集成使用。</p>
<h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><p>下载官方提供的Sentinel 控制台jar，参考<a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0" target="_blank" rel="noopener">Sentinel 控制台</a>进行启动，其实就是普通的springboot项目，可以指定自己的启动参数，自行启动，不再赘诉。</p>
<p>首次启动登陆，左边的菜单和右边的内容为空，别急，因为我们还没有接入客户端。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在要接入Sentinel的springboot项目的pom.xml添加如下代码，放到适合的位置。<code>spring-cloud-starter-alibaba-sentinel</code>包含了所有官网提供能的关于sentinel的组件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- springboot 1.x 用0.1.2.RELEASE  springboot 2.x 用0.2.2.RELEASE--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>application.properties中添加一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.sentinel.transport.dashboard=localhost:8080</span><br></pre></td></tr></table></figure></p>
<p>集成完成。</p>
<p>启动我们项目进行访问。返回Sentinel 控制台即可看到如下界面。</p>
<p><img src="https://github.com/alibaba/Sentinel/wiki/image/resourceTree.png" alt="簇点链路"></p>
<p>每个url都是我们刚才访问过的路径，对于Sentinel称之为资源，即我们可以对该资源进行限流等的操作。</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>Sentinel定义资源分为5种，具体可以查看<a href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">定义资源</a>，我们可以根据业务的需要进行资源的选择。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>Sentinel<a href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E8%A7%84%E5%88%99%E7%9A%84%E7%A7%8D%E7%B1%BB" target="_blank" rel="noopener">规则的种类</a>如下图，有5种规则供我们使用。</p>
<p><img src="https://user-images.githubusercontent.com/9434884/48189045-2ae58400-e37a-11e8-84aa-2e2c0dd042e2.png" alt="规则管理"></p>
<p>以上是最基本的配置，如果不做任何修改，Dashboard的推送规则方式是通过 API 将规则推送至客户端并直接更新到内存中：</p>
<p><img src="https://camo.githubusercontent.com/96b07d598c9eee5a513801cecc68f266fbe58d14/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f34373638382f313533363636303239363237332d34663434306262612d356239652d343230352d393430322d6662363038336236363931322e706e67" alt></p>
<p>此模式为原始模式，<strong>缺点</strong>是每次重启客户端后所有的规则将丢失。Sentinel还提供了Pull 模式、Push 模式。详细可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel" target="_blank" rel="noopener">在生产环境中使用 Sentinel</a>。</p>
<p>官方给的建议：<strong>生产环境下一般采用 push 模式的数据源</strong>。要使用<a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel#Push%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">push 模式</a>就需要对官方给提供的控制台进行改造，以及对客户端进行相应的配置。</p>
<p><img src="https://user-images.githubusercontent.com/9434884/45406233-645e8380-b698-11e8-8199-0c917403238f.png" alt></p>
<h2 id="控制台改造"><a href="#控制台改造" class="headerlink" title="控制台改造"></a>控制台改造</h2><p>官方给的说明有点混乱，整合过程中遇了不少问题，所幸是一步步走出来了。以下就将整理过程整理出来。</p>
<p><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel源码</a>，要改造控制台，源码是必不可少的，下载源码。其实要改造的就是加入Zookeeper动态数据源，源码中已经有了代码，可以拿来直接使用（也提供了apollo、nacos数据源的支持），位置在<code>sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/rule</code>下，将<code>zookeeper</code>包从test拖到main包下，修改<code>FlowControllerV2.java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"flowRuleZookeeperProvider"</span>)</span><br><span class="line"><span class="keyword">private</span> DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"flowRuleZookeeperPublisher"</span>)</span><br><span class="line"><span class="keyword">private</span> DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;</span><br></pre></td></tr></table></figure></p>
<p>这部分是<code>sentinel-dashboard</code>隐藏的代码及功能，应该是处于开发阶段，估计后期会有更好的集成方式。</p>
<p>启动sentinel-dashboard项目，点击菜单<strong>流控规则</strong>，可以看到访问路径如：<code>&lt;localhost:port&gt;/#/dashboard/flow/xxxxx</code>，需要手动添加“v2”为<code>&lt;localhost:port&gt;/#/dashboard/v2/flow/xxxxx</code>，一个隐藏的界面，此处添加的流控规则会被保存到我们配置好的zookeeper中。</p>
<p>或者找到<code>sidebar.html</code>将如下代码放开：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"dashboard.flow(&#123;app: entry.app&#125;)"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-filter"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>  流控规则 V2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>控制台会多一菜单。</p>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>客户端集成相对容易一点，<code>application.properties</code>中添加如下代码即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.sentinel.datasource.ds3.zk.server-addr=localhost:2181</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.group-id=SENTINEL_GROUP</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.data-id=xxxxxx</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.rule-type=flow</span><br><span class="line">spring.cloud.sentinel.datasource.ds3.zk.data-type=json</span><br></pre></td></tr></table></figure></p>
<p>官方给的例子点<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/sentinel-example/sentinel-core-example/readme-zh.md" target="_blank" rel="noopener">Sentinel Example</a>。</p>
<p>在整合过程中废了点时间，因为官方给的说明有点混乱，是给控制台的代码还是给客户端的代码没有明确的说明，还有如上代码中的group-id、data-id等也没有明确的说明，一不注意配置不对，流控规则就不会生效。</p>
<p><code>InitFunc</code>接口，可以用作<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95#%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%BA%90" target="_blank" rel="noopener">注册数据源</a>，在尝试过程中发现这段代码配置到客户端是起作用的，即相当于上边客户端集成的在<code>application.properties</code>中添加的那段代码作用一样。具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; ruleSource = <span class="keyword">new</span> ZookeeperDataSource&lt;&gt;(remoteAddress, groupId,</span><br><span class="line">	flowDataId, source -&gt; JSON.parseObject(source, <span class="keyword">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));</span><br><span class="line">FlowRuleManager.register2Property(ruleSource.getProperty());</span><br></pre></td></tr></table></figure></p>
<p>其中groupId、flowDataId注意，需要与控制台改造中设计到的zookeeper的path一致，否则规则不生效。</p>
<p><a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7" target="_blank" rel="noopener">集群流控</a>，控制台已经集成了该功能，我们拿来可以直接用，省去了调用API的麻烦，但该功能是需要客户端的支持。</p>
<p>Sentinel 集群限流服务端有两种启动方式：独立模式（Alone）；嵌入模式（Embedded）。调试集群限流看代码的过程中发现了<a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-cluster/sentinel-demo-cluster-embedded" target="_blank" rel="noopener">嵌入模式Demo</a>，此处是给springboot客户端集成的demo示例，将entity包、init包、DemoConstants类、META-INF文件夹及它们里边的类和文件，复制到咱们的springboot项目对应位置，自行配置集群，通过jmeter压测接口，会发现集群限流起作用了。</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>1、在控制台的日志里面显示setRules:success，但设置限流规则为什么不显示（不起作用）</p>
<pre><code>查看fastjson 版本，移除我们引入的jar，使用sentinel中的版本。
</code></pre><p>2、convert error：客户端报错有这样的关键字，可以在Sentinel控制台的源码中找到<code>FlowRuleEntity.java</code>，将以下属性添加注解<code>@JSONField(serialize = false)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> String app;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> String ip;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Date gmtCreate;</span><br><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Date gmtModified;</span><br></pre></td></tr></table></figure></p>
<p>3、集群限流不准确，项目添加以下启动参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dcsp.sentinel.log.use.pid=true</span><br></pre></td></tr></table></figure></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Sentinel官方源码中其实已经包含了所有需要到的代码，就是没有比较系统直白的使用demo，可能也是还在开发阶段吧，期待官方的完善。</p>
<p>个人感觉目前源码中缺失的功能，亦或是我没有发现的功能，除了集群限流规则能做到持久化数据库，其它规则没有提供，包括集群应用的配置信息也没有持久化。所幸的是如果不配置客户端集群功能，即人为设置token server失败，如果Token Server不可用，各应用自动退化到单机限流。</p>
<p>官方提供了各种接口供我们使用，可以根据自己的需要，自行设置。还有更多功能等待挖掘，有什么更好的使用方式可以联系我，一起研究。</p>
<p>相关链接：<br><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel源码</a></p>
<p><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba" target="_blank" rel="noopener">Sentinel 与 Spring Boot / Spring Cloud 的整合</a></p>
<p><a href="https://github.com/all4you/sentinel-tutorial" target="_blank" rel="noopener">Sentinel 教程，包括原理分析，源码阅读，实战分享</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2019/03/21/Nginx Linux详细安装部署教程及配置SSL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/Nginx Linux详细安装部署教程及配置SSL/" itemprop="url">Nginx Linux详细安装部署教程及配置SSL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T11:48:00+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/" itemprop="url" rel="index">
                    <span itemprop="name">服务器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、Nginx简介"><a href="#一、Nginx简介" class="headerlink" title="一、Nginx简介"></a>一、Nginx简介</h2><p>Nginx是一个web服务器也可以用来做负载均衡及反向代理使用，目前使用最多的就是负载均衡，具体简介我就不介绍了百度一下有很多，下面直接进入安装步骤</p>
<h2 id="二、Nginx安装"><a href="#二、Nginx安装" class="headerlink" title="二、Nginx安装"></a>二、Nginx安装</h2><h3 id="1、下载Nginx及相关组件"><a href="#1、下载Nginx及相关组件" class="headerlink" title="1、下载Nginx及相关组件"></a>1、下载Nginx及相关组件</h3><p>Linux系统是Centos 6.5 64位，我直接切换到root用户下安装</p>
<p>进入用户目录下载程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# cd /usr/local/src/</span><br></pre></td></tr></table></figure>
<p>下载相关组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# wget http://nginx.org/download/nginx-1.10.2.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# wget http://www.openssl.org/source/openssl-fips-2.0.10.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure>
<p>安装c++编译环境，如已安装可略过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# yum install gcc-c++</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure>
<p>期间会有确认提示输入y回车</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is this ok [y/N]:y</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure>
<h3 id="2、安装Nginx及相关组件"><a href="#2、安装Nginx及相关组件" class="headerlink" title="2、安装Nginx及相关组件"></a>2、安装Nginx及相关组件</h3><p>openssl安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf openssl-fips-2.0.10.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd openssl-fips-2.0.10</span><br><span class="line">[root@localhost openssl-fips-2.0.10]# ./config &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure>
<p>pcre安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf pcre-8.40.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd pcre-8.40</span><br><span class="line">[root@localhost pcre-8.40]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure>
<p>zlib安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf zlib-1.2.11.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd zlib-1.2.11</span><br><span class="line">[root@localhost zlib-1.2.11]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure>
<p>nginx安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# tar zxvf nginx-1.10.2.tar.gz</span><br><span class="line">省略安装内容...</span><br><span class="line">[root@localhost src]# cd nginx-1.10.2</span><br><span class="line">[root@localhost nginx-1.10.2]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">省略安装内容...</span><br></pre></td></tr></table></figure>
<h3 id="3、启动Nginx"><a href="#3、启动Nginx" class="headerlink" title="3、启动Nginx"></a>3、启动Nginx</h3><p>先找一下nginx安装到什么位置上了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# whereis nginx</span><br><span class="line">nginx: /usr/local/nginx</span><br></pre></td></tr></table></figure>
<p>进入nginx目录并启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# cd /usr/local/nginx</span><br><span class="line">[root@localhost nginx]# sbin/nginx</span><br><span class="line">sbin/nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>报错了，按照下面方式解决</p>
<ol>
<li>用whereis libpcre.so.1命令找到libpcre.so.1在哪里</li>
<li>用ln -s /usr/local/lib/libpcre.so.1 /lib64命令做个软连接就可以了</li>
<li>用sbin/nginx启动Nginx</li>
<li>用ps -aux | grep nginx查看状态</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# whereis libpcre.so.1</span><br><span class="line">[root@localhost nginx]# ln -s /usr/local/lib/libpcre.so.1 /lib64</span><br><span class="line">[root@localhost nginx]# sbin/nginx</span><br><span class="line">[root@localhost nginx]# ps -aux | grep nginx</span><br></pre></td></tr></table></figure>
<p>进入Linux系统的图形界面，打开浏览器输入localhost会看到下图，说明nginx启动成功<br><img src="https://www.duia.online/upload/2019/2/90-46173693220190320183342795.png" alt="image"></p>
<p><strong>nginx的基本操作</strong></p>
<p>启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
<p>停止/重启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -s stop(quit、reload)</span><br></pre></td></tr></table></figure>
<p>命令帮助</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -h</span><br></pre></td></tr></table></figure>
<p>验证配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<h3 id="4、简单配置Nginx"><a href="#4、简单配置Nginx" class="headerlink" title="4、简单配置Nginx"></a>4、简单配置Nginx</h3><p>打开nginx配置文件位于nginx目录下的conf文件夹下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# vim conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>简单介绍一下vim的语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">默认vim打开后是不能录入的，需要按键才能操作，具体如下：</span><br><span class="line">开启编辑：按“i”或者“Insert”键</span><br><span class="line">退出编辑：“Esc”键</span><br><span class="line">退出vim：“:q”</span><br><span class="line">保存vim：“:w”</span><br><span class="line">保存退出vim：“:wq”</span><br><span class="line">不保存退出vim：“:q!”</span><br></pre></td></tr></table></figure>
<p>“#”代表注释，最重要的是server{}块这部分就代表每一个web站点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream testserver&#123;</span><br><span class="line">    server localhost:81;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.domain.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         proxy_pass http://testserver;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加如上代码，监听80端口，将域名访问<code>www.domain.com</code>的访问指到<code>localhost:81</code>，保存退出并且重启nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# ./sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
<h3 id="5-配置本地域名多服务"><a href="#5-配置本地域名多服务" class="headerlink" title="5.配置本地域名多服务"></a>5.配置本地域名多服务</h3><p>扩展upstream{}、server{}即可实现二级域名访问同一服务器的多服务项目。</p>
<h3 id="6-开启HTTPS、Nginx-证书部署"><a href="#6-开启HTTPS、Nginx-证书部署" class="headerlink" title="6.开启HTTPS、Nginx 证书部署"></a>6.开启HTTPS、Nginx 证书部署</h3><h4 id="获取证书略"><a href="#获取证书略" class="headerlink" title="获取证书略"></a>获取证书略</h4><h4 id="证书安装"><a href="#证书安装" class="headerlink" title="证书安装"></a>证书安装</h4><p>将域名 <a href="http://www.domain.com" target="_blank" rel="noopener">www.domain.com</a> 的证书文件 <code>1_www.domain.com_bundle.crt</code> 、私钥文件 <code>2_www.domain.com.key</code> 保存到同一个目录，例如 <code>/usr/local/nginx/conf</code> 目录下。<br>修改 Nginx 根目录下 <code>conf/nginx.conf</code> 文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate 1_www.domain.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key 2_www.domain.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://testserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完成后，请先执行命令 <code>sbin/nginx –t</code> 测试 Nginx 配置是否有误。若无报错，重启 Nginx 之后，即可使用 <code>https://www.domain.com</code> 来访问。</p>
<p>相关参数说明如下：</p>
<table>
<thead>
<tr>
<th>配置文件参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>listen 443</td>
<td>SSL 访问端口号为 443</td>
</tr>
<tr>
<td>ssl on</td>
<td>启用 SSL 功能</td>
</tr>
<tr>
<td>ssl_certificate</td>
<td>证书文件</td>
</tr>
<tr>
<td>ssl_certificate_key</td>
<td>私钥文件</td>
</tr>
<tr>
<td>ssl_protocols</td>
<td>使用的协议</td>
</tr>
<tr>
<td>ssl_ciphers</td>
<td>配置加密套件，写法遵循 openssl 标准</td>
</tr>
</tbody>
</table>
<p>如果配置完成后出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx:[emerg]unknown directive &quot;ssl&quot;</span><br></pre></td></tr></table></figure>
<p>因为我们配置这个SSL证书需要引用到nginx的中SSL这模块，然而我们一开始编译的Nginx的时候并没有把SSL模块一起编译进去，所以导致这个错误的出现。</p>
<h4 id="错误解决步骤"><a href="#错误解决步骤" class="headerlink" title="错误解决步骤"></a>错误解决步骤</h4><p>既然在安装的时候没有编译ssl，难道把nginx卸载重新安装一次？不不不，我们只需要在原有的基础上添加ssl模块就行了。</p>
<p>我们先来到当初下载nginx的包压缩的解压目录，解压目录应该在<code>/usr/loacl/src/</code>，绝大多数应该都是在这个目录下的，已经是一种规范了。</p>
<p>来到解压目录下后，按顺序执行一下命令：</p>
<p>命令1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# ./configure --with-http_ssl_module  //重新添加这个ssl模块</span><br></pre></td></tr></table></figure></p>
<p>注意如果没有出现错误，则直接看命令2即可 </p>
<p>执行以上一条命令出现这个错误<code>./configure：错误：SSL模块需要OpenSSL库。</code>，原因是因为缺少了OpenSSL，那我们再来安装一个即可执行：<code>yum -y install openssl openssl-devel</code></p>
<p>等待OpenSSL的安装完成后，再执行<code>./configure</code> ，最后在执行<code>命令1</code> 即可。</p>
<p>命令2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# make</span><br></pre></td></tr></table></figure></p>
<p>不要执行make install，因为make是用来编译的，而make install是安装，不然你整个nginx会重新覆盖的。</p>
<p>命令3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak // 先将原来的nginx备份想删除也可以</span><br><span class="line"></span><br><span class="line">[root@localhost nginx]# cp objs/nginx /usr/local/nginx/sbin/nginx // objs 目录中是编译后产生的文件</span><br></pre></td></tr></table></figure>
<p>再次<code>sbin/nginx –t</code>即可看见成功。</p>
<h4 id="使用全站加密，HTTP-自动跳转-HTTPS（可选）"><a href="#使用全站加密，HTTP-自动跳转-HTTPS（可选）" class="headerlink" title="使用全站加密，HTTP 自动跳转 HTTPS（可选）"></a>使用全站加密，HTTP 自动跳转 HTTPS（可选）</h4><p>对于用户不知道网站可以进行 HTTPS 访问的情况下，让服务器自动把 HTTP 的请求重定向到 HTTPS。</p>
<p>在服务器这边的话配置的话，可以在页面里加 js 脚本，也可以在后端程序里写重定向，当然也可以在 web 服务器来实现跳转。Nginx 是支持 rewrite 的（只要在编译的时候没有去掉 pcre）</p>
<p>在 HTTP 的 server 里增加 <code>rewrite ^(.*) https://$host$1 permanent;</code><br>这样就可以实现 80 进来的请求，重定向为 HTTPS 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.duia.online;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         proxy_pass http://haloserver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rewrite ^(.*) https://$host$1 permanent;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2019/02/22/ueditor+公式插件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/ueditor+公式插件/" itemprop="url">ueditor+公式插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T19:07:00+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ueditor-公式插件"><a href="#ueditor-公式插件" class="headerlink" title="ueditor+公式插件"></a>ueditor+公式插件</h2><p>本文主要说一说ueditor和公式插件KityFormula在使用过程中遇到的问题。</p>
<p>ueditor和项目的集成可以自行百度，KityFormula 可以看这里<a href="https://ueditor.baidu.com/website/kityformula.html" target="_blank" rel="noopener">KityFormula</a>，也相对简单，没啥问题。下边进入主题：</p>
<h3 id="生成公式图片"><a href="#生成公式图片" class="headerlink" title="生成公式图片"></a>生成公式图片</h3><p>默认生成<code>data:image/jpeg;base64</code>图片代码，找到kityFormulaDialog.html文件，有一段如下代码，加入一行代码即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dialog.onok = function()&#123;</span><br><span class="line">       kfe.execCommand(&apos;get.image.data&apos;, function(data)&#123;</span><br><span class="line">           var latex = kfe.execCommand(&apos;get.source&apos;);</span><br><span class="line">           editor.execCommand(&apos;inserthtml&apos;, &apos;&lt;img class=&quot;kfformula&quot; src=&quot;&apos;+ data.img +&apos;&quot; data-latex=&quot;&apos; + latex + &apos;&quot; /&gt;&apos;);</span><br><span class="line">           editor.getKfContent(function(html)&#123;&#125;);//新增代码</span><br><span class="line">           dialog.close();</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>editor.getKfContent()方法是KityFormula提供的生成图片的功能，生成图片需要后台代码的支持。这部分功能正式ueditor提供的涂鸦图片生成的功能。</p>
<h3 id="公式图片背景透明"><a href="#公式图片背景透明" class="headerlink" title="公式图片背景透明"></a>公式图片背景透明</h3><p>Ueditor生成的图片默认JPG格式，经过尝试发现只需要将生成的图片格式修改为PNG图片即可。做如下修改：<br>FileType.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final String JPG = &quot;JPG&quot;;</span><br><span class="line">public static final String PNG = &quot;PNG&quot;;</span><br><span class="line"></span><br><span class="line">private static final Map&lt;String, String&gt; types = new HashMap&lt;String, String&gt;()&#123;&#123;</span><br><span class="line">	</span><br><span class="line">	put( FileType.JPG, &quot;.jpg&quot; );</span><br><span class="line">	put( FileType.PNG, &quot;.png&quot; );</span><br><span class="line">	</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">//......</span><br></pre></td></tr></table></figure></p>
<p>Base64Uploader.java文件中”JPG”改为”PNG”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String suffix = FileType.getSuffix(&quot;JPG&quot;);</span><br></pre></td></tr></table></figure></p>
<h3 id="生成图片后富文本中图片标签加宽高"><a href="#生成图片后富文本中图片标签加宽高" class="headerlink" title="生成图片后富文本中图片标签加宽高"></a>生成图片后富文本中图片标签加宽高</h3><p>getKfContent.js文件设置item属性的地方加以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var width=&apos;&apos;;</span><br><span class="line">var height=&apos;&apos;;</span><br><span class="line">// 创建对象</span><br><span class="line">var img = new Image();</span><br><span class="line">// 设置图片的src</span><br><span class="line">img.src = url;</span><br><span class="line">//console.log(&quot;link:&quot;+link);</span><br><span class="line">img.onload = function()&#123;</span><br><span class="line">    width=img.width;</span><br><span class="line">    height=img.height;</span><br><span class="line">    item.setAttribute(&apos;width&apos;,width);</span><br><span class="line">    item.setAttribute(&apos;height&apos;,height);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="新增限制条件"><a href="#新增限制条件" class="headerlink" title="新增限制条件"></a>新增限制条件</h3><p>AppInfo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int WIDTH_MAX_SIZE = 9;</span><br><span class="line"></span><br><span class="line">// &quot;文件大小超出限制&quot;</span><br><span class="line">put( AppInfo.WIDTH_MAX_SIZE, &quot;图片宽度超出限制&quot; );</span><br></pre></td></tr></table></figure></p>
<p>StorageManager.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedImage sourceImg = ImageIO.read(new FileInputStream(tmpFile));</span><br><span class="line">if (sourceImg.getWidth() &gt; 400) &#123;</span><br><span class="line">	tmpFile.delete();</span><br><span class="line">	return new BaseState(false, AppInfo.WIDTH_MAX_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2019/02/17/springboot+mongo分库分表通用策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/springboot+mongo分库分表通用策略/" itemprop="url">springboot+mongo分库分表通用策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T19:30:00+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-boot/" itemprop="url" rel="index">
                    <span itemprop="name">spring boot</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-boot/mongodb/" itemprop="url" rel="index">
                    <span itemprop="name">mongodb</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-boot/mongodb/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景和基本思路"><a href="#背景和基本思路" class="headerlink" title="背景和基本思路"></a>背景和基本思路</h2><p>题库项目开发过程中，选用mongodb作为用户数据储存的数据库，在前期开发过程中，也做了简单的分表策略——按照业务场景分表，即某一科目的考试练习所产生的数据，会进入一个collection，在涉及到mongodb操作的时候，通过以下方法获取操作的集合名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCollectionName</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.collectionName+<span class="string">"_"</span>+skuId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">find</span><span class="params">(Query query, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.find(query, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Query query, Update update, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.update(query, update, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">insert</span><span class="params">(T entity, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.insert(entity, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">save</span><span class="params">(T entity, Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.save(entity, getCollectionName(id));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其它方法略</span></span><br></pre></td></tr></table></figure>
<p>经过一段时间的运行后发现，分表数据产生的严重的倾斜，分析后，于是修改了分表策略，不能按照科目业务分表，于是修改为对用户id进行取余的方式来进行分表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCollectionName</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.collectionName+<span class="string">"_"</span>+skuId % <span class="keyword">this</span>.shardingCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上便是mongodb分表的基本思想，对于mongodb分表这个概念，有点争议，有些人说mongodb自带分片基因，可以通过相应的配置实现mongodb的分片，所以无需分表，在这里暂不考虑分表的必要性，总的来说，当mongodb单个集合数据上亿，在项目实践中感觉还是可以通过分表功能得到很大的缓解。</p>
<h2 id="通用模块"><a href="#通用模块" class="headerlink" title="通用模块"></a>通用模块</h2><p>废话不多说，先上代码。百度云盘<a href="https://pan.baidu.com/s/12RoXqnbWmDMJphvi8v__Cg" target="_blank" rel="noopener">下载</a> 提取码: <code>phf8</code></p>
<p>一个相对独立的模块，如果你的项目使用的是springboot的话，直接复制进去就可以使用了，大可不必过多的描述，但其中也有几点比较特殊的地方，所以还是列出来做些说明：</p>
<h3 id="1、MongoConfig"><a href="#1、MongoConfig" class="headerlink" title="1、MongoConfig"></a>1、MongoConfig</h3><p>由于我们项目是springboot框架，这里就优先说一下这个配置项，搭配springboot的application.properties文件很容易就可以实现mongodb的配置，并且支持多mongo数据源配置，为分库做准备。</p>
<p>application.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#mongodb://[username:password@]host1[:port1][,host2[:port2],¡­[,hostN[:portN]]][/[database][?options]]</span><br><span class="line"># mongdb1</span><br><span class="line">spring.data.mongodb.one.uri=mongodb://127.0.0.1:27017/wpc</span><br><span class="line"># mongdb2</span><br><span class="line">spring.data.mongodb.two.uri=mongodb://112.126.91.194:27017/tiku_dev</span><br></pre></td></tr></table></figure></p>
<p>MongoConfig.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自动注入第一个 mongondb</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.mongodb.one.uri&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String MONGO_URI;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自动注入第二个 mongondb</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.mongodb.two.uri&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String MONGO_URI2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2、dao"><a href="#2、dao" class="headerlink" title="2、dao"></a>2、dao</h3><p>dao包下有两个子包：multimongo和shardcollection，分别是分库和分表的基础类，根据实际需要进行继承即可。</p>
<p>其中分库策略需要借助<code>MultiMongo.java</code>类来选择具体的策略，以及索要使用的mongo库，根据指定注入的对象名来指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MultiMongo</span>(strategy = DefaultDecisionHandler.DEFAULT, specify = <span class="string">"mongoMain"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Title&gt; <span class="title">findTitles</span><span class="params">(Integer status)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>分表策略需要借助<code>ShardingKey.java</code>类，注解在具体操作类的分表依据的字段上来使用，指定分表个数即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ShardingKey</span>(shardingColumn = <span class="string">"userId"</span>, value = <span class="string">"userId"</span>, shardingCount = <span class="number">128</span>)</span><br><span class="line">   <span class="keyword">private</span> Long userId;</span><br></pre></td></tr></table></figure>
<h3 id="3、DBDecisionDaoAop-java"><a href="#3、DBDecisionDaoAop-java" class="headerlink" title="3、DBDecisionDaoAop.java"></a>3、DBDecisionDaoAop.java</h3><p>分库策略的AOP，需要修改<code>doAround</code>方法的注解，进入加有<code>@MultiMongo</code>注解的dao层具体方法前，动态切换指定mongo库。</p>
<h3 id="4、handler"><a href="#4、handler" class="headerlink" title="4、handler"></a>4、handler</h3><p>定义具体的分库信息，默认提供了<code>DefaultDecisionHandler</code>分库策略，即根据指定库名来获取mongo库。也可以参照<code>DateDecisionHandler</code>来扩展我们所需要的分库策略。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2017/07/28/EJS学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/EJS学习总结/" itemprop="url">EJS学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-28T21:50:00+08:00">
                2017-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="一、什么是EJS"><a href="#一、什么是EJS" class="headerlink" title="一、什么是EJS"></a>一、什么是EJS</h3><p>EJS是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。</p>
<h3 id="二、为什么要使用EJS"><a href="#二、为什么要使用EJS" class="headerlink" title="二、为什么要使用EJS"></a>二、为什么要使用EJS</h3><p>与最初的JavaScript相比较，一些不太了解你的代码的人可以更容易地通过EJS模板代码看得懂你的代码。 让我们放松一下，一起来享受下令人激动的干净简洁的感觉。</p>
<p>总之可以让代码更加干净整洁，让人易懂。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/07/28/EJS学习总结/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2017/04/11/MongoDB的增删改查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/11/MongoDB的增删改查/" itemprop="url">MongoDB的增删改查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T21:37:00+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/mongodb/" itemprop="url" rel="index">
                    <span itemprop="name">mongodb</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/mongodb/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="MongoDB-查询所有数据库"><a href="#MongoDB-查询所有数据库" class="headerlink" title="MongoDB 查询所有数据库"></a>MongoDB 查询所有数据库</h3><blockquote>
<p>show dbs;</p>
</blockquote>
<h3 id="MongoDB-切换-创建数据库"><a href="#MongoDB-切换-创建数据库" class="headerlink" title="MongoDB 切换/创建数据库"></a>MongoDB 切换/创建数据库</h3><blockquote>
<p>use DATABASE_NAME;</p>
</blockquote>
<p>如果数据库不存在，则创建数据库，否则切换到指定数据库。</p>
<h3 id="MongoDB-删除数据库"><a href="#MongoDB-删除数据库" class="headerlink" title="MongoDB 删除数据库"></a>MongoDB 删除数据库</h3><blockquote>
<p>db.dropDatabase()</p>
</blockquote>
<p>删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/11/MongoDB的增删改查/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2017/03/30/CKEDITOR拖拽及单例化实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/30/CKEDITOR拖拽及单例化实现/" itemprop="url">CKEDITOR拖拽及单例化实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-30T22:31:00+08:00">
                2017-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><style type="text/css"><br>.sortClass { line-height: 34px; rgin-bottom: 5px; }<br>.editor{ border: 1px solid #ccc; padding: 5px; display: inline-block; width: 80%; }<br></style></p>
<div class="parentClass">

<p></p></div><p></p>
<button type="button" class="btn btn-default add">新增一行</button>

<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="//cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.min.js"></script>
<script src="//cdn.bootcss.com/ckeditor/4.0.1/ckeditor.js"></script>
<script type="text/javascript">
(function(){
    var myCkeditor;
    $('.parentClass').sortable({
        cancel:'.editor',
        update: function (event, ui) {
            ui.item.find('div[contenteditable=true]').blur();
            if (myCkeditor) {
                CKEDITOR.remove(myCkeditor);
                $('#cke_'+myCkeditor.element.$.id).remove();
                myCkeditor = undefined;
            }
            for (var editor in CKEDITOR.instances) {
                $('#cke_'+editor).remove();
                CKEDITOR.remove(CKEDITOR.instances[editor]);
            }
        }
    });
    $('.add').on('click', function(event) {
        event.preventDefault();
        var i = new Date().getTime();
        $('.parentClass').append(htmlTemp(i));
        // CKEDITOR.inline('editor'+i);
    });
    var htmlTemp = function(i){
        var str = [];
        str.push('<div class="sortClass">');
        str.push('<span>选项 </span><div id="editor'+i+'" class="editor" contenteditable="true" placeholder="选项">'+i+'</div>');
        str.push('</div>');
        return str.join('');
    }
    var indexs = [0, 1, 2, 3, 4];
    setTimeout(function(){
        $.each(indexs, function(index, val) {
            $('.parentClass').append(htmlTemp(index));
        });
        // CKEDITOR.inlineAll();
    }, 1000);
    $('.parentClass').off('blur', 'div[contenteditable=true]');
    $('.parentClass').delegate('div[contenteditable=true]', 'blur', function(event){
        event = event || window.event;
        var $target = $(event.target);
        $target.text()==''?$target.html(''):null;
    });
    $('.parentClass').off('focus', 'div[contenteditable=true]');
    $('.parentClass').delegate('div[contenteditable=true]', 'focus', function(event){
        event = event || window.event;
        if (!myCkeditor) {//未实例化
            myCkeditor = CKEDITOR.inline(event.target);
        } else {
            // console.log(myCkeditor.element.$.id);
            // console.log(event.target.id);
            if (myCkeditor.element.$.id === event.target.id) {
            } else {//已实例化，但不是该文本框的实例
                //清除并重新实例化
                CKEDITOR.remove(myCkeditor);
                $('#cke_'+myCkeditor.element.$.id).remove();
                myCkeditor = CKEDITOR.inline(event.target);
            }
        }
    });
})();
</script>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2017/02/26/Java利用WebSocket实现长连接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/26/Java利用WebSocket实现长连接/" itemprop="url">Java利用WebSocket实现长连接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-26T18:30:00+08:00">
                2017-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在java web开发中，考虑性能时其中有一点：尽可能的减少http请求数。这样除了能加快页面加载速度，更大的好处就是为服务器节省资源，降低服务器压力。但是有时候会遇到一些需求，例如需要实时的从服务器获取一些数据信息，我们最快的想到的办法就是写个定时器，不停的向服务器发送请求，来获取最新数据。这样恰恰与我们上边说的相违背。</p>
<p>以前的自己也是这样处理的，这种方式被称为“轮询”。可以想象到，当很多人同时打开网页时，轮询全部开启，服务器同一时间收到的请求会很大，后来慢慢的接触到了websocket，为解决这种问题带来了便利，总结学习一下，以供大家共同学习。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/26/Java利用WebSocket实现长连接/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2016/12/17/jquery.validate自定义验证和返回多种结果/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/17/jquery.validate自定义验证和返回多种结果/" itemprop="url">jquery.validate自定义验证和返回多种结果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-17T21:08:00+08:00">
                2016-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在使用jquery validate做表单验证时遇到如下需求：</p>
<p>验证需要请求服务器，且验证结果有多种情况，要根据不同验证结果提示不同信息。</p>
<p>很显然利用<code>remote</code>是无法满足需求的，所以只能通过自定义验证方法来进行验证，现总结如下：<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/12/17/jquery.validate自定义验证和返回多种结果/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duia.github.io/2016/11/27/spring源码阅读-context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="W鹏程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/pengcheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/27/spring源码阅读-context/" itemprop="url">spring源码阅读-context</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-27T11:25:00+08:00">
                2016-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>入口方法在BeanDefinitionParserDelegate.parseCustomElement：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br></pre></td></tr></table></figure>
<p>parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parserContext.getReaderContext().fatal(</span><br><span class="line">            <span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>localName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。</p>
<h1 id="annotation-config"><a href="#annotation-config" class="headerlink" title="annotation-config"></a>annotation-config</h1><p>AnnotationConfigBeanDefinitionParser.parse:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回null</span></span><br><span class="line">    Object source = parserContext.extractSource(element);</span><br><span class="line">    <span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">            AnnotationConfigUtils.</span><br><span class="line">                registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line">    <span class="comment">// Register component for the surrounding &lt;context:annotation-config&gt; element.</span></span><br><span class="line">    CompositeComponentDefinition compDefinition = </span><br><span class="line">        <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">    parserContext.pushContainingComponent(compDefinition);</span><br><span class="line">    <span class="comment">// Nest the concrete beans in the surrounding component.</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Finally register the composite component.</span></span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">    parserContext.popAndRegisterContainingComponent();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BeanPostProcessor注册"><a href="#BeanPostProcessor注册" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h2><p>AnnotationConfigUtils.registerAnnotationConfigProcessors源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数其实就是DefaultListableBeanFactory,第二个参数为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将registery强转为DefaultListableBeanFactory类型</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> </span><br><span class="line">            ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AnnotationAwareOrderComparator"><a href="#AnnotationAwareOrderComparator" class="headerlink" title="AnnotationAwareOrderComparator"></a>AnnotationAwareOrderComparator</h3><p>其继承体系如下:</p>
<p><img src="http://tu.duia.online/d3cd551dfbc11e93d7b3ef464e4b29ef" alt="Comparator继承体系"></p>
<p>其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考:</p>
<p><a href="http://www.tuicool.com/articles/VnqUv2" target="_blank" rel="noopener">Spring 4.2新特性-使用@Order调整配置类加载顺序</a></p>
<h3 id="ContextAnnotationAutowireCandidateResolver"><a href="#ContextAnnotationAutowireCandidateResolver" class="headerlink" title="ContextAnnotationAutowireCandidateResolver"></a>ContextAnnotationAutowireCandidateResolver</h3><p>此类用以决定一个bean是否可以当作一个依赖的候选者。其类图:</p>
<p><img src="http://tu.duia.online/9fec1500854a988e570244930dec7b6a" alt="ContextAnnotationAutowireCandidateResolver类图"></p>
<h3 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>此类用于处理标注了@Configuration注解的类。类图:</p>
<p><img src="http://tu.duia.online/e5b049a9c5420a98b778b409fa51066a" alt="ConfigurationClassPostProcessor类图"></p>
<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>此类便用于对标注了@Autowire等注解的bean或是方法进行注入。</p>
<p><img src="http://tu.duia.online/7612add63fe6f0307267d9902d31ec0b" alt="AutowiredAnnotationBeanPostProcessor类图"></p>
<h3 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。</p>
<h3 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsr250Present =</span><br><span class="line">    ClassUtils.isPresent(<span class="string">"javax.annotation.Resource"</span>, AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<p>此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图:</p>
<p><img src="http://tu.duia.online/fa4df4ce90fb570855653c7e8f4bf767" alt="CommonAnnotationBeanPostProcessor类图"></p>
<h3 id="PersistenceAnnotationBeanPostProcessor"><a href="#PersistenceAnnotationBeanPostProcessor" class="headerlink" title="PersistenceAnnotationBeanPostProcessor"></a>PersistenceAnnotationBeanPostProcessor</h3><p>用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jpaPresent =	</span><br><span class="line">    ClassUtils.isPresent(<span class="string">"javax.persistence.EntityManagerFactory"</span>, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader()) &amp;&amp;</span><br><span class="line">    <span class="comment">//org.springframework.orm包</span></span><br><span class="line">    ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<p>rt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。</p>
<h3 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系:</p>
<p><img src="http://tu.duia.online/cd1a542d1c14d51080a35a0da3523f0a" alt="EventListenerMethodProcessor类图"></p>
<h3 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a>DefaultEventListenerFactory</h3><p>此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图:</p>
<p><img src="http://tu.duia.online/0c0944f3d37508e5b80b7eca693fec3a" alt="DefaultEventListenerFactory类图"></p>
<h2 id="逻辑关系整理"><a href="#逻辑关系整理" class="headerlink" title="逻辑关系整理"></a>逻辑关系整理</h2><p>普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图:</p>
<p><img src="http://tu.duia.online/d04e58203466f1480dbc93f15e64dc14" alt="CompositeComponentDefinition类图"></p>
<p>最终形成的数据结构如下图:</p>
<p><img src="http://tu.duia.online/49c83baa78343a17ec6107091c13ed05" alt="数据结构"></p>
<p>不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="ConfigurationClassPostProcessor-1"><a href="#ConfigurationClassPostProcessor-1" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>
<p>注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。</p>
<h4 id="postProcessBeanDefinitionRegistry"><a href="#postProcessBeanDefinitionRegistry" class="headerlink" title="postProcessBeanDefinitionRegistry"></a>postProcessBeanDefinitionRegistry</h4><p>此方法大体由两部分组成。</p>
<h5 id="BeanPostProcessor注册-1"><a href="#BeanPostProcessor注册-1" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h5><p>此部分源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    RootBeanDefinition iabpp = <span class="keyword">new</span> RootBeanDefinition(ImportAwareBeanPostProcessor.class);</span><br><span class="line">    iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);</span><br><span class="line">    RootBeanDefinition ecbpp = <span class="keyword">new</span> RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class);</span><br><span class="line">    ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="ImportAwareBeanPostProcessor"><a href="#ImportAwareBeanPostProcessor" class="headerlink" title="ImportAwareBeanPostProcessor"></a>ImportAwareBeanPostProcessor</h6><p>是ConfigurationClassPostProcessor的私有内部类。其类图:</p>
<p><img src="http://tu.duia.online/0468b8bd2da0743c046df44c8b8a633d" alt="ImportAwareBeanPostProcessor类图"></p>
<p>此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起:</p>
<p>有一个类负责生成Student bean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setAge(<span class="number">22</span>);</span><br><span class="line">        student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"importaware"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(StudentConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentConfig studentConfig;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleBean <span class="title">getSimpleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bean依赖</span></span><br><span class="line">        SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean(studentConfig.student());</span><br><span class="line">        <span class="keyword">return</span> simpleBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = </span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(SimpleBeanConfig.class);</span><br><span class="line">    SimpleBean simpleBean = context.getBean(SimpleBean.class);</span><br><span class="line">    System.out.println(simpleBean.getStudent().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以ImportAware接口的作用就是<strong>使被引用的配置类可以获得引用类的相关信息</strong>。</p>
<h6 id="EnhancedConfigurationBeanPostProcessor"><a href="#EnhancedConfigurationBeanPostProcessor" class="headerlink" title="EnhancedConfigurationBeanPostProcessor"></a>EnhancedConfigurationBeanPostProcessor</h6><p>用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。</p>
<h5 id="类解析"><a href="#类解析" class="headerlink" title="类解析"></a>类解析</h5><p>这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。</p>
<h6 id="bean名字生成策略"><a href="#bean名字生成策略" class="headerlink" title="bean名字生成策略"></a>bean名字生成策略</h6><p>对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。</p>
<p>ConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">SingletonBeanRegistry singletonRegistry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">    singletonRegistry = (SingletonBeanRegistry) registry;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; </span><br><span class="line">        <span class="comment">//org.springframework.context.annotation.internalConfigurationBeanNameGenerator</span></span><br><span class="line">        singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.</span><br><span class="line">            getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">        <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">        <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认是一个AnnotationBeanNameGenerator对象，其类图:</p>
<p><img src="http://tu.duia.online/30892dbfe202f07e88c0821639febfc9" alt="BeanNameGenerator类图"></p>
<p>那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: <strong>配置解析、BeanDefinition加载之后，Singleton初始化之前</strong>，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。</p>
<h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h4><p>此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。简略版的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = </span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line">    <span class="comment">//寻找@Configuration的BeanDefinition</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">        Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">             <span class="comment">//替换</span></span><br><span class="line">            beanDef.setBeanClass(enhancedClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConfigurationClassEnhancer.newEnhancer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; superclass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(superclass);</span><br><span class="line">    <span class="comment">//这里印证了前面EnhancedConfigurationBeanPostProcessor的说明</span></span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">    enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    <span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CALLBACK_FILTER是个什么东西呢:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConditionalCallbackFilter CALLBACK_FILTER = </span><br><span class="line">    <span class="keyword">new</span> ConditionalCallbackFilter(CALLBACKS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">    <span class="keyword">new</span> BeanMethodInterceptor(),</span><br><span class="line">    <span class="keyword">new</span> BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">    NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这么做的原因有两个:</p>
<ul>
<li><p>提供Scope支持:</p>
<p>我们可以使用@Scope注解来使用注解的方式配置其Scope:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setAge(<span class="number">22</span>);</span><br><span class="line">    student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。</p>
</li>
<li><p>实现EnhancedConfiguration接口</p>
</li>
</ul>
<h3 id="AutowiredAnnotationBeanPostProcessor-1"><a href="#AutowiredAnnotationBeanPostProcessor-1" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。</p>
<h4 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><h5 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h5><p>其中前者首先被调用，时机是当BeanDefinition被合并(和父Bean)，但是还没有用来创建Bean实例时。回顾下其调用入口:</p>
<p>AbstractAutowireCapableBeanFactory.doCreateBean(简略):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>applyMergedBeanDefinitionPostProcessors:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, </span></span></span><br><span class="line"><span class="function"><span class="params">    String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	 beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findAutowiringMetadata:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">    <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">            metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                &#125;</span><br><span class="line">                metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">                <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>injectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因:</p>
<ul>
<li>假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。</li>
<li>对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。</li>
</ul>
<p>可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。</p>
<p>@Autowire注解的扫描在buildAutowiringMetadata方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = </span><br><span class="line">        <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line">    <span class="comment">//循环检测父类</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =</span><br><span class="line">                <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, <span class="keyword">new</span> ReflectionUtils.FieldCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//不支持静态变量</span></span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">                <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation should be used on </span></span><br><span class="line"><span class="string">                                methods with parameters: "</span> + method);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，<strong>Spring注入注解可以配置在此bean的父类上</strong>。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。</p>
<h5 id="变量扫描"><a href="#变量扫描" class="headerlink" title="变量扫描"></a>变量扫描</h5><p>之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。</p>
<p>ReflectionUtils的实现其实就是访问者模式，其源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithLocalFields</span><span class="params">(Class&lt;?&gt; clazz, FieldCallback fc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Field field : getDeclaredFields(clazz)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.doWith(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>determineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。</p>
<h5 id="方法扫描"><a href="#方法扫描" class="headerlink" title="方法扫描"></a>方法扫描</h5><h6 id="bridge方法"><a href="#bridge方法" class="headerlink" title="bridge方法"></a>bridge方法</h6><p>就是方法扫描的第一行源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br></pre></td></tr></table></figure>
<p>此句代码的作用是<strong>判断method是否是bridge方法，如果是，寻找其真正的方法。</strong>这里的bridge方法并不是所谓的bridge模式。</p>
<p>有这样的demo代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意父类的返回类型是Object</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : MyList.class.getDeclaredMethods()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name: "</span> + method.getName() + <span class="string">", return: "</span> + method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: get, return: class java.lang.String</span><br><span class="line">name: get, return: class java.lang.Object</span><br></pre></td></tr></table></figure>
<p>通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method; returns &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if and only if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method as defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBridge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getModifiers() &amp; Modifier.BRIDGE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。</p>
<p>可以参考: <a href="http://ifeve.com/syntethic-and-bridge-methods/" target="_blank" rel="noopener">Java那些不为人知的特殊方法</a></p>
<p>到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。</p>
<h6 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h6><p>用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。</p>
<h4 id="postProcessPropertyValues"><a href="#postProcessPropertyValues" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><h5 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h5><p>AbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。</p>
<h5 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h5><p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInjection</span><span class="params">(Object bean)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = bean.getClass();</span><br><span class="line">     <span class="comment">// 查找缓存</span></span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, <span class="keyword">null</span>);</span><br><span class="line">    metadata.inject(bean, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。</p>
<h6 id="Field注入"><a href="#Field注入" class="headerlink" title="Field注入"></a>Field注入</h6><p>实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。</p>
<h6 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h6><p>实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。</p>
<h3 id="RequiredAnnotationBeanPostProcessor-1"><a href="#RequiredAnnotationBeanPostProcessor-1" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。</p>
<h4 id="postProcessMergedBeanDefinition-1"><a href="#postProcessMergedBeanDefinition-1" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>空实现，就是这么任性:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	beanName)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="postProcessPropertyValues-1"><a href="#postProcessPropertyValues-1" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.validatedBeanNames.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip(<span class="keyword">this</span>.beanFactory, beanName)) &#123;</span><br><span class="line">            List&lt;String&gt; invalidProperties = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123;</span><br><span class="line">                    invalidProperties.add(pd.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!invalidProperties.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(buildExceptionMessage</span><br><span class="line">                    (invalidProperties, beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.validatedBeanNames.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h5><p>validatedBeanNames是一个Set<string>类型，对于已经检查过的bean，将其name加入Set，防止做无用功。</string></p>
<h5 id="PropertyDescriptor-1"><a href="#PropertyDescriptor-1" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h5><p>从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢?</p>
<p>AbstractAutowireCapableBeanFactory.populateBean相关代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>filterPropertyDescriptorsForDependencyCheck单参数方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) &#123;</span><br><span class="line">    List&lt;PropertyDescriptor&gt; pds =</span><br><span class="line">            <span class="keyword">new</span> LinkedList&lt;PropertyDescriptor&gt;(Arrays.asList(bw.getPropertyDescriptors()));</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;PropertyDescriptor&gt; it = pds.iterator(); it.hasNext();) &#123;</span><br><span class="line">        PropertyDescriptor pd = it.next();</span><br><span class="line">        <span class="keyword">if</span> (isExcludedFromDependencyCheck(pd)) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pds.toArray(<span class="keyword">new</span> PropertyDescriptor[pds.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢?</p>
<p>BeanWrapperImpl.getPropertyDescriptors:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</span><br><span class="line">    <span class="keyword">return</span> getCachedIntrospectionResults().getPropertyDescriptors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> CachedIntrospectionResults <span class="title">getCachedIntrospectionResults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Assert.state(getWrappedInstance() != <span class="keyword">null</span>, <span class="string">"BeanWrapper does not hold a bean instance"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cachedIntrospectionResults == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cachedIntrospectionResults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，这时BeanWrapper便会把自己”内省”一遍。这从侧面说明@Reqired注解只对setter方法有效。</p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>有一个bean如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"simpleBean"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果:</p>
<p><img src="http://tu.duia.online/48f64d414119e0795f9c00f04cad26ea" alt="@Required测试"></p>
<h3 id="CommonAnnotationBeanPostProcessor-1"><a href="#CommonAnnotationBeanPostProcessor-1" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。</p>
<h4 id="postProcessMergedBeanDefinition-2"><a href="#postProcessMergedBeanDefinition-2" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>此方法的执行入口以及调用时机上面已经说过了。其源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	 beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findResourceMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h5><p>可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	 beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是<strong>遍历所有method寻找初始化和销毁方法标记</strong>。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setInitAnnotationType(PostConstruct.class);</span><br><span class="line">    setDestroyAnnotationType(PreDestroy.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个标签来自于javax.annotation包。那么怎么自定义呢?</p>
<p>CommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initAnnotationType"</span> <span class="attr">value</span>=<span class="string">"annotation.Init"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Init是一个很简单的自定义注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Init &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在自己的bean中使用此注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Init</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Init!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Spring便可以看到效果。</p>
<p>另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，<strong>Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持</strong>。为了达到只有一个实例的目的，需要为前面的配置加上ID。</p>
<h5 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h5><p>findResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。</p>
<h4 id="postProcessPropertyValues-2"><a href="#postProcessPropertyValues-2" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>套路很明显了。</p>
<h4 id="postProcessBeforeInitialization"><a href="#postProcessBeforeInitialization" class="headerlink" title="postProcessBeforeInitialization"></a>postProcessBeforeInitialization</h4><p>实现在父类InitDestroyAnnotationBeanPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">    metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeInitMethods:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(Object target, String beanName)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Collection&lt;LifecycleElement&gt; initMethodsToIterate =</span><br><span class="line">            (<span class="keyword">this</span>.checkedInitMethods != <span class="keyword">null</span> ? <span class="keyword">this</span>.checkedInitMethods : <span class="keyword">this</span>.initMethods);</span><br><span class="line">    <span class="keyword">if</span> (!initMethodsToIterate.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleElement element : initMethodsToIterate) &#123;</span><br><span class="line">             <span class="comment">// 反射调用</span></span><br><span class="line">            element.invoke(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过从源码来看应该支持多个init方法。</p>
<h4 id="postProcessBeforeDestruction"><a href="#postProcessBeforeDestruction" class="headerlink" title="postProcessBeforeDestruction"></a>postProcessBeforeDestruction</h4><p>反射调用销毁方法，没啥说的了。</p>
<h3 id="EventListenerMethodProcessor-1"><a href="#EventListenerMethodProcessor-1" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>就一个值得关注的方法: afterSingletonsInstantiated。</p>
<h5 id="入口-2"><a href="#入口-2" class="headerlink" title="入口"></a>入口</h5><p>DefaultListableBeanFactory.preInstantiateSingletons相关源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = </span><br><span class="line">            (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><p>略过。</p>
<h1 id="component-scan"><a href="#component-scan" class="headerlink" title="component-scan"></a>component-scan</h1><p>ComponentScanBeanDefinitionParser.parse源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base-package属性</span></span><br><span class="line">    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">    <span class="comment">// 解析占位符</span></span><br><span class="line">    basePackage = parserContext.getReaderContext().getEnvironment()</span><br><span class="line">        .resolvePlaceholders(basePackage);</span><br><span class="line">    <span class="comment">//分割成数据</span></span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    <span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClassPathBeanDefinitionScanner <span class="title">configureScanner</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> useDefaultFilters = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123;</span><br><span class="line">        useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delegate bean definition registration to scanner class.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = createScanner</span><br><span class="line">        (parserContext.getReaderContext(), useDefaultFilters);</span><br><span class="line">    scanner.setResourceLoader(parserContext.getReaderContext().getResourceLoader());</span><br><span class="line">    scanner.setEnvironment(parserContext.getReaderContext().getEnvironment());</span><br><span class="line">    scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());</span><br><span class="line">    scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123;</span><br><span class="line">        scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    parseBeanNameGenerator(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseScope(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseTypeFilters(element, scanner, parserContext);</span><br><span class="line">    <span class="keyword">return</span> scanner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面开始按顺序分部分说明。</p>
<h3 id="use-default-filters"><a href="#use-default-filters" class="headerlink" title="use-default-filters"></a>use-default-filters</h3><p>component-scan注解会默认扫描喜闻乐见的@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。</p>
<h3 id="扫描器-创建-amp-初始化"><a href="#扫描器-创建-amp-初始化" class="headerlink" title="扫描器:创建 &amp; 初始化"></a>扫描器:创建 &amp; 初始化</h3><p>就是createScanner方法和下面那一坨setter方法，没啥好说的。</p>
<h3 id="resource-pattern"><a href="#resource-pattern" class="headerlink" title="resource-pattern"></a>resource-pattern</h3><p>用以配置扫描器扫描的路径，默认<code>**/*.class</code>。</p>
<h3 id="name-generator"><a href="#name-generator" class="headerlink" title="name-generator"></a>name-generator</h3><p>可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。</p>
<h3 id="scope-resolver"><a href="#scope-resolver" class="headerlink" title="scope-resolver"></a>scope-resolver</h3><p>指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图:</p>
<p><img src="http://tu.duia.online/b0bfa94c5d8e4aca4aa4a2a4dc28fc72" alt="ScopeMetadataResolver类图"></p>
<p>默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。</p>
<h3 id="scoped-proxy"><a href="#scoped-proxy" class="headerlink" title="scoped-proxy"></a>scoped-proxy</h3><p>此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。</p>
<h3 id="exclude-filter-include-filter"><a href="#exclude-filter-include-filter" class="headerlink" title="exclude-filter/include-filter"></a>exclude-filter/include-filter</h3><p>用法示例:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"base"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"javax.annotation.Resource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>parseTypeFilters方法负责此部分的解析，只贴部分源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (INCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addIncludeFilter(typeFilter);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (EXCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addExcludeFilter(typeFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="annotation-config-1"><a href="#annotation-config-1" class="headerlink" title="annotation-config"></a>annotation-config</h3><p>此属性等同于&lt;context:annotation-config /&gt;配置，默认就是true，也就是说，如果配置了context:component-scan其实就没有必要配置annotation-config 了。</p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>入口方法便是ClassPathBeanDefinitionScanner.doScan:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">         <span class="comment">// 逐包扫描</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                 <span class="comment">// 为BeanDefinition设置默认的属性</span></span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations</span><br><span class="line">                    ((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode</span><br><span class="line">                    (scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逐包扫描-BeanDefinition解析"><a href="#逐包扫描-BeanDefinition解析" class="headerlink" title="逐包扫描/BeanDefinition解析"></a>逐包扫描/BeanDefinition解析</h3><p>扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图:</p>
<p><img src="http://tu.duia.online/82b40a73e614cba7ebe65397d8c56963" alt="MetadataReader类图"></p>
<p>对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SimpleMetadataReader(Resource resource, ClassLoader classLoader) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> BufferedInputStream(resource.getInputStream());</span><br><span class="line">    ClassReader classReader;</span><br><span class="line">    classReader = <span class="keyword">new</span> ClassReader(is);</span><br><span class="line"></span><br><span class="line">    AnnotationMetadataReadingVisitor visitor = <span class="keyword">new</span> AnnotationMetadataReadingVisitor(classLoader);</span><br><span class="line">    classReader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.annotationMetadata = visitor;</span><br><span class="line">    <span class="comment">// (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)</span></span><br><span class="line">    <span class="keyword">this</span>.classMetadata = visitor;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析的关键便在于AnnotationMetadataReadingVisitor，其类图:</p>
<p><img src="http://tu.duia.online/c454f6c01aeffa715882fb41a4878fc7" alt="AnnotationMetadataReadingVisitor类图"></p>
<p>核心在于其visitAnnotation方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(<span class="keyword">final</span> String desc, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">    String className = Type.getType(desc).getClassName();</span><br><span class="line">    <span class="keyword">this</span>.annotationSet.add(className);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnnotationAttributesReadingVisitor(</span><br><span class="line">        className, <span class="keyword">this</span>.attributesMap, <span class="keyword">this</span>.metaAnnotationMap, <span class="keyword">this</span>.classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图:</p>
<p><img src="http://tu.duia.online/8ce3498b680dd491f461567ca7258ed7" alt="ScannedGenericBeanDefinition类图"></p>
<h3 id="Scope解析"><a href="#Scope解析" class="headerlink" title="@Scope解析"></a>@Scope解析</h3><p>AnnotationScopeMetadataResolver.resolveScopeMetadata:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScopeMetadata <span class="title">resolveScopeMetadata</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    ScopeMetadata metadata = <span class="keyword">new</span> ScopeMetadata();</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line">         <span class="comment">// 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">                annDef.getMetadata(), <span class="keyword">this</span>.scopeAnnotationType);</span><br><span class="line">        <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// @Scope值</span></span><br><span class="line">            metadata.setScopeName(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">            ScopedProxyMode proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line">            <span class="keyword">if</span> (proxyMode == <span class="keyword">null</span> || proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">                proxyMode = <span class="keyword">this</span>.defaultProxyMode;</span><br><span class="line">            &#125;</span><br><span class="line">            metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>proxyMode和xml的scoped-proxy属性是一个概念:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = <span class="string">"singleton"</span>, proxyMode = ScopedProxyMode.DEFAULT)</span><br></pre></td></tr></table></figure>
<p><strong>XML的属性是全局的配置，这个是局部(针对单个bean)的配置</strong>，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。</p>
<h3 id="bean名字生成"><a href="#bean名字生成" class="headerlink" title="bean名字生成"></a>bean名字生成</h3><p>AnnotationBeanNameGenerator.generateBeanName:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Explicit bean name found.</span></span><br><span class="line">            <span class="keyword">return</span> beanName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line">    <span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="根据注解"><a href="#根据注解" class="headerlink" title="根据注解"></a>根据注解</h4><p>默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">    AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">    Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">    String beanName = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 遍历当前bean拥有的所有类级注解</span></span><br><span class="line">    <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">         <span class="comment">// 获取此注解所有的属性</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line">        <span class="keyword">if</span> (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) &#123;</span><br><span class="line">            Object value = attributes.get(<span class="string">"value"</span>);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String strVal = (String) value;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    beanName = strVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isStereotypeWithNameValue</span><span class="params">(String annotationType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Set&lt;String&gt; metaAnnotationTypes, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// org.springframework.stereotype.Component</span></span><br><span class="line">    <span class="keyword">boolean</span> isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">        (metaAnnotationTypes != <span class="keyword">null</span> &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) ||</span><br><span class="line">        annotationType.equals(<span class="string">"javax.annotation.ManagedBean"</span>) ||</span><br><span class="line">        annotationType.equals(<span class="string">"javax.inject.Named"</span>);</span><br><span class="line">    <span class="keyword">return</span> (isStereotype &amp;&amp; attributes != <span class="keyword">null</span> &amp;&amp; attributes.containsKey(<span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>metaAnnotationTypes用以判断元注解，针对这种情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。</p>
<h4 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h4><p>如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base.SimpleBean -&gt; SimpleBean</span></span><br><span class="line">    String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class="line">    <span class="comment">//SimpleBean -&gt; simpleBean</span></span><br><span class="line">    <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，对于内部类: OuterClassName.InnerClassName -&gt; outerClassName.InnerClassName.</p>
<h3 id="其它注解解析"><a href="#其它注解解析" class="headerlink" title="其它注解解析"></a>其它注解解析</h3><p>入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"student"</span>)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_APPLICATION)</span><br><span class="line"><span class="meta">@Description</span>(<span class="string">"This is a simple bean."</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个”hint”，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。</p>
<h3 id="冲突检测"><a href="#冲突检测" class="headerlink" title="冲突检测"></a>冲突检测</h3><p>Spring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkCandidate</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有同名的，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanDefinition existingDef = <span class="keyword">this</span>.registry.getBeanDefinition(beanName);</span><br><span class="line">    BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();</span><br><span class="line">    <span class="keyword">if</span> (originatingDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        existingDef = originatingDef;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isCompatible(beanDefinition, existingDef)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConflictingBeanDefinitionException(<span class="string">"冲突啦!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isCompatible用于判断和之前的BeanDefinition是否兼容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCompatible</span><span class="params">(BeanDefinition newDefinition, BeanDefinition existingDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//// explicitly registered overriding bean</span></span><br><span class="line">    <span class="keyword">return</span> (!(existingDefinition <span class="keyword">instanceof</span> ScannedGenericBeanDefinition) || </span><br><span class="line">            <span class="comment">//// scanned same file twice</span></span><br><span class="line">            newDefinition.getSource().equals(existingDefinition.getSource()) || </span><br><span class="line">            <span class="comment">// scanned equivalent class twice			</span></span><br><span class="line">            newDefinition.equals(existingDefinition));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<strong>如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的。</strong></p>
<h3 id="代理生成"><a href="#代理生成" class="headerlink" title="代理生成"></a>代理生成</h3><p>入口: ClassPathBeanDefinitionScanner.doScan:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure>
<p>AnnotationConfigUtils.applyScopedProxyMode:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BeanDefinitionHolder <span class="title">applyScopedProxyMode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line">    <span class="comment">// 基本都是从这里跑了</span></span><br><span class="line">    <span class="keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">    <span class="keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点:</p>
<ul>
<li>这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。</li>
<li>被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。</li>
<li>将被代理者以scopedTarget.原名字注册到容器，返回代理者。</li>
<li>代理者和被代理者同时存在于容器中。</li>
</ul>
<p>可以看出，这其实是一个偷天换日的过程。</p>
<p>做个实验:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boostrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">        SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">         System.out.println(bean.getClass().getName());</span><br><span class="line">         context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SimpleBean已开启代理，输出的结果:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base.SimpleBean$$EnhancerBySpringCGLIB$$27256c61</span><br></pre></td></tr></table></figure>
<p>那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢?</p>
<p>DefaultListableBeanFactory.getBean(Class<t> requiredType, Object… args)部分源码:</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] beanNames = getBeanNamesForType(requiredType);</span><br><span class="line"><span class="comment">//不止一个满足条件(代理者和被代理者)</span></span><br><span class="line"><span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">         <span class="comment">// here</span></span><br><span class="line">        <span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">            autowireCandidates.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (autowireCandidates.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        beanNames = autowireCandidates.toArray(<span class="keyword">new</span> String[autowireCandidates.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。</p>
<h3 id="BeanDefinition注册"><a href="#BeanDefinition注册" class="headerlink" title="BeanDefinition注册"></a>BeanDefinition注册</h3><p>你懂的。</p>
<h2 id="Component注册"><a href="#Component注册" class="headerlink" title="Component注册"></a>Component注册</h2><p>套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。</p>
<h1 id="property-override"><a href="#property-override" class="headerlink" title="property-override"></a>property-override</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo:</p>
<p>定义如下的属性文件(property.properties):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.name=dog</span><br></pre></td></tr></table></figure>
<p>格式为: bean名字.属性名字=值。由如下的bean:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>进行如下的配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"property.properties"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行如下的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">    SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">    System.out.println(bean.getStudent().getName());</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的便是dog，而不是skywalker。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下:</p>
<p><img src="http://tu.duia.online/b3a522d200541134265ac2ab1254cded" alt="PropertyOverrideBeanDefinitionParser类图"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码: </p>
<p>AbstractPropertyLoadingBeanDefinitionParser.doParse:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    String location = element.getAttribute(<span class="string">"location"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(location)) &#123;</span><br><span class="line">        String[] locations = StringUtils.commaDelimitedListToStringArray(location);</span><br><span class="line">        builder.addPropertyValue(<span class="string">"locations"</span>, locations);</span><br><span class="line">    &#125;</span><br><span class="line">    String propertiesRef = element.getAttribute(<span class="string">"properties-ref"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(propertiesRef)) &#123;</span><br><span class="line">        builder.addPropertyReference(<span class="string">"properties"</span>, propertiesRef);</span><br><span class="line">    &#125;</span><br><span class="line">    String fileEncoding = element.getAttribute(<span class="string">"file-encoding"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(fileEncoding)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"fileEncoding"</span>, fileEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">    String order = element.getAttribute(<span class="string">"order"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(order)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"order"</span>, Integer.valueOf(order));</span><br><span class="line">    &#125;</span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreResourceNotFound"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-resource-not-found"</span>)));</span><br><span class="line">    builder.addPropertyValue(<span class="string">"localOverride"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"local-override"</span>)));</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="properties-ref"><a href="#properties-ref" class="headerlink" title="properties-ref"></a>properties-ref</h3><p>此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span>  <span class="attr">properties-ref</span>=<span class="string">"property"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"property"</span> <span class="attr">class</span>=<span class="string">"java.util.Properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"student.name"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样便可以看到结果。</p>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。</p>
<h3 id="ignore-resource-not-found"><a href="#ignore-resource-not-found" class="headerlink" title="ignore-resource-not-found"></a>ignore-resource-not-found</h3><p>如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。</p>
<h3 id="ignore-unresolvable"><a href="#ignore-unresolvable" class="headerlink" title="ignore-unresolvable"></a>ignore-unresolvable</h3><p>如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。</p>
<h3 id="local-override"><a href="#local-override" class="headerlink" title="local-override"></a>local-override</h3><p>这个属性让我很迷惑。Spring说是此选项决定”local”的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Properties[] localProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set local properties, e.g. via the "props" tag in XML bean definitions.</span></span><br><span class="line"><span class="comment"> * These can be considered defaults, to be overridden by properties</span></span><br><span class="line"><span class="comment"> * loaded from files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localProperties = <span class="keyword">new</span> Properties[] &#123;properties&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这应该就是Spring所说的”local”属性。好，我们来注入一下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span>  <span class="attr">location</span>=<span class="string">"property.properties"</span> <span class="attr">local-override</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"student.name"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向”local”注入?(context:property-override不允许子标签存在)</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图:</p>
<p><img src="http://tu.duia.online/62625252e36e91a60de225abd66db8da" alt="PropertyOverrideConfigurer类图"></p>
<h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><p>入口当然是BeanFactoryPostProcessor.postProcessBeanFactory(PropertyResourceConfigurer):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 属性加载</span></span><br><span class="line">        Properties mergedProps = mergeProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert the merged properties, if necessary.</span></span><br><span class="line">        convertProperties(mergedProps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let the subclass process the properties.</span></span><br><span class="line">        processProperties(beanFactory, mergedProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性加载"><a href="#属性加载" class="headerlink" title="属性加载"></a>属性加载</h3><p>PropertiesLoaderSupport.mergeProperties:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Properties <span class="title">mergeProperties</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties result = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">        <span class="comment">// Load properties from file upfront, to let local properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Properties localProp : <span class="keyword">this</span>.localProperties) &#123;</span><br><span class="line">            CollectionUtils.mergePropertiesIntoMap(localProp, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">        <span class="comment">// Load properties from file afterwards, to let those properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。</p>
<h3 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h3><p>convertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。</p>
<h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory factory, String beanName, String property, String value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinition bd = factory.getBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">while</span> (bd.getOriginatingBeanDefinition() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bd = bd.getOriginatingBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    PropertyValue pv = <span class="keyword">new</span> PropertyValue(property, value);</span><br><span class="line">    pv.setOptional(<span class="keyword">this</span>.ignoreInvalidKeys);</span><br><span class="line">    bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。</p>
<h1 id="property-placeholder"><a href="#property-placeholder" class="headerlink" title="property-placeholder"></a>property-placeholder</h1><p>这个怎么用已经喜闻乐见了</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。</p>
<p>PropertyPlaceholderBeanDefinitionParser.doParse:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.doParse(element, builder);</span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreUnresolvablePlaceholders"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-unresolvable"</span>)));</span><br><span class="line">    String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp;</span><br><span class="line">            !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"systemPropertiesModeName"</span>, <span class="string">"SYSTEM_PROPERTIES_MODE_"</span></span><br><span class="line">            + systemPropertiesModeName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"value-separator"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"valueSeparator"</span>, element.getAttribute(<span class="string">"value-separator"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"trim-values"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"trimValues"</span>, element.getAttribute(<span class="string">"trim-values"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"null-value"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"nullValue"</span>, element.getAttribute(<span class="string">"null-value"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="system-properties-mode"><a href="#system-properties-mode" class="headerlink" title="system-properties-mode"></a>system-properties-mode</h3><p>Spring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。</p>
<h3 id="value-separator"><a href="#value-separator" class="headerlink" title="value-separator"></a>value-separator</h3><p>用于配置默认的值的分隔符:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"$&#123;student.name:skywalker&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果属性文件里没有student.name，那么就是skywalker。默认就是:。</p>
<h3 id="null-value"><a href="#null-value" class="headerlink" title="null-value"></a>null-value</h3><p>遇到哪些值应该当做空处理，比如可以把空串””设为这个，默认不对任何值进行处理。</p>
<h3 id="trim-values"><a href="#trim-values" class="headerlink" title="trim-values"></a>trim-values</h3><p>是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。</p>
<h3 id="BeanDefinition-1"><a href="#BeanDefinition-1" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>这次是PropertySourcesPlaceholderConfigurer，其类图:</p>
<p><img src="http://tu.duia.online/374e1898d10ab7dfb7cab85d7785c85e" alt="PropertySourcesPlaceholderConfigurer类图"></p>
<h2 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h2><p>PropertySourcesPlaceholderConfigurer.postProcessBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.propertySources = <span class="keyword">new</span> MutablePropertySources();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addLast(</span><br><span class="line">                <span class="keyword">new</span> PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, </span><br><span class="line">                    <span class="keyword">this</span>.environment) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.source.getProperty(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        PropertySource&lt;?&gt; localPropertySource =</span><br><span class="line">                <span class="keyword">new</span> PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addFirst(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addLast(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processProperties(beanFactory, <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources));</span><br><span class="line">    <span class="keyword">this</span>.appliedPropertySources = <span class="keyword">this</span>.propertySources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样:</p>
<p>不使用property-placeholder标签，以显式的bean定义代替。</p>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。</p>
<h1 id="load-time-weaver-amp-spring-configured"><a href="#load-time-weaver-amp-spring-configured" class="headerlink" title="load-time-weaver &amp; spring-configured"></a>load-time-weaver &amp; spring-configured</h1><p>这两个配置是紧密相关的，所以在一起说了。</p>
<p>load-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。</p>
<p>可以参考:</p>
<p><a href="http://sexycoding.iteye.com/blog/1062372" target="_blank" rel="noopener">Spring之LoadTimeWeaver——一个需求引发的思考</a></p>
<p><a href="http://www.iteye.com/topic/481813" target="_blank" rel="noopener">Spring LoadTimeWeaver 的那些事儿</a></p>
<h2 id="javaagent"><a href="#javaagent" class="headerlink" title="javaagent"></a>javaagent</h2><p>要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例:</p>
<p>-javaagent:D:\Software\maven-repos\org\springframework\spring-agent\2.5.6.SEC03\spring-agent-2.5.6.SEC03.jar</p>
<p>此jar包的META-INF/MANIFEST.MF文件需要配置如下一行:</p>
<p>Premain-Class: org.springframework.instrument.InstrumentationSavingAge<br> nt</p>
<p>Spring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationSavingAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instrumentation instrumentation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        instrumentation = inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instrumentation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。</p>
<h3 id="LoadTimeWeaver"><a href="#LoadTimeWeaver" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h3><p>此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系:</p>
<p><img src="http://tu.duia.online/0726e81aba163c9b3a8ef1edec699646" alt="LoadTimeWeaver继承体系"></p>
<p>LoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getBeanClassName</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果配置了weaver-class属性，那么使用其值</span></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.getAttribute(WEAVER_CLASS_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// org.springframework.context.weaving.DefaultContextLoadTimeWeaver</span></span><br><span class="line">    <span class="keyword">return</span> DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个BeanDefinition的id/name又是什么呢?</p>
<p>LoadTimeWeaverBeanDefinitionParser.resolveId:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolveId</span><span class="params">(Element element, AbstractBeanDefinition definition, ParserContext 	parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// loadTimeWeaver</span></span><br><span class="line">    <span class="keyword">return</span> ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。</p>
<h3 id="LoadTimeWeaverBeanDefinitionParser"><a href="#LoadTimeWeaverBeanDefinitionParser" class="headerlink" title="LoadTimeWeaverBeanDefinitionParser"></a>LoadTimeWeaverBeanDefinitionParser</h3><p>LoadTimeWeaverBeanDefinitionParser.doParse:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="keyword">if</span> (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) &#123;</span><br><span class="line">            RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);</span><br><span class="line">            parserContext.registerBeanComponent(</span><br><span class="line">                    <span class="keyword">new</span> BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser().parse(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aspectj-weaving"><a href="#aspectj-weaving" class="headerlink" title="aspectj-weaving"></a>aspectj-weaving</h3><p>这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。</p>
<p>此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。</p>
<h3 id="是否开启"><a href="#是否开启" class="headerlink" title="是否开启"></a>是否开启</h3><p>isAspectJWeavingEnabled方法用于判断是否启用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAspectJWeavingEnabled</span><span class="params">(String value, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"on"</span>.equals(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"off"</span>.equals(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找aop.xml</span></span><br><span class="line">        ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AspectJWeavingEnabler"><a href="#AspectJWeavingEnabler" class="headerlink" title="AspectJWeavingEnabler"></a>AspectJWeavingEnabler</h3><p>从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图:</p>
<p><img src="http://tu.duia.online/ec7d1a908f913e4a515d7d0f8dcd6a6e" alt="AspectJWeavingEnabler类图"></p>
<h3 id="SpringConfiguredBeanDefinitionParser"><a href="#SpringConfiguredBeanDefinitionParser" class="headerlink" title="SpringConfiguredBeanDefinitionParser"></a>SpringConfiguredBeanDefinitionParser</h3><p>如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br></pre></td></tr></table></figure>
<p>其parse方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// org.springframework.context.config.internalBeanConfigurerAspect</span></span><br><span class="line">    <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">         <span class="comment">// org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect</span></span><br><span class="line">        def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);</span><br><span class="line">        def.setFactoryMethodName(<span class="string">"aspectOf"</span>);</span><br><span class="line">        def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        def.setSource(parserContext.extractSource(element));</span><br><span class="line">        parserContext.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition</span><br><span class="line">            (def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图:</p>
<p><img src="http://tu.duia.online/e5f1c7643e36acaf6542da73ab606c32" alt="AnnotationBeanConfigurerAspect类图"></p>
<p>AnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。</p>
<p>下面就去aj文件中看看到底定义了哪些pointcut以及advise。</p>
<p>语法可以参考:</p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/1415606" target="_blank" rel="noopener">Spring 之AOP AspectJ切入点详解</a></p>
<h4 id="切点-pointcut"><a href="#切点-pointcut" class="headerlink" title="切点(pointcut)"></a>切点(pointcut)</h4><h5 id="inConfigurableBean"><a href="#inConfigurableBean" class="headerlink" title="inConfigurableBean"></a>inConfigurableBean</h5><p>在AnnotationBeanConfigurerAspect中定义，源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">inConfigurableBean</span><span class="params">()</span> : @<span class="title">this</span><span class="params">(Configurable)</span></span>;</span><br></pre></td></tr></table></figure>
<p>@this没找到相关说明，结合@以及this的语义，猜测是匹配<strong>带有@Configurable注解(以及作为元注解)的类</strong>。</p>
<h5 id="beanConstruction"><a href="#beanConstruction" class="headerlink" title="beanConstruction"></a>beanConstruction</h5><p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">beanConstruction</span><span class="params">(Object bean)</span> :</span></span><br><span class="line"><span class="function">            <span class="title">initialization</span><span class="params">(ConfigurableObject+.new(..)</span>) &amp;&amp; <span class="title">this</span><span class="params">(bean)</span></span>;</span><br></pre></td></tr></table></figure>
<p>initialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。</p>
<h5 id="preConstructionCondition"><a href="#preConstructionCondition" class="headerlink" title="preConstructionCondition"></a>preConstructionCondition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> &amp;&amp; <span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>由两个pointcut与运算而来。</p>
<h5 id="leastSpecificSuperTypeConstruction"><a href="#leastSpecificSuperTypeConstruction" class="headerlink" title="leastSpecificSuperTypeConstruction"></a>leastSpecificSuperTypeConstruction</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> : <span class="title">initialization</span><span class="params">(ConfigurableObject.new(..)</span>)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="preConstructionConfiguration"><a href="#preConstructionConfiguration" class="headerlink" title="preConstructionConfiguration"></a>preConstructionConfiguration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">preConstructionConfiguration</span><span class="params">()</span> : <span class="title">preConstructionConfigurationSupport</span><span class="params">(*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionConfigurationSupport</span><span class="params">(Configurable c)</span> : @<span class="title">this</span><span class="params">(c)</span> &amp;&amp; <span class="title">if</span> <span class="params">(c.preConstruction()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>preConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。</p>
<h5 id="postConstructionCondition"><a href="#postConstructionCondition" class="headerlink" title="postConstructionCondition"></a>postConstructionCondition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">postConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> &amp;&amp; !<span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>mostSpecificSubTypeConstruction:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(thisJoinPoint.getSignature()</span>.<span class="title">getDeclaringType</span><span class="params">()</span> </span>== thisJoinPoint.getThis().getClass());</span><br></pre></td></tr></table></figure>
<p>advise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。</p>
<h4 id="advise"><a href="#advise" class="headerlink" title="advise"></a>advise</h4><h5 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before(Object bean) :</span><br><span class="line">    beanConstruction(bean) &amp;&amp; preConstructionCondition() &amp;&amp; inConfigurableBean()  &#123;</span><br><span class="line">    configureBean(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行-3"><a href="#运行-3" class="headerlink" title="运行"></a>运行</h2><p>AspectJWeavingEnabler.postProcessBeanFactory:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    enableAspectJWeaving(<span class="keyword">this</span>.loadTimeWeaver, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enableAspectJWeaving:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enableAspectJWeaving</span><span class="params">(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (weaverToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">            weaverToUse = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(beanClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No LoadTimeWeaver available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    weaverToUse.addTransformer(</span><br><span class="line">            <span class="keyword">new</span> AspectJClassBypassingClassFileTransformer(<span class="keyword">new</span> ClassPreProcessorAgentAdapter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h3><p>AspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢?</p>
<p>当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadTimeWeaver</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，关键在于LoadTimeWeaverAwareProcessor，类图:</p>
<p><img src="http://tu.duia.online/cdcad948d03952c35e63e11b6e17bc25" alt="LoadTimeWeaverAwareProcessor类图"></p>
<p>postProcessBeforeInitialization方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> LoadTimeWeaverAware) &#123;</span><br><span class="line">        LoadTimeWeaver ltw = <span class="keyword">this</span>.loadTimeWeaver;</span><br><span class="line">        <span class="keyword">if</span> (ltw == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>,</span><br><span class="line">                <span class="string">"BeanFactory required if no LoadTimeWeaver explicitly specified"</span>);</span><br><span class="line">             <span class="comment">// 去容器找 </span></span><br><span class="line">            ltw = <span class="keyword">this</span>.beanFactory.getBean(</span><br><span class="line">                ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);</span><br><span class="line">        &#125;</span><br><span class="line">        ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。</p>
<p>BeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点:</p>
<p>BeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的:</p>
<p>AbstractApplicationContext.refresh:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>
<p>那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的?</p>
<p>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBeanPostProcessors:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BeanPostProcessor&gt; <span class="title">getBeanPostProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanPostProcessors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br></pre></td></tr></table></figure>
<p>直接将实例添加到BeanFactory中，所以可以得出结论:</p>
<p><strong>我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加</strong>。</p>
<h3 id="BeanClassLoaderAware"><a href="#BeanClassLoaderAware" class="headerlink" title="BeanClassLoaderAware"></a>BeanClassLoaderAware</h3><h4 id="入口-3"><a href="#入口-3" class="headerlink" title="入口"></a>入口</h4><p>DefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢?</p>
<p>AbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="setBeanClassLoader"><a href="#setBeanClassLoader" class="headerlink" title="setBeanClassLoader"></a>setBeanClassLoader</h4><p>这个方法很关键，对instrument的获取就是在这里。源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (serverSpecificLoadTimeWeaver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = serverSpecificLoadTimeWeaver;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> ReflectiveLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显分为三部分。</p>
<h5 id="服务器agent"><a href="#服务器agent" class="headerlink" title="服务器agent"></a>服务器agent</h5><p>Spring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>createServerSpecificLoadTimeWeaver源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> LoadTimeWeaver <span class="title">createServerSpecificLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String name = classLoader.getClass().getName();</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"weblogic"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebLogicLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.glassfish"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GlassFishLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.apache.catalina"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TomcatLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.jboss"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JBossLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"com.ibm"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebSphereLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<strong>对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现</strong>。</p>
<p>这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。</p>
<h5 id="Spring-agent"><a href="#Spring-agent" class="headerlink" title="Spring agent"></a>Spring agent</h5><p>这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInstrumentationAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getInstrumentation() != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AGENT_CLASS_PRESENT) &#123;</span><br><span class="line">        <span class="keyword">return</span> InstrumentationAccessor.getInstrumentation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。</p>
<p>InstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationAccessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstrumentationSavingAgent.getInstrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。</p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW…)，检测的源码位于ReflectiveLoadTimeWeaver的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(classLoader, <span class="string">"ClassLoader must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    <span class="keyword">this</span>.addTransformerMethod = ClassUtils.getMethodIfAvailable(</span><br><span class="line">            <span class="keyword">this</span>.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addTransformerMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档:</p>
<p><a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html#enabling-load-time-weaving" target="_blank" rel="noopener">Chapter 5. Load-Time Weaving</a></p>
<h3 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h3><p>从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。</p>
<p>AspectJClassBypassingClassFileTransformer.transform:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">    <span class="comment">// aspectj自身的类无需检测(织入)，直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (className.startsWith(<span class="string">"org.aspectj"</span>) || className.startsWith(<span class="string">"org/aspectj"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.transform(loader, className, classBeingRedefined, </span><br><span class="line">        protectionDomain, classfileBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图:</p>
<p><img src="http://tu.duia.online/8d15860c9c2c11667b615ebe5e94ba36" alt="ClassPreProcessorAgentAdapter类图"></p>
<p>根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4.</p>
<h3 id="Aj"><a href="#Aj" class="headerlink" title="Aj"></a>Aj</h3><p>Aj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Aj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。</p>
<h4 id="WeavingAdaptor初始化"><a href="#WeavingAdaptor初始化" class="headerlink" title="WeavingAdaptor初始化"></a>WeavingAdaptor初始化</h4><p>初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。</p>
<h5 id="aop-xml"><a href="#aop-xml" class="headerlink" title="aop.xml"></a>aop.xml</h5><h6 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h6><p>aop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的:</p>
<p>以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.AnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.AnnotationCacheAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.JCacheCacheAspect"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么解析后的结果:</p>
<p><img src="http://tu.duia.online/dfecbf68cdc94e14e8b13201b85bfde0" alt="aop.xml解析结果"></p>
<h6 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h6><p>入口方法在ClassLoaderWeavingAdaptor.registerDefinitions:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">registerDefinitions</span><span class="params">(<span class="keyword">final</span> BcelWeaver weaver, <span class="keyword">final</span> ClassLoader loader, List&lt;Definition&gt; definitions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对应&lt;weaver options="-verbose"&gt;</span></span><br><span class="line">    registerOptions(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;exclude&gt;标签</span></span><br><span class="line">    registerAspectExclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;include&gt;标签</span></span><br><span class="line">    registerAspectInclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">// &lt;aspect&gt;</span></span><br><span class="line">    success = registerAspects(weaver, loader, definitions);</span><br><span class="line">    registerIncludeExclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;dump&gt;标签</span></span><br><span class="line">    registerDump(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//忽略返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Spring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/pengcheng.jpg" alt="W鹏程">
            
              <p class="site-author-name" itemprop="name">W鹏程</p>
              <p class="site-description motion-element" itemprop="description">宁在地狱为王，不愿天堂为仆</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/duia" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="duia.online@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">W鹏程</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
